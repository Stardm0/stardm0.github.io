[{"title":"webrtcç¼–è¯‘","url":"/2025/04/14/webrtcç¼–è¯‘/","content":"\nä¸ºäº†ä½¿ç”¨ç¼–è¯‘åçš„webrtcåº“æˆ‘èŠ±äº†å¾ˆå¤šæ—¶é—´ï¼Œç»ˆäºåœ¨ä»Šå¤©è§£å†³äº†å„ä¸ªé—®é¢˜ï¼Œå¹¶æ­£å¼åœ¨è‡ªå·±çš„é¡¹ç›®ä¸­ä½¿ç”¨ã€‚è¯´çœŸçš„å¾ˆç´¯^(*ï¿£(oo)ï¿£)^ã€‚ä½†æˆåŠŸäº†è®©æˆ‘è§‰å¾—è¿™ä¸€åˆ‡éƒ½æ²¡æœ‰ç™½è´¹(â‰§â–½â‰¦q)\n\n**Windows ç¯å¢ƒä¸‹ä¸‹è½½ WebRTC æºç **\n\n---\n\n## ğŸ§° ä¸€ã€å‡†å¤‡å·¥ä½œ\n\n### å®‰è£…å¿…è¦å·¥å…·\n\n#### âœ… Visual Studio\n- å®‰è£… **Visual Studio 2022**\n- å‹¾é€‰ä»¥ä¸‹ç»„ä»¶ï¼š\n  - C++å¼€å‘æ¡Œé¢å·¥ä½œè´Ÿè½½ï¼ˆåŒ…å« MSVCã€Windows 10 SDKï¼‰\n\n---\n\n### å®‰è£… Pythonï¼ˆæ¨è 3.8 ä»¥ä¸Šï¼‰\n> å®‰è£…æ—¶å‹¾é€‰ â€œAdd Python to PATHâ€ã€‚\n\n---\n\n### å®‰è£… Git\nä»å®˜ç½‘ä¸‹è½½å¹¶å®‰è£…ï¼š[https://git-scm.com/download/win](https://git-scm.com/download/win)\n\nå‡è®¾ä½ çš„ä»£ç†åœ°å€æ˜¯ï¼š127.0.0.1:7890\n```bash\ngit config --global http.proxy http://127.0.0.1:7890\ngit config --global https.proxy http://127.0.0.1:7890\n```\n\n---\n\n## ğŸ“¦ äºŒã€ä¸‹è½½ `depot_tools`å¹¶é…ç½®ç¯å¢ƒ\n\n```bash\ngit clone https://chromium.googlesource.com/chromium/tools/depot_tools.git\n```\n\n### é…ç½®ç¯å¢ƒå˜é‡ï¼š\n- å°† `depot_tools` æ‰€åœ¨ç›®å½•æ·»åŠ åˆ°ç³»ç»Ÿçš„ `PATH`\n  - æ§åˆ¶é¢æ¿ â†’ ç³»ç»Ÿ â†’ ç¯å¢ƒå˜é‡ â†’ `Path` â†’ æ·»åŠ ä¸€è¡Œï¼š`C:\\your\\path\\to\\depot_tools`\n- æ·»åŠ ç³»ç»Ÿå˜é‡ \n- ç¼–è¯‘ç›¸å…³\nDEPOT_TOOLS_UPDATE=0 \nDEPOT_TOOLS_WIN_TOOLCHAIN=0 \nGYP_MSVS_OVERRIDE_PATH=C:\\Program Files\\Microsoft Visual Studio\\2022\\Community è¿™ä¸ªå˜é‡å’Œç”Ÿæˆvså·¥ç¨‹æœ‰å…³ï¼Œå°±æ˜¯åœ¨ç¼–è¯‘å‚æ•°æ·»åŠ çš„--ide=vs2022\n\n- ç½‘ç»œç›¸å…³ \nhttp_proxy=ä½ çš„ä»£ç†åœ°å€\nhttps_proxy=ä½ çš„ä»£ç†åœ°å€\nNO_AUTH_BOTO_CONFIG=/youpath/.boto\n\n.botoæ–‡ä»¶çš„å†…å®¹å¦‚ä¸‹\n[Boto]\nproxy = 127.0.0.1\nproxy_port = 7890\nhttps_proxy = 127.0.0.1\nhttps_proxy_port = 7890\n\n---\n\n## â¬‡ï¸ ä¸‰ã€æ‹‰å– WebRTC æºç \n\n### æ‰“å¼€ **x64 Native Tools Command Prompt for VS**ï¼ˆæ¨èä½¿ç”¨è¿™ä¸ªç»ˆç«¯ï¼‰\n\n\n### åˆ›å»ºå·¥ä½œç›®å½•\n\n```powershell\nmkdir webrtc-checkout\ncd webrtc-checkout\n```\n\n### æ‹‰å–æºç ï¼ˆé¦–æ¬¡ä½¿ç”¨ï¼‰\n```powershell\nfetch --nohooks webrtc\n```\n\nâš ï¸ ç¬¬ä¸€æ¬¡ä¼šä¸‹è½½ Chromium æ„å»ºç¯å¢ƒï¼Œæ—¶é—´è¾ƒé•¿ã€‚\n\n---\n\n### è¿›å…¥æºç ç›®å½•å¹¶åŒæ­¥ä¾èµ–\n\n```powershell\ncd src\ngclient sync\n```\n\n---\n\n## ğŸ”§ å››ã€ç”Ÿæˆå’Œæ„å»ºï¼ˆå¯é€‰ï¼‰\n\n### åˆ›å»ºæ„å»ºç›®å½•\n```powershell\ngn gen out/Default\n```\n\nåœ¨out/Default/args.gnæ–‡ä»¶ä¸­\nè®¾ç½®å¦‚ä¸‹ç¼–è¯‘å‚æ•°ï¼š\n\n```\n# Set build arguments here. See `gn help buildargs`.\ntarget_os = \"win\"\ntarget_cpu = \"x64\"\nis_debug = true\nis_clang = true\nuse_custom_libcxx = false\n```\nis_debug = true æ§åˆ¶æ˜¯å¦æ˜¯è°ƒè¯•ç‰ˆæœ¬çš„\n\n### ç¼–è¯‘ï¼ˆä½¿ç”¨ Ninjaï¼‰\n```powershell\nninja -C out/Default --ide=vs2022\n```\nç¼–è¯‘è¿‡ç¨‹ä¸­å¯èƒ½å‡ºç°å°‘é‡è¯­æ³•é—®é¢˜ï¼Œå¯é€šè¿‡è¯¢é—®AIæ‰‹åŠ¨è§£å†³\n\n---\n\n## ğŸ§² äº”ã€åœ¨VSé¡¹ç›®ä¸­ä½¿ç”¨webrtcåº“æ–‡ä»¶\n\néœ€è¦æ·»åŠ ä»¥ä¸‹é¢„ç¼–è¯‘å®å®šä¹‰\nWEBRTC_WIN\nNOMINMAX\nRTC_ENABLE_WIN_WGC\n\né‡‡ç”¨è°ƒè¯•è¿˜è¦æ·»åŠ ä»¥ä¸‹è¿™è¡Œ\n_ITERATOR_DEBUG_LEVEL=0\n","tags":["WebRtc"],"categories":["éŸ³è§†é¢‘"]},{"title":"è¿›ç¨‹ä¸çº¿ç¨‹(2)","url":"/2025/03/17/è¿›ç¨‹ä¸çº¿ç¨‹(2)/","content":"\n## çº¿ç¨‹ç®¡ç†\n\n### çº¿ç¨‹æ§åˆ¶\n\n#### çº¿ç¨‹åˆ›å»º\n\né€šè¿‡`pthread_create`å‡½æ•°åˆ›å»ºçº¿ç¨‹ï¼Œçº¿ç¨‹å¯ä»¥å¹¶å‘æ‰§è¡Œä»»åŠ¡ã€‚ç¤ºä¾‹ä¸­åˆ›å»ºäº†ä¸¤ä¸ªçº¿ç¨‹ï¼Œä¸€ä¸ªç”¨äºè¯»å–æ§åˆ¶å°è¾“å…¥ï¼Œå¦ä¸€ä¸ªç”¨äºå°†æ•°æ®è¾“å‡ºåˆ°æ§åˆ¶å°ã€‚\n\n```c\n#include<pthread.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#define BUF_LEN 1024\n\nchar *buf;\n\nvoid *input_thread(void *argv){\n    int i = 0;\n    while(1){\n        char c = fgetc(stdin);\n        if(c && c != '\\n'){\n            buf[i++] = c;\n        }\n        if(i >= BUF_LEN){\n            i = 0;\n        }\n    }\n}\n\nvoid *output_thread(void *argv){\n    int i = 0;\n    while(1){\n        if(buf[i]){\n            fputc(buf[i], stdout);\n            fputc('\\n', stdout);\n            buf[i++] = 0;\n            if(i >= BUF_LEN){\n                i = 0;\n            }\n        }else{\n            sleep(1);\n        }\n    }\n}\n\n// åˆ›å»ºä¸¤ä¸ªçº¿ç¨‹ ä¸€ä¸ªè¯»å–æ§åˆ¶å°æ•°æ® ä¸€ä¸ªå°†æ•°æ®å†™å‡ºæ§åˆ¶å°\n\n\n\nint main(int argc, char const *argv[])\n{\n    pthread_t pid_input;\n    pthread_t pid_output;\n\n    buf = (char *)malloc(sizeof(char) * BUF_LEN);\n\n    // åˆ›å»ºè¯»çº¿ç¨‹\n    pthread_create(&pid_input, NULL, input_thread, NULL);\n\n    //åˆ›å»ºå†™çº¿ç¨‹\n    pthread_create(&pid_output, NULL, output_thread, NULL);\n\n    //ä¸»çº¿çº¿ç¨‹ç­‰å¾…å­çº¿ç¨‹ç»“æŸ\n    pthread_join(pid_input, NULL);\n    pthread_join(pid_output, NULL);\n\n    free(buf);\n\n    return 0;\n}\n\n```\n\n### çº¿ç¨‹ç»ˆæ­¢\n\nçº¿ç¨‹å¯ä»¥é€šè¿‡`pthread_exit`æˆ–è¿”å›å‡½æ•°å€¼è‡ªç„¶ç»ˆæ­¢ï¼Œä¹Ÿå¯ä»¥é€šè¿‡`pthread_cancel`å¼ºåˆ¶ç»ˆæ­¢ã€‚`pthread_setcanceltype`å¯ä»¥è®¾ç½®å–æ¶ˆç±»å‹ä¸ºå¼‚æ­¥æˆ–å»¶è¿Ÿã€‚\n\n#### detachä¸æŒ‚èµ·ç»ˆæ­¢\n\nä½¿ç”¨`pthread_detach`æ ‡è®°çº¿ç¨‹ä¸ºåˆ†ç¦»çŠ¶æ€ï¼Œçº¿ç¨‹ç»“æŸåè‡ªåŠ¨å›æ”¶èµ„æºï¼Œä¸»çº¿ç¨‹æ— éœ€ç­‰å¾…ã€‚\n```c\n#include<pthread.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n\nvoid *task(void *arg){\n    printf(\"thread started\\n\");\n    sleep(2);\n    printf(\"thread finished\\n\");\n    return NULL;\n}\n\nint main(int argc, char const *argv[])\n{\n    pthread_t tid;\n    pthread_create(&tid, NULL, task, NULL);\n\n    // ä½¿ç”¨detachæ ‡è®° ç­‰çº¿ç¨‹å®Œæˆåå›æ”¶ç›¸å…³èµ„æº\n    pthread_detach(tid);\n\n    // ä¸»çº¿ç¨‹è¿è¡Œå®Œæˆæ¯”åˆ›å»ºçš„çº¿ç¨‹æ…¢\n    printf(\"main thread continues\\n\");\n    sleep(3); //å› ä¸ºä¸»çº¿ç¨‹ä¸ä¼šç­‰å¾… å¦‚æœçˆ¶çº¿ç¨‹å…ˆç»“æŸä¼šå¼ºåˆ¶æ€æ­»å­è¿›ç¨‹\n    printf(\"main thread ending\");\n    return 0;\n}\n\n\n```\n\n#### cancelçš„å»¶è¿Ÿå–æ¶ˆ\n\né€šè¿‡`pthread_cancel`å‘é€å–æ¶ˆè¯·æ±‚ï¼Œçº¿ç¨‹åœ¨é‡åˆ°å–æ¶ˆç‚¹ï¼ˆå¦‚sleepæˆ–pthread_testcancelï¼‰æ—¶æ‰ä¼šç»ˆæ­¢ã€‚\n\n```c\n#include<pthread.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n\nvoid *task(void *arg){\n    printf(\"thread started\\n\");\n    //é»˜è®¤å–æ¶ˆç±»å‹æ˜¯å»¶è¿Ÿ\n    printf(\"working...\");\n    sleep(1); //sleep()ä¼šæ£€æµ‹æ˜¯å¦æœ‰å–æ¶ˆè¯·æ±‚æ ‡è®°\n    //äººä¸ºè°ƒç”¨å–æ¶ˆç‚¹å‡½æ•°\n    pthread_testcancel();\n    printf(\"thread finished\\n\");\n    return NULL;\n}\n\nint main(int argc, char const *argv[])\n{\n    pthread_t tid;\n    pthread_create(&tid, NULL, task, NULL);\n\n    // å–æ¶ˆå­çº¿ç¨‹\n    if (pthread_cancel(tid) != 0)\n    {\n        perror(\"pthread_cancel\");\n    }\n    void *res;\n    // pthread_cancelåªæ˜¯å‘å‡ºä¸€ä¸ªåœæ­¢å‘½ä»¤\n    pthread_join(tid, &res);\n    if(res == PTHREAD_CANCELED){\n        printf(\"çº¿ç¨‹è¢«å–æ¶ˆ\\n\");\n    }else{\n        printf(\"çº¿ç¨‹æ²¡æœ‰è¢«å–æ¶ˆ exit code %ld\\n\", (long)res);\n    }\n\n    return 0;\n}\n\n\n```\n\n#### cancelçš„å¼‚æ­¥å–æ¶ˆå’Œç¦ç”¨å–æ¶ˆ\n\n`pthread_setcancelstate`å¯ä»¥ç¦ç”¨æˆ–å¯ç”¨çº¿ç¨‹çš„å–æ¶ˆå“åº”ï¼Œ`pthread_setcanceltype`è®¾ç½®å–æ¶ˆç±»å‹ä¸ºå¼‚æ­¥ã€‚\n\n\n```c\n#include<pthread.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n\nvoid *task(void *arg){\n    //printf(\"thread started, thread id: %lu\\n\", pthread_self());\n    int oldstate;\n\n    //fflush(stdout); // ç¡®ä¿è¾“å‡ºç«‹å³åˆ·æ–°\n    //printf(\"cancel state disabled, old state: %d\\n\", oldstate);\n    // ç¦ç”¨å–æ¶ˆå“åº”\n    //pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &oldstate);\n\n    printf(\"working...\\n\");\n    fflush(stdout); // ç¡®ä¿è¾“å‡ºç«‹å³åˆ·æ–°\n\n    sleep(1); // sleep() ä¼šæ£€æµ‹æ˜¯å¦æœ‰å–æ¶ˆè¯·æ±‚æ ‡è®°\n\n    printf(\"cancel state check before re-enable, old state: %d\\n\", oldstate);\n    fflush(stdout); // ç¡®ä¿è¾“å‡ºç«‹å³åˆ·æ–°\n\n    // æ¢å¤å–æ¶ˆçŠ¶æ€\n    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &oldstate);\n    printf(\"cancel state enabled, restored old state: %d\\n\", oldstate);\n    fflush(stdout); // ç¡®ä¿è¾“å‡ºç«‹å³åˆ·æ–°\n\n    printf(\"thread finished\\n\");\n    fflush(stdout); // ç¡®ä¿è¾“å‡ºç«‹å³åˆ·æ–°\n\n    return NULL;\n}\n\nint main(int argc, char const *argv[])\n{\n    pthread_t tid;\n    pthread_create(&tid, NULL, task, NULL);\n    // å–æ¶ˆå­çº¿ç¨‹\n    if (pthread_cancel(tid) != 0)\n    {\n        perror(\"pthread_cancel\");\n    }\n    void *res;\n    // pthread_cancel åªæ˜¯å‘å‡ºä¸€ä¸ªåœæ­¢å‘½ä»¤\n    pthread_join(tid, &res);\n    if(res == PTHREAD_CANCELED){\n        printf(\"çº¿ç¨‹è¢«å–æ¶ˆ\\n\");\n    }else{\n        printf(\"çº¿ç¨‹æ²¡æœ‰è¢«å–æ¶ˆ exit code %ld\\n\", (long)res);\n    }\n\n    return 0;\n}\n\n```\n\n### çº¿ç¨‹åŒæ­¥\n\n#### ç«æ€æ¡ä»¶ä¸äº’æ–¥é”\n\nå¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®å…±äº«èµ„æºå¯èƒ½å¯¼è‡´ç«æ€æ¡ä»¶ã€‚ä½¿ç”¨äº’æ–¥é”ï¼ˆ`pthread_mutex_lock`å’Œ`pthread_mutex_unlock`ï¼‰ç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹è®¿é—®å…±äº«èµ„æºã€‚\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<pthread.h>\n\n#define THREAD_COUNT 30000\n\n// åˆå§‹åŒ–é”\nstatic pthread_mutex_t counter_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nvoid *add_thread(void *arg){\n    int *p = (int *)arg;\n    // åœ¨ç´¯åŠ ä¹‹å‰è·å–é” ä¿è¯åªæœ‰ä¸€ä¸ªçº¿ç¨‹è¿›è¡Œç´¯åŠ \n    pthread_mutex_lock(&counter_mutex);\n    (*p)++;\n    // ç´¯åŠ ä¹‹åé‡Šæ”¾é”\n    pthread_mutex_unlock(&counter_mutex);\n    return NULL;\n}\n\nint main(int argc, char const *argv[])\n{\n    pthread_t pid[THREAD_COUNT];\n    int num = 0;\n    for(size_t i = 0; i < THREAD_COUNT; i++){\n        //åˆ›å»ºçš„çº¿ç¨‹åŠŸèƒ½æ˜¯ç»™ä¼ å…¥çš„å‚æ•°åŠ ä¸€\n        pthread_create(pid + i, NULL, add_thread, &num);\n    }\n\n    for (size_t i = 0; i < THREAD_COUNT; i++)\n    {\n        pthread_join(pid[i], NULL);\n    }\n    \n    printf(\"ç´¯åŠ ç»“æœ%d\\n\", num);\n    return 0;\n}\n\n```\n\n#### è¯»å†™é”\n\nè¯»å†™é”ï¼ˆ`pthread_rwlock`ï¼‰å…è®¸å¤šä¸ªçº¿ç¨‹åŒæ—¶è¯»å–å…±äº«èµ„æºï¼Œä½†å†™æ“ä½œéœ€è¦ç‹¬å è®¿é—®ï¼Œé€‚åˆè¯»å¤šå†™å°‘çš„åœºæ™¯ã€‚\n\n```c\n#include<unistd.h>\n#include<stdio.h>\n#include<pthread.h>\n\n//static pthread_rwlock_t rwlock = __PTHREAD_RWLOCK_INITIALIZER;\npthread_rwlock_t rwlock;\nint shared_date = 0;\n\nvoid *lock_write(void *arg){\n    \n    pthread_rwlock_wrlock(&rwlock);\n    int tmp = shared_date + 1;\n    sleep(1);\n    shared_date = tmp;\n    pthread_rwlock_unlock(&rwlock);\n    printf(\"ä½†å‰æ˜¯%s, shared_dateä¸º%d\\n\", (char *)arg, shared_date);\n}\n\nvoid *lock_read(void *arg){\n    // è¯»å†™é”ä¸­çš„åº¦æ˜¯å¯ä»¥ç”±å¤šä¸ªçº¿ç¨‹ç»Ÿä¸€è¯»å–çš„\n    //è·å–è¯»é”\n    pthread_rwlock_rdlock(&rwlock);\n    printf(\"å½“å‰æ˜¯%s,shared_dateä¸º%d\\n\", (char*)arg, shared_date);\n    pthread_rwlock_unlock(&rwlock);\n    \n}\n\nint main(int argc, char const *argv[])\n{\n    //åŠ¨æ€åˆå§‹åŒ–è¯»å†™é”\n    pthread_rwlock_init(&rwlock, NULL);\n\n    pthread_t write1, write2, reader1, reader2, reader3, reader4, reader5, reader6;\n\n    //åˆ›å»ºä¸¤ä¸ªå†™çº¿ç¨‹\n    pthread_create(&write1, NULL, lock_write, \"write1\");\n    pthread_create(&write2, NULL, lock_write, \"write2\");\n\n    // ä¼‘çœ ç­‰å¾…\n    sleep(3);\n\n    pthread_create(&reader1, NULL, lock_read, \"reader1\");\n    pthread_create(&reader2, NULL, lock_read, \"reader2\");\n    pthread_create(&reader3, NULL, lock_read, \"reader3\");\n    pthread_create(&reader4, NULL, lock_read, \"reader4\");\n    pthread_create(&reader5, NULL, lock_read, \"reader5\");\n    pthread_create(&reader6, NULL, lock_read, \"reader6\");\n\n    //ä¸»çº¿ç¨‹ç­‰å¾…åˆ›å»ºçš„å­çº¿ç¨‹è¿è¡Œå®Œæˆ\n    pthread_join(write1, NULL);\n    pthread_join(write2, NULL);\n    pthread_join(reader1, NULL);\n    pthread_join(reader2, NULL);\n    pthread_join(reader3, NULL);\n    pthread_join(reader4, NULL);\n    pthread_join(reader5, NULL);\n    pthread_join(reader6, NULL);\n\n\n    //é”€æ¯è¯»å†™é”\n    pthread_rwlock_destroy(&rwlock);\n    return 0;\n\n}\n\n```\n\n#### è¯»å†™é”çš„å†™é¥¥é¥¿è§£å†³\n\né€šè¿‡è®¾ç½®è¯»å†™é”å±æ€§ï¼ˆ`pthread_rwlockattr_setkind_np`ï¼‰ä¸ºå†™ä¼˜å…ˆï¼Œé¿å…å†™çº¿ç¨‹å› å¤§é‡è¯»çº¿ç¨‹è€Œé•¿æ—¶é—´ç­‰å¾…ã€‚\n\n```c\n#include<unistd.h>\n#include<stdio.h>\n#include<pthread.h>\n\n//static pthread_rwlock_t rwlock = __PTHREAD_RWLOCK_INITIALIZER;\npthread_rwlock_t rwlock;\nint shared_date = 0;\n\nvoid *lock_write(void *arg){\n    \n    printf(\"æˆ‘%sè¦è·å–å†™é”\\n\", (char *)arg);\n    pthread_rwlock_wrlock(&rwlock);\n    int tmp = shared_date + 1;\n    shared_date = tmp;\n    printf(\"å½“å‰æ˜¯%s, shared_dateä¸º%d\\n\", (char *)arg, shared_date);\n    pthread_rwlock_unlock(&rwlock);\n    printf(\"%sé‡Šæ”¾äº†å†™\\né”\", (char*)arg);\n}\n\nvoid *lock_read(void *arg){\n    // è¯»å†™é”ä¸­çš„åº¦æ˜¯å¯ä»¥ç”±å¤šä¸ªçº¿ç¨‹ç»Ÿä¸€è¯»å–çš„\n    //è·å–è¯»é”\n    printf(\"æˆ‘%sè¦è·å–è¯»é”\\n\", (char*)arg);\n    pthread_rwlock_rdlock(&rwlock);\n    printf(\"å½“å‰æ˜¯%s,shared_dateä¸º%d\\n\", (char*)arg, shared_date);\n    sleep(1);\n    pthread_rwlock_unlock(&rwlock);\n    printf(\"%sé‡Šæ”¾äº†è¯»é”\\n\", (char*)arg);\n    \n}\n\nint main(int argc, char const *argv[])\n{\n    //åˆ›å»ºè¯»å†™é”å±æ€§å¯¹è±¡\n    pthread_rwlockattr_t attr;\n    pthread_rwlockattr_init(&attr);\n    //ä¿®æ”¹å¯¹è±¡å±æ€§ è®¾ç½®å†™ä¼˜å…ˆ\n    pthread_rwlockattr_setkind_np(&attr, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);\n    //åŠ¨æ€åˆå§‹åŒ–è¯»å†™é”\n    pthread_rwlock_init(&rwlock, &attr);\n\n    pthread_t write1, write2, reader1, reader2, reader3, reader4, reader5, reader6;\n\n    //åˆ›å»ºä¸¤ä¸ªå†™çº¿ç¨‹\n    pthread_create(&write1, NULL, lock_write, \"write1\");\n\n    pthread_create(&reader1, NULL, lock_read, \"reader1\");\n    pthread_create(&reader2, NULL, lock_read, \"reader2\");\n    pthread_create(&reader3, NULL, lock_read, \"reader3\");\n    // åœ¨çº¿ç¨‹è¯»å–çš„ä¸­é—´è·å–ä¸€ä¸ªå†™é”çš„æ“ä½œ\n    pthread_create(&write2, NULL, lock_write, \"write2\");\n    pthread_create(&reader4, NULL, lock_read, \"reader4\");\n    pthread_create(&reader5, NULL, lock_read, \"reader5\");\n    pthread_create(&reader6, NULL, lock_read, \"reader6\");\n\n    //ä¸»çº¿ç¨‹ç­‰å¾…åˆ›å»ºçš„å­çº¿ç¨‹è¿è¡Œå®Œæˆ\n    pthread_join(write1, NULL);\n    pthread_join(write2, NULL);\n    pthread_join(reader1, NULL);\n    pthread_join(reader2, NULL);\n    pthread_join(reader3, NULL);\n    pthread_join(reader4, NULL);\n    pthread_join(reader5, NULL);\n    pthread_join(reader6, NULL);\n\n\n    //é”€æ¯è¯»å†™é”\n    pthread_rwlock_destroy(&rwlock);\n    return 0;\n\n}\n\n```\n\n#### è‡ªæ—‹é”\n\n**è‡ªæ—‹é”ï¼ˆSpinlockï¼‰**æ˜¯ä¸€ç§ç”¨äºå¤šçº¿ç¨‹æˆ–å¤šæ ¸ç¯å¢ƒä¸‹ä¿æŠ¤å…±äº«èµ„æºçš„åŒæ­¥æœºåˆ¶ã€‚å½“çº¿ç¨‹å°è¯•è·å–é”æ—¶ï¼Œå¦‚æœé”å·²è¢«å ç”¨ï¼Œçº¿ç¨‹ä¼šè¿›å…¥å¿™ç­‰å¾…çŠ¶æ€ï¼ˆè‡ªæ—‹ï¼‰ï¼Œä¸æ–­æ£€æŸ¥é”æ˜¯å¦è¢«é‡Šæ”¾ï¼Œè€Œä¸æ˜¯è¿›å…¥é˜»å¡çŠ¶æ€ã€‚è‡ªæ—‹é”é€‚ç”¨äºé”æŒæœ‰æ—¶é—´è¾ƒçŸ­çš„åœºæ™¯ï¼Œé¿å…çº¿ç¨‹åˆ‡æ¢çš„å¼€é”€ï¼Œä½†é•¿æ—¶é—´è‡ªæ—‹ä¼šæµªè´¹CPUèµ„æºã€‚\n\n#### æ¡ä»¶å˜é‡\n\næ¡ä»¶å˜é‡ï¼ˆ`pthread_cond_wait`å’Œ`pthread_cond_signal`ï¼‰ç”¨äºçº¿ç¨‹é—´é€šä¿¡ï¼Œå…è®¸çº¿ç¨‹åœ¨ç‰¹å®šæ¡ä»¶æ»¡è¶³æ—¶å”¤é†’å…¶ä»–çº¿ç¨‹ã€‚\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<pthread.h>\n\n#define BUFFER_SIZE 5\nint buffer[BUFFER_SIZE];\nint count = 0;\n\n// åˆå§‹åŒ–äº’æ–¥é”\nstatic pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n\n// åˆå§‹åŒ–æ¡ä»¶å˜é‡\nstatic pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n\nvoid * producer(void *arg){\n    int item = 1;\n    //è·å–äº’æ–¥é”\n    pthread_mutex_lock(&mutex);\n    while(1){\n        // å¦‚æœç¼“å†²åŒºå†™æ»¡ ä½¿ç”¨æ¡ä»¶å˜é‡æš‚æ—¶é‡Šæ”¾å½“å‰çº¿ç¨‹\n        if(count == BUFFER_SIZE){\n            //å”¤é†’æ¶ˆè´¹è€…\n            pthread_cond_signal(&cond);\n            pthread_cond_wait(&cond, &mutex);\n        }\n        //ç¼“å†²åŒºæ²¡æœ‰æ»¡\n        buffer[count++] = item++;\n        printf(\"ç™½æœˆå…‰å‘é€äº†ä¸€ä¸ªå¹¸è¿æ•°å­—%d\\n\", buffer[count - 1]);\n\n    }\n    //é‡Šæ”¾\n    pthread_mutex_unlock(&mutex);\n}\nvoid * consumer(void *arg){\n    //è·å–äº’æ–¥é”\n    pthread_mutex_lock(&mutex);\n    while(1){\n        if(count == 0){\n            //å”¤é†’ç”Ÿäº§è€…\n            pthread_cond_signal(&cond);\n            //ç¼“å†²ä¸­æ²¡æœ‰æ¶ˆæ¯å¯è¯»\n            pthread_cond_wait(&cond, &mutex);\n        }\n        printf(\"æˆ‘æ”¶åˆ°ç™½æœˆå…‰çš„å¹¸è¿æ•°å­—%d\\n\", buffer[--count]);\n    }\n    //é‡Šæ”¾\n    pthread_mutex_unlock(&mutex);\n}\n\nint main(int argc, char const *argv[])\n{\n    // åˆ›å»ºä¸¤ä¸ªçº¿ç¨‹\n    pthread_t producer_thread, consumer_thread;\n\n    pthread_create(&producer_thread, NULL, producer,NULL);\n    pthread_create(&consumer_thread, NULL, consumer,NULL);\n\n    pthread_join(producer_thread, NULL);\n    pthread_join(consumer_thread, NULL);\n\n    return 0;\n}\n\n```\n\n\n### çº¿ç¨‹æ± \n\nçº¿ç¨‹æ± æ˜¯ä¸€ç§å¹¶å‘ç¼–ç¨‹æŠ€æœ¯ï¼Œé€šè¿‡é¢„å…ˆåˆ›å»ºä¸€ç»„çº¿ç¨‹å¹¶å¤ç”¨å®ƒä»¬æ¥æ‰§è¡Œä»»åŠ¡ï¼Œé¿å…äº†é¢‘ç¹åˆ›å»ºå’Œé”€æ¯çº¿ç¨‹çš„å¼€é”€ã€‚çº¿ç¨‹æ± çš„æ ¸å¿ƒæ€æƒ³æ˜¯å°†ä»»åŠ¡æäº¤åˆ°ä»»åŠ¡é˜Ÿåˆ—ä¸­ï¼Œç”±æ± ä¸­çš„ç©ºé—²çº¿ç¨‹ä»é˜Ÿåˆ—ä¸­å–å‡ºä»»åŠ¡å¹¶æ‰§è¡Œã€‚å®ƒé€‚ç”¨äºéœ€è¦å¤„ç†å¤§é‡çŸ­ä»»åŠ¡çš„åœºæ™¯ï¼Œèƒ½å¤Ÿæé«˜ç¨‹åºæ€§èƒ½ã€é™ä½èµ„æºæ¶ˆè€—ï¼Œå¹¶ç®€åŒ–çº¿ç¨‹ç®¡ç†ã€‚å¸¸è§çš„çº¿ç¨‹æ± å®ç°åŒ…æ‹¬å›ºå®šå¤§å°çº¿ç¨‹æ± ã€åŠ¨æ€è°ƒæ•´çº¿ç¨‹æ± ç­‰ã€‚\n\n```c\n#include<glib.h>\n#include<stdio.h>\n#include<unistd.h>\n#include<stdlib.h>\n\nvoid task_func(gpointer data, gpointer user_data){\n    int task_num = *(int *)data;\n    free(data);\n    printf(\"å¼€å§‹æ‰§è¡Œ%dä»»åŠ¡\\n\", task_num);\n    sleep(task_num);\n    printf(\"%dä»»åŠ¡æ‰§è¡Œå®Œæˆ\\n\", task_num);\n}\n\nint main(int argc, char const *argv[])\n{\n    //åˆ›å»ºçº¿ç¨‹æ± \n    GThreadPool *pool = g_thread_pool_new(task_func, NULL, 5, TRUE, NULL);\n\n    //å‘çº¿ç¨‹æ± ä¸­æ·»åŠ ä»»åŠ¡\n    for(int i = 0; i < 10; i++){\n        //æ¯ä¸€ä¸ªä»»åŠ¡çš„ç¼–å·\n        int *tmp = (int*)malloc(sizeof(int));\n        *tmp = i + 1;\n\n        g_thread_pool_push(pool, tmp, NULL);\n    }\n\n    g_thread_pool_free(pool, FALSE, TRUE);\n    printf(\"æ‰€æœ‰çš„ä»»åŠ¡éƒ½å®Œæˆäº†\\n\");\n    return 0;\n}\n\n```","tags":["Linux","C"],"categories":["Linuxåº”ç”¨å±‚"]},{"title":"è¿›ç¨‹ä¸çº¿ç¨‹(1)","url":"/2025/03/13/è¿›ç¨‹ä¸çº¿ç¨‹(1)/","content":"\nè¿™é‡Œæˆ‘å°†å­¦ä¹ çš„è¿›ç¨‹ä¸çº¿ç¨‹åˆ†ä¸ºä¸‰ä¸ªå¤§éƒ¨åˆ†\n\n1.è¿›ç¨‹åˆ›å»ºï¼šä½¿ç”¨forkåˆ›å»ºå­è¿›ç¨‹ï¼Œexecveæ‰§è¡Œæ–°ç¨‹åºã€‚\n2.â€‹è¿›ç¨‹é€šä¿¡ï¼šåŒ¿åç®¡é“ã€æœ‰åç®¡é“ã€å…±äº«å†…å­˜ã€æ¶ˆæ¯é˜Ÿåˆ—ã€ä¿¡å·\nâ€‹3.çº¿ç¨‹ç®¡ç†ï¼šçº¿ç¨‹åˆ›å»ºã€ç»ˆæ­¢ã€åŒæ­¥ï¼ˆäº’æ–¥é”ã€è¯»å†™é”ã€æ¡ä»¶å˜é‡ç­‰ï¼‰\nè¦æƒ³è¿›ä¸€æ­¥äº†è§£ç³»ç»Ÿçš„åº•å±‚åŸç†å¯ä»¥å»çœ‹æ“ä½œç³»ç»Ÿç›¸å…³çš„çŸ¥è¯†ï¼Œäº†è§£äº†è§£è¿›ç¨‹çº¿ç¨‹çš„å†…å­˜æ¨¡å‹ï¼Œä»¥åŠè¿›ç¨‹çº¿ç¨‹åœ¨ç³»ç»Ÿä¸Šçš„å·¥ä½œåŸç†ã€‚è¿™é‡Œæœ‰ä¸€ç¯‡ä¸é”™çš„æ–‡ç« \nhttps://zybtree.github.io/2020/08/10/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/\n\n\n## è¿›ç¨‹åˆ›å»º\n\n### ä½¿ç”¨ `fork` åˆ›å»ºå­è¿›ç¨‹\nâ€¢ **`fork` çš„ä½œç”¨**ï¼š`fork` æ˜¯ Linux ç³»ç»Ÿä¸­ç”¨äºåˆ›å»ºå­è¿›ç¨‹çš„ç³»ç»Ÿè°ƒç”¨ã€‚è°ƒç”¨ `fork` åï¼Œçˆ¶è¿›ç¨‹ä¼šå¤åˆ¶ä¸€ä»½è‡ªå·±çš„åœ°å€ç©ºé—´ç»™å­è¿›ç¨‹ï¼Œå­è¿›ç¨‹ä» `fork` è¿”å›å¤„å¼€å§‹æ‰§è¡Œã€‚è¿™é‡Œæ¶‰åŠåˆ°`å†™æ—¶å¤åˆ¶`\nâ€¢ **è¿”å›å€¼**ï¼š\n  â€¢ `-1`ï¼šåˆ›å»ºå¤±è´¥ã€‚\n  â€¢ `0`ï¼šåœ¨å­è¿›ç¨‹ä¸­è¿”å›ã€‚\n  â€¢ `> 0`ï¼šåœ¨çˆ¶è¿›ç¨‹ä¸­è¿”å›å­è¿›ç¨‹çš„ PIDã€‚\nâ€¢ **ä»£ç ç¤ºä¾‹**ï¼š\n  ```c\n#include<stdio.h>\n#include<sys/types.h>\n#include<unistd.h>\n\nint main(int argc, char *argv[]){\n    //è°ƒç”¨forkä¹‹å‰ ä»£ç éƒ½åœ¨çˆ¶è¿›ç¨‹ä¸­è¿è¡Œ\n    printf(\"å½“å‰%d\\n\", getpid());\n\n    /**ä¸éœ€è¦ä¼ å‚\n     * return: int è¿›ç¨‹å·\n     *        (1):-1 å‡ºé”™\n     *        (2): çˆ¶è¿›ç¨‹ä¸­è¡¨ç¤ºå­è¿›ç¨‹çš„PID\n     *        (3): å­è¿›ç¨‹ä¸­æ˜¾ç¤ºä¸º0\n     * __pid_t fork (void)\n     */\n    //ä½¿ç”¨forkåˆ›å»ºå­è¿›ç¨‹ forkä¹‹åæ‰€æœ‰çš„ä»£ç éƒ½æ˜¯åœ¨çˆ¶å­è¿›ç¨‹ä¸­å„è‡ªæ‰§è¡Œä¸€é\n    pid_t pid = fork();\n    \n    //printf(\"%d\\n\", pid);\n    if(pid < 0){\n        printf(\"å­è¿›ç¨‹åˆ›å»ºå¤±è´¥!\");\n        return 1;\n    }else if(pid == 0){\n        //å½“å‰ä¸ºå­è¿›ç¨‹\n        printf(\"å­è¿›ç¨‹ %d åˆ›å»ºæˆåŠŸ! çˆ¶è¿›ç¨‹æ˜¯ %d\\n\", getpid(), getppid());\n    }else{\n        //å½“å‰ä¸ºçˆ¶è¿›ç¨‹\n        printf(\"å½“å‰ä¸ºçˆ¶è¿›ç¨‹ %d å­è¿›ç¨‹æ˜¯ %d\\n\", getpid(), pid);\n    }\n    return 0;\n}\n  ```\n\n### ä½¿ç”¨ `execve` æ‰§è¡Œæ–°ç¨‹åº\nâ€¢ **`execve` çš„ä½œç”¨**ï¼š`execve` ç”¨äºæ›¿æ¢å½“å‰è¿›ç¨‹çš„åœ°å€ç©ºé—´ä¸ºæ–°çš„ç¨‹åºï¼Œå¹¶æ‰§è¡Œè¯¥ç¨‹åºã€‚è°ƒç”¨æˆåŠŸåï¼ŒåŸç¨‹åºçš„ä»£ç å’Œæ•°æ®è¢«æ–°ç¨‹åºæ›¿æ¢ã€‚è¿™ä¹Ÿæ„å‘³ç€è¯¥è¿›ç¨‹çš„pidä¿æŒä¸å˜\nâ€¢ **ä»£ç ç¤ºä¾‹**ï¼š\n  ```c\n#include<stdio.h>\n#include<unistd.h>\n\nint main(int argc, char *argv[]){\n    //è·³è½¬ä¹‹å‰\n    char *name = \"banzhang\";\n    printf(\"æˆ‘æ˜¯%s ç¼–å·%d\\n\", name, getpid());\n\n    //æ‰§è¡Œè·³è½¬\n    /**\n     * const char *__path: æ‰§è¡Œç¨‹åºçš„è·¯å¾„\n     * char *const __argv[]ï¼šä¼ å…¥å‚æ•° -> å¯¹åº”æ‰§è¡Œç¨‹åºmainæ–¹æ³•çš„ç¬¬äºŒä¸ªå‚æ•°\n     *      (1): ç¬¬ä¸€ä¸ªå‚æ•°å›ºå®šæ˜¯ç¨‹åºçš„åç§° -> æ‰§è¡Œçš„ç¨‹åºè·¯å¾„\n     *      (2): æ‰§è¡Œç¨‹åºè¦ä¼ å…¥çš„å‚æ•°\n     *      (3): ç»“å°¾çš„æœ€åä¸€ä¸ªå‚æ•°ä¸€å®šæ˜¯NULL\n     * char *const __envp[]: ä¼ é€’çš„ç¯å¢ƒå˜é‡\n     *      (1): ç¯å¢ƒå˜é‡å‚æ•°: key=value\n     *      (2): æœ€åä¸€ä¸ªå‚æ•°ä¸ºNULL\n     * return: æˆåŠŸæ ¹æœ¬æ²¡æ³•è¿”å› ä¸‹é¢çš„ä»£ç ä¹Ÿæ²¡æœ‰æ„ä¹‰ å¤±è´¥è¿”å›-1;\n     * int execve (const char *__path, char *const __argv[], char *const __envp[])\n     */\n    char *args[] = {\"/home/stream/process_test/erlou\", name, NULL};\n    char *envs[] = {\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin\",NULL};\n    int re = execve(args[0], args, envs);\n    if(re == -1){\n        printf(\"è°ƒç”¨ç¨‹åºå¤±è´¥!\\n\");\n        return 1;\n    }\n\n    return 0;\n}\n  ```\n\n---\n\n## è¿›ç¨‹é€šä¿¡\n\n### åŒ¿åç®¡é“\nâ€¢ **åŒ¿åç®¡é“çš„ç‰¹ç‚¹**ï¼šåŠåŒå·¥é€šä¿¡ï¼Œåªèƒ½ç”¨äºæœ‰äº²ç¼˜å…³ç³»çš„è¿›ç¨‹é—´é€šä¿¡ã€‚åŒæ—¶ä¿æŒä¸€ä¸ªè¯»ä¸€ä¸ªå†™çš„åŸåˆ™\nâ€¢ **ä»£ç ç¤ºä¾‹**ï¼š\n  ```c\n#include<sys/types.h>\n#include<sys/wait.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<string.h>\n\nint main(int argc, char *argv[]){\n    pid_t cpid;\n    int pipefd[2];\n\n    //å°†ç¨‹åºä¼ è¿‘æ¥çš„ç¬¬ä¸€ä¸ªå‘½ä»¤è¡Œå‚æ•° é€šè¿‡ç®¡é“ä¼ è¾“ç»™å­è¿›ç¨‹\n    if(argc != 2){\n        fprintf(stderr, \"%s:è¯·å¡«å†™éœ€è¦ä¼ é€’çš„ä¿¡æ¯!\\n\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n\n    //åˆ›å»ºç®¡é“\n    if(pipe(pipefd) == -1){\n        perror(\"åˆ›å»ºç®¡é“å¤±è´¥\");\n        exit(EXIT_FAILURE);\n    }\n\n    //å¤åˆ¶çˆ¶å­è¿›ç¨‹\n    cpid = fork();\n    if(cpid == -1){\n        perror(\"é‚€è¯·æ–°å­¦å‘˜å¤±è´¥\");\n        exit(EXIT_FAILURE);\n    }\n    if(cpid == 0){\n        //å­è¿›ç¨‹ è¯»å–ç®¡é“çš„æ•°æ® æ‰“å°åˆ°æ§åˆ¶å°\n        //write(pipefd[1], argv[1], strlen(argv[1]));\n        close(pipefd[1]);\n        char str[100] = {0};\n        sprintf(str, \"æ–°å­¦å‘˜ %dæ¥å—ä¿¡æ¯\\n\", getpid());\n        write(STDOUT_FILENO, &str, sizeof(str));\n        char buf;\n        while(read(pipefd[0], &buf, 1) > 0){\n            write(STDOUT_FILENO, &buf, 1);\n        }\n        write(STDOUT_FILENO, \"\\n\", 1);\n        close(pipefd[0]);\n        _exit(EXIT_SUCCESS);\n    }else{\n        //çˆ¶è¿›ç¨‹ å†™å…¥ç®¡é“æ•°æ® æ‰“å°åˆ°æ§åˆ¶å°\n        //close(pipefd[0]);\n        // å°†æ•°æ®å†™å…¥\n        printf(\"è€å­¦å‘˜%då¯¹æ–°å­¦å‘˜ä¼ é€’ä¿¡æ¯\\n\", getpid());\n        write(pipefd[1], argv[1], strlen(argv[1]));\n        close(pipefd[1]);\n        waitpid(cpid, NULL, 0);\n        // char buf;\n        // while(read(pipefd[0], &buf, 1) > 0){\n        //     write(STDOUT_FILENO, &buf, 1);\n        // }\n        // write(STDOUT_FILENO, \"\\n\", 1);\n        close(pipefd[0]);\n        exit(EXIT_SUCCESS);\n    }\n    return 0;\n}\n  ```\n\n### æœ‰åç®¡é“\nâ€¢ **æœ‰åç®¡é“çš„ç‰¹ç‚¹**ï¼šå…è®¸æ— äº²ç¼˜å…³ç³»çš„è¿›ç¨‹é—´é€šä¿¡ï¼Œé€šè¿‡æ–‡ä»¶ç³»ç»Ÿä¸­çš„ç‰¹æ®Šæ–‡ä»¶å®ç°ã€‚\nâ€¢ **å†™è¿›ç¨‹ä»£ç ç¤ºä¾‹**ï¼š\n  ```c\n#include<sys/stat.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<fcntl.h>\n#include<string.h>\n#include<errno.h>\n\nint main(int argc, char *argv[]){\n    int fd;\n    char *pipe_path = \"/tmp/myfifo\";\n    if(mkfifo(pipe_path, 0664) != 0){\n        perror(\"mkfifo\");\n        exit(EXIT_FAILURE);\n    }\n    //å¯¹æœ‰åç®¡é“çš„ç‰¹æ®Šæ–‡ä»¶ åˆ›å»ºfd\n    fd = open(pipe_path, O_WRONLY);\n    if(fd == -1){\n        perror(\"open\");\n        exit(EXIT_FAILURE);\n    }\n    char buf[100];\n    size_t read_num;\n    while((read_num = read(STDIN_FILENO, buf, 100)) > 0){\n        write(fd, buf, read_num);\n    }\n    if(read_num < 0){\n        perror(\"read\");\n        close(fd);\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"å‘é€æ•°æ®åˆ°ç®¡é“å®Œæˆ è¿›ç¨‹ç»ˆæ­¢\");\n    close(fd);\n    if(unlink(pipe_path) == -1){\n        perror(\"unlink\");\n    }\n\n    return 0;\n}\n  ```\n\nâ€¢ **è¯»è¿›ç¨‹ä»£ç ç¤ºä¾‹**ï¼š\n  ```c\n#include<sys/stat.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<fcntl.h>\n#include<string.h>\n#include<errno.h>\n\nint main(int argc, char *argv[]){\n    int fd;\n    char *pipe_path = \"/tmp/myfifo\";\n\n    //å¯¹æœ‰åç®¡é“çš„ç‰¹æ®Šæ–‡ä»¶ åˆ›å»ºfd\n    fd = open(pipe_path, O_RDONLY);\n    if(fd == -1){\n        perror(\"open\");\n        exit(EXIT_FAILURE);\n    }\n    char buf[100];\n    size_t read_num;\n    while((read_num = read(fd, buf, 100)) > 0){\n        write(STDOUT_FILENO, buf, read_num);\n    }\n\n    if(read_num < 0){\n        perror(\"read\");\n        close(fd);\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"æ¥å—ç®¡é“æ•°æ®å®Œæˆ è¿›ç¨‹ç»ˆæ­¢\");\n    close(fd);\n\n    return 0;\n}\n  ```\n\n### å…±äº«å†…å­˜\nâ€¢ **å…±äº«å†…å­˜çš„ç‰¹ç‚¹**ï¼šå¤šä¸ªè¿›ç¨‹å…±äº«åŒä¸€å—å†…å­˜åŒºåŸŸï¼Œæ˜¯æœ€å¿«çš„è¿›ç¨‹é—´é€šä¿¡æ–¹å¼ã€‚\nâ€¢ **ä»£ç ç¤ºä¾‹**ï¼š\n  ```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<unistd.h>\n#include<fcntl.h>\n#include<sys/mman.h>\n#include<sys/wait.h>\n#include<string.h>\n\nint main(int argc, char const *argv[])\n{\n    char *share;\n    // åˆ›å»ºä¸€ä¸ªå…±äº«å†…å­˜å¯¹è±¡\n    char shm_name[100]  ={0};\n    sprintf(shm_name, \"/letter%d\", getpid());\n    int fd;\n    fd = shm_open(shm_name, O_RDWR | O_CREAT, 0664);\n    if(fd < 0){\n        perror(\"shm_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    // è®¾ç½®å…±äº«å†…å­˜å¤§å°\n    ftruncate(fd, 1024);\n\n    // å†…å­˜æ˜ å°„\n    share = mmap(NULL, 1024, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    if(share == MAP_FAILED){\n        perror(\"mmap\");\n        exit(EXIT_FAILURE);\n    }\n\n    // æ˜ å°„å®Œæˆä¹‹åå…³é—­fdè¿æ¥ ä¸æ˜¯é‡Šæ”¾\n    close(fd);\n\n    // ä½¿ç”¨å†…å­˜æ˜ å°„å®ç°è¿›ç¨‹é—´çš„é€šè®¯\n    pid_t pid = fork();\n    if(pid < 0){\n        perror(\"fork\");\n        exit(EXIT_FAILURE);\n    }\n    if(pid == 0){\n        strcpy(share, \"ä½ æ˜¯ä¸ªå¥½äºº\\n\");\n        printf(\"æ–°å­¦å‘˜%då®Œæˆå›ä¿¡\\n\", getpid());\n    }else{\n        waitpid(pid, NULL, 0);\n        printf(\"è€å­¦å‘˜%dæ”¶åˆ°äº†æ–°å­¦å‘˜%dçš„å›ä¿¡:%s\", getpid(), pid, share);\n\n        // é‡Šæ”¾æ˜ å°„åŒº\n        int re = munmap(share, 1024);\n        if(re == -1){\n            perror(\"munmap\");\n            exit(EXIT_FAILURE);\n        }\n        // é‡Šæ”¾å…±äº«å†…å­˜å¯¹è±¡\n        shm_unlink(shm_name);\n    }\n\n    return 0;\n}\n  ```\n\n### æ¶ˆæ¯é˜Ÿåˆ—\nâ€¢ **æ¶ˆæ¯é˜Ÿåˆ—çš„ç‰¹ç‚¹**ï¼šå…è®¸è¿›ç¨‹é€šè¿‡æ¶ˆæ¯é˜Ÿåˆ—å‘é€å’Œæ¥æ”¶æ¶ˆæ¯ï¼Œæ”¯æŒæ— äº²ç¼˜å…³ç³»çš„è¿›ç¨‹é—´é€šä¿¡ã€‚\nâ€¢ **æ¶ˆè´¹è€…ä»£ç ç¤ºä¾‹**ï¼š\n  ```c\n#include<mqueue.h>\n#include<stdio.h>\n#include<time.h>\n#include<string.h>\n#include<unistd.h>\n#include<stdlib.h>\n\nint main(int argc, char const *argv[])\n{\n    //åˆ›å»ºæ¶ˆæ¯é˜Ÿåˆ—\n    struct mq_attr attr;\n\n    //æœ‰ç”¨çš„å‚æ•° è¡¨ç¤ºæ¶ˆæ¯é˜Ÿåˆ—çš„å®¹é‡\n    attr.mq_maxmsg = 10;\n    attr.mq_msgsize = 100;\n\n    // ç”¨mq_openæ—¶è¢«å¿½ç•¥çš„å‚æ•°\n    attr.mq_flags = 0;\n    attr.mq_curmsgs = 0;\n    \n    char *mq_name = \"/p_c_mq\";\n    mqd_t mqdes = mq_open(mq_name, O_RDWR | O_CREAT, 0664, &attr);\n    if(mqdes == (mqd_t)-1){\n        perror(\"mq_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    //ä¸æ–­æ¥æ”¶æ§åˆ¶å°ä¸­çš„æ•°æ® å‘é€åˆ°æ¶ˆæ¯é˜Ÿåˆ—\n    char read_buf[100];\n    struct timespec time_info;\n\n    while(1){\n        memset(read_buf, 0, 100);\n\n        clock_gettime(0, &time_info);\n        time_info.tv_sec += 15;\n        // è¯»å–æ¶ˆæ¯é˜Ÿåˆ—çš„æ•°æ®\n        if (mq_timedreceive(mqdes, read_buf, 100, NULL, &time_info) == -1)\n        {\n            perror(\"mq_tiemreceive\");\n        }\n\n        //åˆ¤æ–­å½“å‰æ•°æ®æ˜¯å¦ä¸ºç»“æŸä¿¡æ¯\n        if(read_buf[0] == EOF){\n            printf(\"æ¥æ”¶åˆ°ç”Ÿäº§è€…å‘é€çš„ç»“æŸä¿¡æ¯ å‡†å¤‡é€€å‡º...\\n\");\n            break;\n        }\n\n\n        //æ­£å¸¸çš„è¯»å–çš„æ¶ˆæ¯é˜Ÿåˆ—ä¿¡æ¯æ‰“å°åˆ°æ§åˆ¶å°\n\n        printf(\"æ¥æ”¶åˆ°æ¥è‡ªç”Ÿäº§è€…å‘é€çš„çš„æ¶ˆæ¯ï¼š%s\\n\", read_buf);\n    }\n\n    //å…³é—­æ¶ˆæ¯é˜Ÿåˆ—æè¿°ç¬¦\n    close(mqdes);\n\n    //æ¸…é™¤æ¶ˆæ¯é˜Ÿåˆ—\n    mq_unlink(mq_name);\n\n    return 0;\n}\n  ```\n\nâ€¢ **ç”Ÿäº§è€…ä»£ç ç¤ºä¾‹**ï¼š\n  ```c\n#include<mqueue.h>\n#include<stdio.h>\n#include<time.h>\n#include<string.h>\n#include<unistd.h>\n#include<stdlib.h>\n\nint main(int argc, char const *argv[])\n{\n    //åˆ›å»ºæ¶ˆæ¯é˜Ÿåˆ—\n    struct mq_attr attr;\n\n    //æœ‰ç”¨çš„å‚æ•° è¡¨ç¤ºæ¶ˆæ¯é˜Ÿåˆ—çš„å®¹é‡\n    attr.mq_maxmsg = 10;\n    attr.mq_msgsize = 100;\n\n    // ç”¨mq_openæ—¶è¢«å¿½ç•¥çš„å‚æ•°\n    attr.mq_flags = 0;\n    attr.mq_curmsgs = 0;\n    \n    char *mq_name = \"/p_c_mq\";\n    mqd_t mqdes = mq_open(mq_name, O_RDWR | O_CREAT, 0664, &attr);\n    if(mqdes == (mqd_t)-1){\n        perror(\"mq_open\");\n        exit(EXIT_FAILURE);\n    }\n\n    //ä¸æ–­æ¥æ”¶æ§åˆ¶å°ä¸­çš„æ•°æ® å‘é€åˆ°æ¶ˆæ¯é˜Ÿåˆ—\n    char write_buf[100];\n    struct timespec time_info;\n\n    while(1){\n        memset(write_buf, 0, 100);\n        ssize_t read_count = read(0, write_buf, 100);\n        clock_gettime(0, &time_info);\n        time_info.tv_sec += 5;\n        if(read_count == -1){\n            perror(\"read\");\n            continue;\n        }else if(read_count == 0){\n            // å°±æ˜¯åœ¨æ§åˆ¶å°ä¸­è¾“å…¥ ctrl + dçš„æ—¶å€™\n            printf(\"EOF, exit..\\n\");\n            char eof = EOF;\n            if (mq_timedsend(mqdes, &eof, 1, 0, &time_info) == -1)\n            {\n                perror(\"mq-timesend\");\n            }\n            break;\n        }\n\n        //æ­£å¸¸æ¥æ”¶æ§åˆ¶å°æ•°æ®å¹¶å‘é€\n        if (mq_timedsend(mqdes, write_buf, strlen(write_buf), 0, &time_info) == -1)\n        {\n            perror(\"mq-timesend\");\n        }\n        printf(\"ä»å‘½ä»¤è¡Œæ¥æ”¶çš„æ•°æ®å·²ç»å‘é€ç»™æ¶ˆæ¯é˜Ÿåˆ—\\n\");\n    }\n\n    //å…³é—­æ¶ˆæ¯é˜Ÿåˆ—æè¿°ç¬¦\n    close(mqdes);\n\n    return 0;\n}\n  ```\n\n### ä¿¡å·é‡\nä¿¡å·é‡æœºåˆ¶ç”±`ä¿¡å·é‡` å’Œ`P, Væ“ä½œ`ä¸¤éƒ¨åˆ†ç»„æˆ, `ä¿¡å·é‡`æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„å˜é‡, æ˜¯è¿›ç¨‹ä¼ é€’çš„ä¸€ä¸ªæ•´æ•°æ•°å€¼ï¼Œåªèƒ½è¢«ä¸¤ä¸ªæ ‡å‡†åŸè¯­æ‰€è®¿é—®ï¼ŒåŠp(waitæ“ä½œ)æ“ä½œ, v(signalæ“ä½œ)æ“ä½œã€‚Pæ˜¯é˜»å¡åŸè¯­ï¼ŒVæ˜¯å”¤é†’åŸè¯­ã€‚På¯¹ä¿¡å·é‡å€¼-1å, å°äº0åˆ™æ‰§è¡Œé˜»å¡æ“ä½œã€‚åä¹‹V +1åï¼Œ å¤§äºç­‰äºé›¶æ—¶ä¸æ‰§è¡Œå”¤é†’æ“ä½œï¼Œå°äº0åˆ™å”¤é†’ä¸€ä¸ªç­‰å¾…è¿›ç¨‹ï¼Œç»§ç»­æ‰§è¡Œ\n\nâ€¢ **æ— åä¿¡å·é‡**\né€šè¿‡å…±äº«å†…å­˜çš„æ–¹å¼å®ç°è¿›ç¨‹é—´çš„é€šè®¯\n```c\n#include<pthread.h>\n#include<stdio.h>\n#include<unistd.h>\n#include<fcntl.h>\n#include<semaphore.h>\n#include<sys/mman.h>\n#include<sys/stat.h>\n#include<sys/types.h>\n#include<sys/wait.h>\n\nint main(int argc, char const *argv[])\n{\n    char *shm_name = \"unnamed_sem_shm\";\n    //åˆ›å»ºå…±äº«å†…å­˜\n    int fd = shm_open(shm_name, O_CREAT | O_RDWR, 0666);\n    //è°ƒæ•´å…±äº«å†…å­˜å¤§å°\n    ftruncate(fd, sizeof(sem_t));\n    //å®Œæˆæ˜ å°„\n    sem_t *sem = mmap(NULL, sizeof(sem_t), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    //åˆå§‹åŒ–ä¿¡å·é‡\n    sem_init(sem,1, 0);\n    //åˆ›å»ºçˆ¶å­è¿›ç¨‹\n    pid_t pid = fork();\n    if(pid < 0){\n        perror(\"fork\");\n    }else if(pid == 0){\n        sleep(1);\n        printf(\"è¿™æ˜¯å­è¿›ç¨‹\\n\");\n        sem_post(sem);\n    }else{\n        sem_wait(sem);\n        printf(\"è¿™æ˜¯çˆ¶è¿›ç¨‹\\n\");\n        waitpid(pid, NULL, 0);\n    }\n\n    //å›æ”¶èµ„æº\n    if(pid > 0){\n        if(sem_destroy(sem) == -1){\n            perror(\"sem_destroy\");\n        }\n\n    }\n    if(munmap(sem, sizeof(sem_t)) == -1){\n        perror(\"munmap\");\n    }\n    if(close(fd) == -1){\n        perror(\"close\");\n    }\n    if(pid > 0){\n        if(shm_unlink(shm_name) == -1){\n            perror(\"shm_unlink\");\n        }\n    }\n    return 0;\n}\n\n\n```\n\nâ€¢ **æœ‰åä¿¡å·é‡**\næ¯”èµ·é€šè¿‡å…±äº«å†…å­˜çš„æ–¹å¼ä¼šç®€å•å¾ˆå¤š\n```c\n#include<stdio.h>\n#include<unistd.h>\n#include<fcntl.h>\n#include<semaphore.h>\n#include<sys/mman.h>\n#include<sys/stat.h>\n#include<sys/types.h>\n#include<sys/wait.h>\n\nint main(int argc, char const *argv[])\n{\n    //char *shm_value_name = \"/named_sem_shm_value\";\n    char *sem_name = \"/named_sem_shm\";\n\n    //åˆ›å»ºå…±äº«å†…å­˜å¯¹è±¡\n    // int value_fd = shm_open(sem_name, O_CREAT | O_RDWR, 0666);\n\n    //åˆå§‹åŒ–æœ‰åä¿¡å·é‡\n    sem_t * sem = sem_open(sem_name, O_CREAT, 0666, 0);\n\n    //åˆ›å»ºçˆ¶å­è¿›ç¨‹\n    pid_t pid = fork();\n    if(pid < 0){\n        perror(\"fork\");\n    }else if(pid == 0){\n        sleep(1);\n        printf(\"è¿™æ˜¯å­è¿›ç¨‹\\n\");\n        sem_post(sem);\n    }else{\n        sem_wait(sem);\n        printf(\"è¿™æ˜¯çˆ¶è¿›ç¨‹\\n\");\n        waitpid(pid, NULL, 0);\n    }\n\n    //å›æ”¶èµ„æº\n\n    if(sem_close(sem) == -1){\n        perror(\"close\");\n    }\n    if(pid > 0){\n        if(sem_unlink(sem_name) == -1){\n            perror(\"shm_unlink\");\n        }\n    }\n    return 0;\n}\n\n```\n\nâ€¢ **ç»å…¸æ¡ˆä¾‹**\né€šè¿‡åˆ›å»ºä¸¤ä¸ªä¿¡å·é‡æ¥æ§åˆ¶è¿›ç¨‹æˆ–çº¿ç¨‹çš„æ‰§è¡Œé¡ºåº\n\n```c\n#include<stdio.h>\n#include<unistd.h>\n#include<stdlib.h>\n#include<semaphore.h>\n#include<time.h>\n#include<pthread.h>\n\nsem_t *full;\nsem_t *empty;\n\nint shard_num;\n\nint rand_num(){\n    srand(time(NULL));\n    return rand();\n}\n\nvoid *producer(void *arg){\n    for (size_t i = 0; i < 5; i++)\n    {\n        // è·å–ä¿¡å·é‡\n        sem_wait(empty);\n        printf(\"\\nç¬¬%dè½®æ•°æ®ä¼ è¾“\\n\", i + 1);\n        sleep(1);\n        shard_num = rand_num();\n\n        //é‡Šæ”¾ä¿¡å·é‡\n        sem_post(full);\n    }\n    \n}\n\nvoid *consumer(void *arg){\n    for (size_t i = 0; i < 5; i++)\n    {\n        // è·å–ä¿¡å·é‡\n        sem_wait(full);\n        printf(\"\\nç¬¬%ldè½®æ¶ˆè´¹è€…å¼€å§‹è¯»å–æ•°æ®\\n\", i + 1);\n        sleep(1);\n        printf(\"æ¥æ”¶åˆ°çš„æ•°æ®æ˜¯%d\", shard_num);\n\n        //é‡Šæ”¾ä¿¡å·é‡\n        sem_post(empty);\n    }\n    \n}\n\nvoid *consumer(void *arg){\n\n}\n\nint main(int argc, char const *argv[])\n{\n    full = (sem_t *)malloc(sizeof(sem_t));\n    empty = (sem_t *)malloc(sizeof(sem_t));\n    // åˆå§‹åŒ–ä¿¡å·é‡\n    sem_init(empty, 0, 1);\n    sem_init(full, 0, 0);\n\n    // åˆ›å»ºç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…çº¿ç¨‹\n    pthread_t producer_id, consumer_id;\n    pthread_create(&producer_id, NULL, producer, NULL);\n    pthread_create(&consumer_id, NULL, consumer, NULL);\n\n    //ç­‰å¾…çº¿ç¨‹å…¨éƒ¨å®Œæˆ\n    pthread_join(producer_id, NULL);\n    pthread_join(consumer_id, NULL);\n\n    //ä»£ç æœ€åæ‘§æ¯ä¿¡å·é‡\n    sem_destroy(full);\n    sem_destroy(empty);\n    return 0;\n}\n\n```\n\n### ä¿¡å·\nâ€¢ **ä¿¡å·çš„ç‰¹ç‚¹**ï¼šç”¨äºé€šçŸ¥è¿›ç¨‹å‘ç”Ÿäº†æŸç§äº‹ä»¶ï¼Œæ˜¯ä¸€ç§å¼‚æ­¥é€šä¿¡æ–¹å¼ã€‚\nâ€¢ **ä»£ç ç¤ºä¾‹**ï¼š\n  ```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<signal.h>\n#include<unistd.h>\n\nvoid sigint_handle(int signum){\n    printf(\"\\nå—åˆ°%dä¿¡å· åœæ­¢ç¨‹åº\\n\", signum);\n    exit(signum);\n}\n\nint main(int argc, char const *argv[])\n{\n    if (signal(SIGINT, sigint_handle) == SIG_ERR)\n    {\n        perror(\"signal\");\n        return 1;\n    }\n    \n    while(1){\n        sleep(1);\n        printf(\"ä½ å¥½, åœ¨å—\\n\");\n    }\n    return 0;\n}\n  ```\n\n---","tags":["Linux","C"],"categories":["Linuxåº”ç”¨å±‚"]},{"title":"1v1è§†é¢‘èŠå¤©ç½‘é¡µ","url":"/2025/01/19/1v1è§†é¢‘èŠå¤©ç½‘é¡µ/","content":"\nèŠ±äº†ç‚¹æ—¶é—´è·Ÿç€Bç«™çš„æ•™ç¨‹æ‰‹æ•²äº†ä¸€ä¸ªå…³äºWebRtcçš„é¡¹ç›®ï¼Œå®ƒæ˜¯B/Sæ¡†æ¶çš„ï¼Œç”¨jsåšçš„å‰åç«¯ã€‚å·¥å…·ç”¨çš„æ˜¯nodeï¼Œå¯ä»¥è¯´æ˜¯éå¸¸çš„æ–¹ä¾¿ã€‚jsè¯­æ³•æœ¬èº«ä¹Ÿç®€å•æ˜“å­¦ï¼Œå’ŒCæœ‰å¾ˆå¤šç›¸ä¼¼ä¹‹å¤„ã€‚æ€»çš„æ¥è¯´nodejs YYDS(q(â‰§â–½â‰¦q))\n\n\n### æ•´ä¸ªé¡¹ç›®å¯ä»¥åˆ†ä¸ºä¸‰å¤§å—\n\n1. èº«ä»½éªŒè¯:ç™»å½•ã€æ³¨å†Œ\n\næ¶‰åŠåˆ°å‰ç«¯ç•Œé¢ï¼Œæ•°æ®åº“ï¼Œä¿¡ä»¤æœåŠ¡å™¨ï¼Œnode webæœåŠ¡å™¨\n\n2. èŠå¤©å®¤\n\næ¶‰åŠåˆ°å‰ç«¯ç•Œé¢ï¼Œä¿¡ä»¤æœåŠ¡å™¨ï¼Œnode webæœåŠ¡å™¨\n\n3. 1v1èŠå¤©å®¤\n\næ¶‰åŠåˆ°å‰ç«¯ç•Œé¢ï¼Œä¿¡ä»¤æœåŠ¡å™¨ï¼Œnode webæœåŠ¡å™¨ï¼ŒNATç©¿é€æœåŠ¡å™¨(å½“ç„¶æˆ‘è¿™é‡Œæ²¡æœ‰æ­å»ºï¼Œæ‰€ä»¥å€™é€‰è€…ç”¨çš„hostï¼Œæ¯•ç«Ÿå°±æ˜¯ä¸ºäº†å­¦ä¹ WebRtc)\n\n### ç›¸å…³è®¾è®¡\n\n1ã€B/Sæ¶æ„æ¨¡å¼\n\n2ã€ç™»å½•ç•Œé¢è®¾è®¡\n\n3ã€éŸ³è§†é¢‘èŠå¤©ç•Œé¢è®¾è®¡\n\n4ã€æ–‡å­—è¾“å…¥è¾“å‡ºç•Œé¢è®¾è®¡\n\n5ã€æˆ¿é—´åˆ›å»ºä¸é€€å‡ºåŠŸèƒ½\n\n6ã€éŸ³è§†é¢‘èŠå¤©æœåŠ¡\n\n7ã€æ–‡å­—èŠå¤©æœåŠ¡å¤„ç†\n\n8ã€ä¿¡ä»¤æœåŠ¡å¤„ç†\n\n9ã€NATç©¿é€æœåŠ¡å¤„ç†\n\n### ç”¨åˆ°çš„nodeæ¨¡å—\n\nhttp https ç”¨äºæ”¯æŒhttp httpsåè®®\nsqlite3 æ•°æ®åº“æ¨¡å—\nlog4js ä¸»è¦ç”¨äºæœåŠ¡å™¨çš„æ§åˆ¶å°è¾“å‡ºæ—¥å¿—\nsocket.io ç”¨äºä¿¡ä»¤æœåŠ¡å™¨çš„è®¾è®¡ï¼ˆé¢å¤–è¿˜éœ€è¦å†å®¢æˆ·ç«¯å¼•å…¥å¯¹åº”ç‰ˆæœ¬çš„socket.io.jsï¼‰\nexpress server-index ä¸¤è€…ç»“åˆä½¿ç”¨ï¼Œç”¨äºå°†ç½‘é¡µä»¥æ–‡ä»¶å¤¹çš„å½¢å¼å±•ç¤ºå‡ºæ¥\n\n---\nå†…å®¹å¾ˆå¤šï¼Œä»¥ä¸‹ä¸»è¦å±•ç¤ºä¿¡å·ç›‘å¬ç›¸åº”çš„jsä»£ç ï¼Œé¡¹ç›®çš„ä¸»è¦å†…å®¹ä¹Ÿå°±æ˜¯è¿™é‡Œ\n\n### server.jsï¼ˆæœåŠ¡å™¨ï¼‰\n```js\n\n//å¼•å…¥çš„æ¨¡å—\nvar http=require(\"http\");\nvar https = require(\"https\");\nvar fs = require(\"fs\");\n\n    //è‡ªå·±å®‰è£…çš„\nvar express=require(\"express\");\nvar serveIndex=require(\"serve-index\");\nvar sqlite3=require(\"sqlite3\");\nvar log4js=require(\"log4js\");\nvar socket=require(\"socket.io\");\n\n......\n\nvar io=socket.listen(httpServer);\nio.sockets.on(\"connection\", (socket)=>{\n    logger.info(\"connected\", socket.id);\n\n    //å¼€å§‹ç›‘å¬èº«ä»½éªŒè¯ç›¸å…³çš„ä¿¡å·\n    socket.on(\"login\", (uname, pwd)=>{\n        logger.info(\"login: \", uname, pwd);\n        db.all(\"select * from users where name=? and pwd=?\",\n            [uname, pwd], (e, rows)=>{\n            if(e){\n                handleErr(e);\n                socket.emit(\"serverErr\");\n            }else{\n                if(rows.length===1){\n                    socket.emit(\"loginsuc\", uname);\n                }else{\n                    socket.emit(\"loginfailed\", uname);\n                }\n            }\n        })\n    });\n\n    socket.on(\"regist\", (uname, pwd)=>{\n        var sql = \"select * from users where name=?\";\n        db.all(sql, [uname], (e, rows)=>{\n           if(e){\n               handleErr(e);\n               socket.emit(\"serverErr\");\n           }else{\n               if(rows.length===1){\n                   socket.emit(\"samename\", uname);\n               }else{\n                   sql=\"insert into users(name, pwd) values(?, ?)\";\n                   db.run(sql, [uname, pwd], (e)=>{\n                       if(e){\n                           handleErr(e);\n                           socket.emit(\"serverErr\");\n                       }else{\n                           socket.emit(\"registsuc\");\n                       }\n                   })\n               }\n           }\n        });\n    })\n\n    //ç›‘å¬èŠå¤©å¤§å…ç›¸å…³çš„ä¿¡å·\n    socket.on(\"cjoin\", (room, uname)=>{\n        logger.info(\"cjoin\", room, uname);\n        socket.join(room);\n\n        socket.emit(\"cjoined\", uname);\n        socket.to(room).emit(\"cotherjoined\", uname);\n    })\n\n    socket.on(\"cmessage\", (room, uname, msg)=>{\n        logger.info(\"cmessage\", room, uname, msg);\n        io.in(room).emit(\"cgetmessage\", uname, msg);\n    })\n\n    socket.on(\"cleave\", (room, uname)=>{\n        logger.info(\"cleave\", room, uname);\n        socket.leave(room);\n        socket.emit(\"cleft\");\n        socket.to(room).emit(\"cotherleft\", uname);\n    })\n\n    //å¼€å§‹å¤„ç†1v1èŠå¤©å®¤çš„æ¶ˆæ¯\n    socket.on(\"vjoin\", (room, uname)=>{\n        logger.info(\"vjoin\", room, uname);\n        socket.join(room);\n\n        var myRoom = io.sockets.adapter.rooms[room];\n        var users = Object.keys(myRoom.sockets).length;\n        logger.info(room+\" users=\" + users);\n        if(users > 2){\n            socket.leave(room);\n            socket.emit(\"vfull\", room);\n        }else{\n            socket.emit(\"vjoined\", room);\n            if(users > 1){\n                socket.to(room).emit(\"votherjoined\", room, uname);\n            }\n        }\n    });\n\n    socket.on(\"vdata\", (room, data)=>{\n        logger.info(\"vdata\", room, data);\n        socket.to(room).emit(\"vgetdata\", room, data);\n    });\n\n    socket.on(\"vleave\", (room, uname)=>{\n        logger.info(\"vleave\", room, uname);\n        if(room === \"\" || uname === \"\"){\n            logger.info(\"room is empty string\");\n            return;\n        }\n        var myRoom = io.sockets.adapter.rooms[room];\n        var users = Object.keys(myRoom.sockets).length;\n\n        logger.info(\"vleave users=\" + (users - 1));\n        socket.leave(room);\n        socket.emit(\"vleft\", room);\n        socket.to(room).emit(\"votherleft\");\n    })\n\n});\n```\n\n### login.jsï¼ˆç™»å½•ï¼‰\n\n```js\nfunction start(){\n    socket=io.connect();\n\n    //ç›‘å¬æœåŠ¡å™¨çš„æ¶ˆæ¯\n    socket.on(\"loginsuc\",(uname)=>{\n        alert(\"ç™»å½•æˆåŠŸ:\" + uname);\n        window.location.href=\"chat.html?uname=\"+uname;\n    });\n\n    socket.on(\"loginfailed\",(uname)=>{\n        alert(\"ç™»å½•å¤±è´¥:\" + uname);\n    });\n\n    socket.on(\"serverErr\",()=>{\n         alert(\"æœåŠ¡å™¨æ“ä½œå¼‚å¸¸\");\n    })\n}\n```\n\n### regist.jsï¼ˆæ³¨å†Œï¼‰\n\n```js\nfunction start(){\n    socket=io.connect();\n\n    socket.on(\"serverErr\", ()=>{\n        alert(\"æœåŠ¡å™¨æ“ä½œå¼‚å¸¸ï¼Œè¯·é‡è¯•\");\n    });\n\n    socket.on(\"samename\", (uname)=>{\n        alert(\"æ”¹åå­—å·²è¢«æ³¨å†Œ\");\n    });\n\n    socket.on(\"registsuc\", ()=>{\n        alert(\"æ³¨å†ŒæˆåŠŸ\");\n        goBack();\n    });\n}\n```\n\n### chat.jsï¼ˆèŠå¤©å®¤ï¼‰\n\nè¿™é‡Œçš„taMsgListæŒ‡å‘çš„æ˜¯ä¸€ä¸ªtextareaæ ‡ç­¾\n\n```js\nfunction start(){\n    socket=io.connect();\n\n    socket.on(\"cjoined\", (uname)=>{\n        console.log(taMsgList); // æ£€æŸ¥taMsgListæ˜¯å¦æ­£ç¡®æŒ‡å‘textarea\n        taMsgList.value = \"æ¬¢è¿\" + uname + \"æ¥åˆ°å¤§å…\\n\";\n    });\n\n    socket.on(\"cotherjoined\", (uname)=>{\n        taMsgList.value += uname + \"è¿›å…¥å¤§å…\\n\";\n    })\n\n    socket.on(\"cgetmessage\", (uname, msg)=>{\n        taMsgList.value += uname + \":\" + msg + \"\\n\";\n    })\n\n    socket.on(\"cleft\", ()=>{\n        history.back();\n    })\n\n    socket.on(\"cotherleft\", (uname)=>{\n        taMsgList.value += uname + \"ç¦»å¼€äº†å¤§å…\\n\";\n    })\n\n    socket.emit(\"cjoin\", room, uname);\n}\n```\n\n### videoRoom.js(è§†é¢‘èŠå¤©)\n\nè¿™é‡Œæœ‰ä¸€ä¸ªçŠ¶æ€æœºçš„æ¦‚å¿µï¼ŒåŸºstatusçš„çŠ¶æ€ï¼Œå®ƒçš„è®¾è®¡æ˜¯ä¸ºä¿è¯æ‰€æœ‰æƒ…å†µçš„å‘ç”Ÿéƒ½æœ‰æ­£ç¡®çš„å¤„ç†\n```js\nfunction conn(){\n    socket = io.connect();\n    //ç›‘å¬æ¥è‡ªæœåŠ¡å™¨çš„ä¿¡å·\n    socket.on(\"vfull\", (room)=>{\n        status = \"leave\";\n        alert(\"æˆ¿é—´å·²æ»¡: \" + room);\n        console.log(\"vfull:\", status);\n    });\n\n    socket.on(\"vjoined\", (room)=>{\n        alert(\"æˆåŠŸåŠ å…¥æˆ¿é—´:\" + room);\n\n        iptRoom.disabled = true;\n        btnEnterRoom.disabled = true;\n        btnLeaveRoom.disabled = false;\n\n        createPeerConnection();\n\n        status = \"joined\";\n        console.log(\"vjoined:\", status);\n    });\n\n    socket.on(\"votherjoined\", (room, uname)=>{\n        console.log(\"åˆ«äººè¿›æ¥äº†äº†:\"+uname);\n\n        if(status === \"joined_unbind\"){\n            createPeerConnection();\n        }\n        status = \"joined_conn\";\n\n        //åª’ä½“åå•†\n        mediaNegociate()\n\n        console.log(\"votherjoined:\", status);\n    });\n\n    socket.on(\"vgetdata\", (room, data)=>{\n       console.log(\"vgetdata:\", data);\n       if(!data){\n           return;\n       }\n       if(data.type===\"candidate\"){\n           console.log(\"get other candidate\");\n           //å€™é€‰è€…ä¿¡æ¯\n           var cddt = new RTCIceCandidate({\n               sdpMLineIndex:data.label,\n               candidate:data.candidate\n           });\n           pc.addIceCandidate(cddt);\n       }else if(data.type === \"offer\"){\n           console.log(\"get offer\");\n           pc.setRemoteDescription(new RTCSessionDescription(data));\n\n           //æŸ¥è¯¢è‡ªå·±çš„åª’ä½“ä¿¡æ¯å¹¶åº”ç­”\n           pc.createAnswer()\n               .then(getAnswer)\n               .catch(handleErr);\n       }else if(data.type === \"answer\"){\n           console.log(\"get answer\");\n           pc.setRemoteDescription(new RTCSessionDescription(data));\n       }\n    });\n\n    socket.on(\"vleft\", (room)=>{\n        alert(\"ç¦»å¼€æˆ¿é—´:\"+room);\n\n        iptRoom.disabled = false;\n        btnEnterRoom.disabled = false;\n        btnLeaveRoom.disabled = true;\n\n        status = \"leaved\";\n        console.log(\"vleft:\", status);\n    });\n\n    socket.on(\"votherleft\", ()=>{\n        status = \"vjoined_unbind\";\n        closePeerConnection();\n        console.log(\"votherleft:\", status);\n    });\n}\n```","tags":["WebRtc"],"categories":["éŸ³è§†é¢‘"]},{"title":"WebRtcåˆæ­¥è®¤è¯†(webrtcå®ç°1v1è§†é¢‘é€šè¯ä»0åˆ°1)","url":"/2024/12/25/WebRtcåˆæ­¥è®¤è¯†(webrtcå®ç°1v1è§†é¢‘é€šè¯ä»0åˆ°1)/","content":"\nåœ¨ç½‘ä¸Šæ‰¾åˆ°äº†ä¸€ä¸ªéå¸¸é€‚åˆå…¥é—¨çš„æ•™ç¨‹ï¼Œåˆ†äº«ç»™æœ‰ç¼˜äºº(ç¨å¾®æ”¹äº†ä»¥ä¸‹å¸ƒå±€ï¼Œå¹¶æ·»åŠ äº†ä¸€ç‚¹å†…å®¹o(*ï¿£ï¸¶ï¿£*)o)\n\n## WebRtcå¤„ç†è¿‡ç¨‹\n\nå®ç°1v1çš„é€šè¯æœ‰4ä¸ªéƒ¨åˆ†ï¼ŒWebRtcç»ˆç«¯ï¼ˆè¿™é‡Œç†è§£ä¸ºæµè§ˆå™¨ç«¯ï¼‰ã€Signalï¼ˆä¿¡ä»¤ï¼‰æœåŠ¡å™¨ã€STUN/TURNæœåŠ¡å™¨\n\n- WebRtcç»ˆç«¯ï¼Œè´Ÿè´£éŸ³è§†é¢‘çš„é‡‡é›†ã€ç¼–è§£ç ã€NATç©¿è¶Šã€éŸ³è§†é¢‘æ•°æ®ä¼ è¾“ ï¼ˆè¿™é‡Œç»ˆç«¯æš‚æ—¶çœ‹åšæµè§ˆå™¨ï¼ŒwebRtcä¸æ­¢åº”ç”¨åœ¨æµè§ˆå™¨ï¼‰\n- SignalæœåŠ¡å™¨ï¼Œè´Ÿè´£ä¿¡ä»¤å¤„ç†ï¼Œå¦‚æœ‰äººåŠ å…¥æˆ¿é—´ã€ç¦»å¼€æˆ¿é—´ã€åª’ä½“åå•†æ¶ˆæ¯ä¼ é€’ç­‰ã€‚ï¼ˆç±»ä¼¼èŠå¤©å®¤çš„xxåŠ å…¥æˆ¿é—´ï¼‰ï¼Œä¸€èˆ¬é‡‡ç”¨WebSocketè¿æ¥\n- STUN/TURNæœåŠ¡ï¼Œè´Ÿè´£è·å–WebRtcç»ˆç«¯åœ¨å…¬ç½‘çš„ipåœ°å€ï¼Œä»¥åŠNATç©¿è¶Šå¤±è´¥åçš„æ•°æ®ä¸­è½¬ã€‚ï¼ˆï¼‰\n\nç”¨æˆ·Aå’Œç”¨æˆ·Bè¦è¯­éŸ³é€šè¿‡å¤§è‡´è¿‡ç¨‹ï¼š\n1. ç”¨æˆ·Aå’Œç”¨æˆ·Bä½œä¸ºWebRtcç»ˆç«¯ï¼ˆæµè§ˆå™¨ï¼‰æ£€æµ‹ä½ çš„è®¾å¤‡æ˜¯å¦æ”¯æŒéŸ³è§†é¢‘æ•°æ®é‡‡é›†ï¼Œ\n2. è·å–éŸ³è§†é¢‘æ•°æ®ååŠ å…¥åˆ°ä¿¡ä»¤ä¿¡ä»¤æœåŠ¡å™¨ï¼Œè¿™æ ·2ä¸ªç”¨æˆ·éƒ½åŠ å…¥åˆ°ä¸€ä¸ªæˆ¿é—´\n3. ç”¨æˆ·Aä¼šåˆ›å»ºRTCPeerConnectionå¯¹è±¡ï¼Œè¯¥å¯¹è±¡å°†é‡‡é›†åˆ°çš„éŸ³è§†é¢‘æ•°æ®è¿›è¡Œç¼–ç å’Œé€šè¿‡P2Pä¼ é€ç»™å¯¹æ–¹ï¼ŒP2Pç©¿è¶Šå¤±è´¥ï¼Œå°±ä½¿ç”¨TURNè¿›è¡Œæ•°æ®ä¸­è½¬ï¼Œæœ‰çš„å…¬å¸æ¶æ„æ˜¯ç›´æ¥ç”¨åè€…è¿›è¡Œä¼ è¾“\néŸ³è§†é¢‘é‡‡é›†\næµè§ˆå™¨çš„getUserMediaæ–¹æ³•\n\n```js\nnavigator.mediaDevices.getUserMedia(constraints);\n```\n\nconstraintså‚æ•°è§†é¢‘è®¾ç½®é‡‡é›†åˆ†è¾¨ç‡ã€å¸§ç‡å‚æ•°ï¼ŒéŸ³é¢‘å¯ä»¥è®¾ç½®å¼€å¯é™å™ªç­‰å‚æ•°ï¼›å¦‚è®¾å¤‡å…·å¤‡éŸ³è§†é¢‘é‡‡é›†èƒ½åŠ›ï¼Œå®ƒè¿”å›çš„æˆåŠŸçš„promiseé‡Œï¼Œå¯ä»¥è·å–åˆ°MediaStreamå¯¹è±¡ï¼Œå¹¶å®Œæˆä»¥ä¸‹æ“ä½œ\n1. æœ¬åœ°æ“ä½œè§†é¢‘æµï¼šMediaStreamå¯¹è±¡å­˜æ”¾ç€é‡‡é›†åˆ°çš„éŸ³è§†é¢‘è½¨ï¼Œç›´æ¥èµ‹å€¼ç»™videoæ ‡ç­¾çš„srcObjectå±æ€§ï¼Œå°±å¯ä»¥æœ¬åœ°å®ç°çœ‹åˆ°æ‘„åƒå¤´å’Œå¬åˆ°å£°éŸ³ã€‚\n2. æ‹ç…§ï¼šé€šè¿‡canvasçš„drawImageï¼Œå°†videoæ ‡ç­¾ä¼ å…¥\n3. ä¿å­˜ç…§ç‰‡ï¼šé€šè¿‡canvas.toDataURLç”Ÿæˆæœ¬åœ°åœ°å€ï¼Œé€šè¿‡aæ ‡ç­¾ä¸‹è½½å›¾ç‰‡\n\n```js\nvar constraints = { audio: true, video: true };\nlet media\nnavigator.mediaDevices\n    .getUserMedia(constraints)\n    .then((MediaStream) => {\n      media = MediaStream;\n      const video = document.querySelector(\"video\");\n      video.srcObject = MediaStream;\n      video.onloadedmetadata = function (e) {\n        video.play();\n      };\n    })\n    .catch((e) => {\n      console.warn(e, \"e\");\n    });\n\n// æ‹ç…§ï¼šè°ƒç”¨canvasçš„apiï¼Œå°†videoæ ‡ç­¾ä¼ å…¥\nconst video = document.querySelector(\"video\");\ndocument.querySelector(\"canvas\").getContext('2d').drawImage(video, 0, 0,400,300)\n\n// ä¿å­˜ç…§ç‰‡\nconst url = canvas.toDataURL(\"image/jpeg\");\ndocument.createElement('a').href = url;\n```\n\n### åª’ä½“åå•†\n\n- **ä½œç”¨**ï¼š  \n  è®©åŒæ–¹æ‰¾åˆ°å…±åŒæ”¯æŒçš„åª’ä½“èƒ½åŠ›ï¼Œè¿‡ç¨‹æœ‰ç‚¹åƒ TCP çš„ä¸‰æ¬¡æ¡æ‰‹ã€‚\n\n- **çŸ¥è¯†ç‚¹**ï¼š\n  1. **åˆ›å»ºè¿æ¥**ï¼š  \n     åˆ›å»º `RTCPeerConnection` å¯¹è±¡ï¼Œå®ƒè´Ÿè´£ç«¯ä¸ç«¯ä¹‹é—´å»ºç«‹ P2P è¿æ¥ã€‚\n  2. **ä¿¡ä»¤**ï¼š  \n     å®¢æˆ·ç«¯é€šè¿‡ä¿¡ä»¤æœåŠ¡å™¨äº¤æ¢ **SDP**ï¼ˆSession Description Protocolï¼‰ä¿¡æ¯ã€‚SDP åŒ…å«ç¼–è§£ç æ–¹å¼ã€ä¼ è¾“åè®®ã€IP åœ°å€å’Œç«¯å£ç­‰ä¿¡æ¯ï¼Œç¡®ä¿åŒæ–¹èƒ½å¤Ÿæ‰¾åˆ°å…±åŒæ”¯æŒçš„åª’ä½“èƒ½åŠ›å¹¶è¿›è¡Œé€šä¿¡ã€‚\n  3. **Offer**ï¼š  \n     åœ¨åŒå‘é€šä¿¡æ—¶ï¼Œå‘¼å«æ–¹å‘é€çš„ SDP æ¶ˆæ¯ç§°ä¸º **Offer**ã€‚\n  4. **Answer**ï¼š  \n     åœ¨åŒå‘é€šä¿¡æ—¶ï¼Œè¢«å‘¼å«æ–¹å‘é€çš„ SDP æ¶ˆæ¯ç§°ä¸º **Answer**ã€‚\n\n- **åª’ä½“åå•†è¿‡ç¨‹**ï¼š\n  1. å‘¼å«æ–¹åˆ›å»º Offer ç±»å‹çš„ SDP æ¶ˆæ¯åï¼Œé€šè¿‡ `setLocalDescription` æ–¹æ³•ä¿å­˜åˆ°æœ¬åœ°çš„ Local åŸŸï¼Œå†é€šè¿‡ä¿¡ä»¤å°† Offer å‘ç»™è¢«å‘¼å«æ–¹ã€‚\n  2. è¢«å‘¼å«æ–¹æ”¶åˆ° Offer ç±»å‹çš„ SDP æ¶ˆæ¯åï¼Œé€šè¿‡ `setRemoteDescription` ä¿å­˜åˆ°å…¶ Remote åŸŸã€‚æ¥ç€ï¼Œå®ƒåˆ›å»º Answer ç±»å‹çš„ SDP æ¶ˆæ¯ï¼Œå¹¶é€šè¿‡ `setLocalDescription` ä¿å­˜åˆ°æœ¬åœ°ï¼Œå†å°†æ¶ˆæ¯å‘ç»™å‘¼å«æ–¹ã€‚\n  3. å‘¼å«æ–¹æ”¶åˆ° Answer ç±»å‹çš„ SDP æ¶ˆæ¯åï¼Œé€šè¿‡ `setRemoteDescription` ä¿å­˜åˆ°å…¶ Remote åŸŸã€‚\n\n- **æ€»ç»“**ï¼š  \n  åª’ä½“åå•†å®Œæˆåï¼ŒWebRTC åº•å±‚ä¼šæ”¶é›† **Candidate**ï¼ˆWebRTC ä¸è¿œç«¯é€šä¿¡æ—¶ä½¿ç”¨çš„åè®®ã€IP åœ°å€å’Œç«¯å£ï¼‰ï¼Œè¿›è¡Œè¿é€šæ€§æµ‹è¯•ï¼Œæœ€ç»ˆå»ºç«‹ä¸€æ¡é“¾è·¯ã€‚\n\n\n```js\n// å‘¼å«æ–¹A\n// åˆ›å»ºOffer,æœ¬åœ°è®¾ç½®ï¼Œå‘ç»™å¯¹æ–¹\nconst pcA = new RTCPeerConnection();\npcA.createOffer().then((offerSDP)=>{\n    pcA.setLocalDescription(offerSDP);\n    sendMessage(offerSDP);\n})\n\n// æ¥å—åˆ°answerï¼Œä¿å­˜èµ·æ¥\nsocket.on('message', (message) => {\n    if(message.type === 'answer') {\n        pcA.setRemoteDescription(new RTCSessionDescription(message))\n    }\n})\n\n\n// è¢«å‘¼å«æ–¹B\nconst pcB = new RTCPeerConnection();\nsocket.on('message', (message) => {\n    if(message.type === 'offer')\n    pcB.setRemoteDescription(new RTCSessionDescription(message))\n    \n    // åˆ›å»ºAnswer,æœ¬åœ°è®¾ç½®ï¼Œå‘ç»™å¯¹æ–¹\n    pcB.createAnswer().then((answerSDP)=>{\n        pcB.setLocalDescription(answerSDP);\n        sendMessage(answerSDP)\n    })\n})\n\n```\n\n### è¿æ¥å»ºç«‹\n\n#### è¿æ¥çš„åŸºæœ¬åŸåˆ™\nå¦‚æœAå’ŒBè¿æ¥ï¼ŒCä½œä¸ºæœåŠ¡å™¨\n\nåœºæ™¯ä¸€ï¼šåŒæ–¹å¤„äºåŒä¸€ä¸ªç½‘æ®µå†…ï¼ˆå†…ç½‘ï¼‰\nåœºæ™¯äºŒï¼šåŒæ–¹å¤„äºä¸åŒç‚¹\n\n`ICE Candidateï¼ˆICEå€™é€‰è€…ï¼‰`ï¼Œå®ƒè¡¨ç¤ºWebRtcä¸è¿œç«¯é€šä¿¡ä½¿ç”¨çš„åè®®ã€ipåœ°å€å’Œç«¯å£ï¼Œä¸€èˆ¬3ç§æ–¹å¼\n`host`è¡¨ç¤ºæœ¬æœºå€™é€‰è€…ï¼Œå†…ç½‘ä¹‹é—´çš„è”é€šæ€§æµ‹è¯•ï¼Œä¼˜å…ˆçº§æœ€é«˜\n`srflx`è¡¨ç¤ºå†…ç½‘ä¸»æœºæ˜ å°„çš„å¤–ç½‘åœ°å€å’Œç«¯å£ï¼Œè®©åŒå‘é€šè¿‡P2Pè¿›è¡Œè¿æ¥ï¼Œæ¬¡ä¼˜åŒ–çº§\n`relay`è¡¨ç¤ºä¸­ç»§å€™é€‰è€…ï¼Œä½ä¼˜å…ˆçº§\n\n```js\n{\n    address: 'xxx.xxx.xxx.xxx',\n    port: 'xxxx',\n    type: 'host/srflx/relay',\n    protocol: 'UDP/TCP',\n    // ...\n}\n```\n\n#### STUNåè®®\n`NAT`æ˜¯æŒ‡ç½‘ç»œåœ°å€è½¬æ¢ï¼Œä½œç”¨å°±æ˜¯è¿›è¡Œå†…å¤–ç½‘çš„åœ°å€è½¬æ¢ã€‚\n`STUN(session traversal utilities for NAT)`,ä¸€ç§å¤„ç†NATä¼ è¾“çš„åè®®ï¼Œå®ƒå…è®¸ä½äºNATåçš„å®¢æˆ·ç«¯æ‰¾å‡ºè‡ªå·±çš„å…¬ç½‘åœ°å€ã€‚\nsrflxç±»å‹çš„Candidateå®é™…ä¸Šå°±æ˜¯ç”¨çš„ç»NATæ˜ å°„åçš„å¤–ç½‘åœ°å€ï¼Œè¿›è¡ŒP2Pè¿æ¥é€šä¿¡ã€‚\n#### TURNåè®®\nrelayæœåŠ¡é€šè¿‡TURNåè®®å®ç°ã€‚TURNåè®®æè¿°äº†å¦‚ä½•è·å–relayæœåŠ¡å™¨ï¼ˆå³TUNRåè®®ï¼‰çš„Candidateè¿‡ç¨‹ã€‚é€šè¿‡TURNæœåŠ¡å™¨å‘é€AllocationæŒ‡ä»¤ï¼ŒrelayæœåŠ¡å°±ä¼šåœ¨æœåŠ¡ç«¯åˆ†é…ä¸€ä¸ªæ–°çš„relayç«¯å£ï¼Œç”¨äºä¸­è½¬UDPæ•°æ®æŠ¥ã€‚\nå› ä¸ºP2Påœºæ™¯æœ‰é™ï¼Œå…¶å®å¤§éƒ¨åˆ†è¿˜æ˜¯é‡‡ç”¨relayæ–¹å¼æ¥ä¼ è¾“æ•°æ®ã€‚\nå®ç°1v1éŸ³è§†é¢‘å®æ—¶ç›´æ’­ç³»ç»Ÿ\nç”¨æˆ·Aå’Œç”¨æˆ·Bä¹‹é—´è§†é¢‘é€šè¯è¿‡ç¨‹ï¼š\n\n#### ä¿¡ä»¤æœåŠ¡å™¨\nåŸºäºnodejs\n```js\nconst ws = require('nodejs-websocket');\nconst roomTableMap = new Map(); // æ ¹æ®roomIdï¼Œè®°å½•æ¯ä¸ªæˆ¿é—´çš„æˆå‘˜ä¿¡æ¯\nws.createServer((socket) => {\n    socket.on('text', (str) => {\n        // æ¥æ”¶æ¥è‡ªå®¢æˆ·ç«¯çš„æ¶ˆæ¯\n    })\n\n    socket.on('close', (data) => {\n        console.log(data);\n    })\n\n    socket.on('error', (data) => {\n        console.log(data);\n    })\n}).listen(3000)\n```\n\n#### å»ºç«‹è¿æ¥çš„å…·ä½“æµç¨‹\n1. ç”¨æˆ·Aå’Œç”¨æˆ·Bï¼Œé€šè¿‡WebSocketï¼Œè¿æ¥wsæœåŠ¡ï¼Œç›‘å¬å›è°ƒå‡½æ•°\n```js\nfunction createWebScoket(url) {\n  ws = new WebSocket(url);\n  ws.onopen = (e) => {};\n  ws.onmessage = (e) => {\n    // æ¥æ”¶æ¥è‡ªä¿¡ä»¤æœåŠ¡å™¨çš„æ¶ˆæ¯\n  };\n  ws.onclose = (e) => {};\n  ws.onerror = (e) => {};\n}\n```\n\n2. ç”¨æˆ·Aå’Œç”¨æˆ·Bå…ˆåç‚¹å‡»åŠ å…¥æˆ¿é—´ï¼Œæ ¹æ®navigator.mediaDevices.getUserMediaè·å–æœ¬åœ°çš„éŸ³è§†é¢‘æµï¼Œå†é€šè¿‡ws.sendå°†roomIdã€userIdç­‰ä¿¡æ¯ä¼ é€’ç»™ä¿¡ä»¤æœåŠ¡å™¨\n```js\nroomId = document.getElementById('roomBox').value // è¾“å…¥æ¡†å–æˆ¿é—´å·\n// æ‹¿åˆ°åª’ä½“è®¾å¤‡æµï¼Œæ˜¾ç¤ºåœ¨æœ¬åœ°\nnavigator.mediaDevices.getUserMedia({ video: true, audio: true }).then((stream) => {\n    ws.send(JSON.stringify({\n      type: 'join',\n      roomId,\n      uid: localUserId\n    }))\n    localStream = stream;\n    localVideo.srcObject = stream;\n})\n```\n\n3. ä¿¡ä»¤æœåŠ¡å™¨å…ˆåæ”¶åˆ°ç”¨æˆ·Aå’Œç”¨æˆ·Bæ¶ˆæ¯ï¼Œå°†è¯¥ç”¨æˆ·åŠ å…¥æˆ¿é—´ï¼Œå½“ç”¨æˆ·BåŠ å…¥çš„æ—¶å€™ï¼Œå°±é€šçŸ¥åˆ°æˆ¿é—´é‡Œç”¨æˆ·A\n```js\nsocket.on('text', (data) => {\n    const { type = '', roomId, uid, remoteUid} = JSON.parse(data);\n    if (type === 'join') {\n        let roomMap = roomTableMap.get(roomId);\n        if (!roomMap) {\n            roomMap = new Map();\n            roomTableMap.set(roomId, roomMap)\n        }\n        roomMap.set(uid, {roomId,uid,socket})\n        for (const [key, value] of roomMap) {\n            if(key !== uid) {\n                value.socket.sendText(JSON.stringify({ type: 'peer-join', remoteUid: uid }));\n            }\n        }\n    }\n})\n```\n\n\n4. ç”¨æˆ·Aå‘ç°æ­¤æ—¶æˆ¿é—´æœ‰å…¶ä»–äººï¼Œä¼šæ”¶åˆ°æ¶ˆæ¯ï¼Œtype=â€œpeer-joinâ€ï¼Œä¼šå…ˆåˆ›å»ºRTCPeerConnectionå¯¹è±¡ï¼Œå†ç›‘å¬onicecandidateï¼ˆæ”¶åˆ°ç½‘ç»œåå•†ç›¸å…³æ¶ˆæ¯ï¼‰å’Œontrackï¼ˆæ”¶åˆ°è¿œç«¯éŸ³è§†é¢‘æµï¼‰,å°†æœ¬åœ°éŸ³è§†é¢‘æµæ·»åŠ åˆ°å¯¹è±¡ä¸­\n```js\nws.onmessage = (e) => {\n    if (type === 'peer-join') {\n        pc = new RTCPeerConnection(null);\n        pc.onicecandidate = (e) => {\n            if (e.candidate) {\n              ws.send(JSON.stringify({\n                type: 'candidate',\n                roomId,\n                uid: localUserId,\n                remoteUid: remoteUserId,\n                candidate: e.candidate\n              }))\n            }\n        }\n        pc.ontrack = (e) => {\n            remoteStream = e.streams[0];\n            remoteVideo.srcObject = remoteStream;\n        }\n        localStream.getTracks().forEach(track => {\n        pc.addTrack(track, localStream)\n        });\n    }\n}\n```\n\n\n5. ç”¨æˆ·Aå†é€šè¿‡RTCPeerConnectionçš„å®ä¾‹ï¼Œåˆ›å»ºofferï¼ˆsdpä¿¡æ¯ç”¨äºåå•†éŸ³è§†é¢‘ç¼–ç åè®®ï¼‰ï¼ŒsetLocalDescriptionè®¾ç½®åœ¨æœ¬åœ°ï¼Œå†å‘é€åˆ°ä¿¡ä»¤æœåŠ¡å™¨,è½¬ç»™ç”¨æˆ·B\n```js\nws.onmessage = (e) => {\n    if (type === 'peer-join') {\n      pc.createOffer().then(sdp => {\n          pc.setLocalDescription(sdp).then(() => {\n              ws.send(JSON.stringify({\n                type: 'offer',\n                roomId,\n                uid: localUserId,\n                remoteUid,\n                sdp\n              }))\n            })\n        })\n    }\n}\n```\n\n6. ä¿¡ä»¤æœåŠ¡å™¨æ”¶åˆ°æ¶ˆæ¯ï¼Œtype=â€˜offerâ€™æ—¶ï¼Œè½¬å‘ç»™ç”¨æˆ·B\n```js\nsocket.on('text', (data) => {\n    const { type = '', roomId, uid, sdp = '' } = JSON.parse(str);\n    if(type === 'offer') {\n        let roomMap = roomTableMap.get(roomId);\n        for (const [key, value] of roomMap) {\n            if (key !== uid) {\n                value.socket.sendText(JSON.stringify({\n                  type,\n                  roomId,\n                  remoteUid: uid,\n                  sdp\n                }))\n              }\n        }\n    }\n})\n```\n\n\n7. ç”¨æˆ·Bï¼Œæ”¶åˆ°ä¿¡ä»¤æœåŠ¡å™¨å‘åˆ°type=â€˜offerâ€™æ¶ˆæ¯ï¼ŒåŒæ ·å…ˆåˆ›å»ºRTCPeerConnectionå®ä¾‹å’Œç›‘å¬ï¼Œå†ç›‘å¬onicecandidateå’Œontrackï¼Œå°†æœ¬åœ°éŸ³è§†é¢‘æµæ·»åŠ åˆ°å®ä¾‹ä¸­ï¼Œä»£ç åŒä¸Šé¢ä¸€è‡´\nåŒæ—¶ç”¨æˆ·Bï¼Œä¼šå°†ç”¨æˆ·Açš„sdpæ¶ˆæ¯ï¼ŒsetRemoteDescriptionåˆ°è¿œç¨‹ï¼Œè‡ªå·±åˆ›å»ºanswerçš„sdpä¿¡æ¯ï¼Œå‘é€ç»™æœåŠ¡ç«¯ï¼Œè½¬ç»™ç”¨æˆ·A\n```js\nws.onmessage = (e) => {\n    if (type === 'offer') {\n        pc.setRemoteDescription(new RTCSessionDescription(sdp));\n        pc.createAnswer().then(sdp => {\n            pc.setLocalDescription(sdp).then(() => {\n              ws.send(JSON.stringify({\n                type: 'answer',\n                roomId,\n                uid: localUserId,\n                remoteUid,\n                sdp\n              }))\n            })\n        })\n    }\n}\n```\n\n\n8. æœ€åç”¨æˆ·Aæ”¶åˆ°ï¼Œtype=â€˜answerâ€™çš„æ¶ˆæ¯ï¼ŒsetRemoteDescriptionåˆ°è¿œç¨‹\nåŒæ–¹æ”¶åˆ°ontrackå›è°ƒäº‹ä»¶ï¼Œè·å–åˆ°å¯¹æ–¹ç æµçš„å¯¹è±¡å¥æŸ„\nåŒæ–¹éƒ½å¼€å§‹è¯·æ±‚æ‰“æ´ï¼Œé€šè¿‡onicecandidateè·å–åˆ°æ‰“æ´ä¿¡æ¯ï¼ˆcandidateï¼‰å¹¶é€šè¿‡ä¿¡ä»¤æœåŠ¡å™¨å‘é€ç»™å¯¹æ–¹\nå¦‚æœp2pèƒ½æˆåŠŸåˆ™è¿›è¡Œé€šè¯ï¼Œä¸æˆåŠŸåˆ™è¿›è¡Œä¸­ç»§è½¬å‘é€šè¯(è¿™é‡Œå¹¶æ²¡æœ‰é…ç½®æœåŠ¡å™¨ï¼Œæ‰€ä»¥åªèƒ½è¿›è¡Œå†…ç½‘çš„é€šä¿¡)\n\n#### ä¸­ç»§æœåŠ¡å™¨çš„é…ç½®\n\nè¿™é‡Œæˆ‘ä½¿ç”¨äº†å¼€æºçš„coturnæœåŠ¡å™¨\n\næ·»åŠ pc = new RTCPeerConnection()è¿™ä¸ªæ–¹æ³•çš„å‚æ•°\n```js\nconst configuration = {\n  iceTransportPolicy: 'relay', //æµ‹è¯•çš„æ—¶å€™ä½¿ç”¨relay, å‘å¸ƒåˆ°å…¬ç½‘æ—¶ç”¨all\n  iceServers: [\n    {\n      urls:  ['stun:192.168.75.128:3478', 'stun:stun.l.google.com:19302'] //å¯ä»¥æŒ‰ç…§è¿™æ ·çš„æ ¼å¼å¡«å†™å¤šä¸ª\n    },\n    {\n      urls: 'turn:192.168.75.128:3478', //ä½ çš„æœåŠ¡å™¨\n      username: 'wqe', //ç”¨æˆ·å\n      credential: '1234567' //å¯†ç \n    }\n  ]\n};\n```\n\n### å®Œæ•´ä»£ç \n#### å‰ç«¯ä»£ç \n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <div>\n    <input id=\"roomBox\" type=\"text\">\n    <button id=\"joinBtn\">åŠ å…¥</button>\n    <button id=\"leaveBtn\">ç¦»å¼€</button>\n  </div>\n  <div>\n    <video id=\"localVideo\" autoplay muted playsinline></video>\n    <video id=\"remoteVideo\" autoplay playsinline></video>\n  </div>\n  <script>\n    const localVideo = document.getElementById('localVideo');\n    const remoteVideo = document.getElementById('remoteVideo');\n    const joinBtn = document.getElementById('joinBtn');\n    const leaveBtn = document.getElementById('leaveBtn');\n    const localUserId = Math.random().toString(36).slice(2);\n    let roomId = -1;\n    let remoteUserId = -1;\n    let localStream = null;\n    let remoteStream = null;\n    let ws = null;\n    let pc = null;\n    function createWebScoket(url) {\n      ws = new WebSocket(url);\n      ws.onopen = (e) => {\n        console.log(\"onopen\", e)\n      }\n      ws.onmessage = (e) => {\n        const { type, remoteUid = '', sdp, candidate } = JSON.parse(e.data);\n        if (type === 'peer-join') {\n          remoteUserId = remoteUid;\n          if (!pc) createConnect();\n          pc.createOffer().then(sdp => {\n            pc.setLocalDescription(sdp).then(() => {\n              ws.send(JSON.stringify({\n                type: 'offer',\n                roomId,\n                uid: localUserId,\n                remoteUid,\n                sdp\n              }))\n            })\n          })\n        } else if (type === 'peer-leave') {\n          remoteVideo.srcObject = null;\n        } else if (type === 'offer') {\n          if (!pc) createConnect();\n          pc.setRemoteDescription(new RTCSessionDescription(sdp))\n          pc.createAnswer().then(sdp => {\n            pc.setLocalDescription(sdp).then(() => {\n              ws.send(JSON.stringify({\n                type: 'answer',\n                roomId,\n                uid: localUserId,\n                remoteUid,\n                sdp\n              }))\n            })\n          })\n        } else if (type === 'answer') {\n          if (!pc) createConnect();\n          pc.setRemoteDescription(new RTCSessionDescription(sdp))\n        } else if (type === 'candidate') {\n          pc.addIceCandidate(new RTCIceCandidate(candidate))\n        }\n      }\n      ws.onclose = (e) => {\n        console.log(\"onclose\", e)\n      }\n      ws.onerror = (e) => {\n        console.log(\"onerror\", e)\n      }\n    }\n    createWebScoket('ws://127.0.0.1:3000');\n    // åŠ å…¥æˆ¿é—´\n    joinBtn.onclick = () => {\n      roomId = document.getElementById('roomBox').value // è¾“å…¥æ¡†å–æˆ¿é—´å·\n      // æ‹¿åˆ°åª’ä½“è®¾å¤‡æµï¼Œæ˜¾ç¤ºåœ¨æœ¬åœ°\n      navigator.mediaDevices.getUserMedia({ video: true, audio: true }).then((stream) => {\n        ws.send(JSON.stringify({\n          type: 'join',\n          roomId,\n          uid: localUserId\n        }))\n        localStream = stream;\n        localVideo.srcObject = stream;\n      })\n    }\n    function createConnect() {\n      pc = new RTCPeerConnection(null);\n      pc.onicecandidate = (e) => {\n        if (e.candidate) {\n          ws.send(JSON.stringify({\n            type: 'candidate',\n            roomId,\n            uid: localUserId,\n            remoteUid: remoteUserId,\n            candidate: e.candidate\n          }))\n        }\n      }\n      pc.ontrack = (e) => {\n        remoteStream = e.streams[0];\n        remoteVideo.srcObject = remoteStream;\n      }\n      localStream.getTracks().forEach(track => {\n        pc.addTrack(track, localStream)\n      });\n    }\n    // ç¦»å¼€\n    leaveBtn.onclick = () => {\n      ws.send(JSON.stringify({\n        type: 'leave',\n        roomId,\n        uid: localUserId\n      }))\n      remoteVideo.srcObject = null;\n      localStream && localStream.getTracks().forEach(track => track.stop())\n      localVideo.srcObject = null;\n      if(pc) {\n        pc.close();\n        pc = null;\n      }\n    }\n  </script>\n</body>\n</html>\n```\n\n#### ä¿¡ä»¤æœåŠ¡å™¨å®Œæ•´ä»£ç \n```js\nconst ws = require('nodejs-websocket');\nconst roomTableMap = new Map();\nws.createServer((socket) => {\n    socket.on('text', (str) => {\n        const { type = '', roomId, uid, remoteUid, candidate = '', sdp = '' } = JSON.parse(str);\n        if (type === 'join') {\n            let roomMap = roomTableMap.get(roomId);\n            if (!roomMap) {\n                roomMap = new Map();\n                roomTableMap.set(roomId, roomMap)\n            }\n            const client = {\n                roomId,\n                uid,\n                socket\n            }\n            roomMap.set(uid, client)\n            for (const [key, value] of roomMap) {\n                if (key !== uid) {\n                    // é€šçŸ¥å…¶ä»–äººï¼Œæœ‰äººè¿›å…¥æˆ¿é—´äº†\n                    value.socket.sendText(JSON.stringify({ type: 'peer-join', remoteUid: uid }));\n                }\n            }\n        } else if (type === 'leave') {\n            let roomMap = roomTableMap.get(roomId);\n            roomMap.delete(uid);\n            for (const [key, value] of roomMap) {\n                value.socket.sendText(JSON.stringify({ type: 'peer-leave', remoteUid: uid }));\n            }\n        } else if (['offer', 'answer', 'candidate'].includes(type)) {\n            let roomMap = roomTableMap.get(roomId);\n            for (const [key, value] of roomMap) {\n              if (key !== uid) {\n                value.socket.sendText(JSON.stringify({\n                  type,\n                  roomId,\n                  remoteUid: uid,\n                  sdp,\n                  candidate\n                }))\n              }\n            }\n        }\n    })\n    socket.on('close', (data) => {\n        console.log(data);\n    })\n    socket.on('error', (data) => {\n        console.log(data);\n    })\n}).listen(3000)\n```\n\n### æœ€å\næœ¬æ–‡åªæ˜¯webrtcè¿›è¡Œä¸€ä¸ªåˆæ­¥çš„äº†è§£ï¼Œå‚è€ƒäº†<<WebRtcéŸ³è§†é¢‘å®æ—¶äº’åŠ¨æŠ€æœ¯åŸç†>>ä¹¦ç±å’Œbç«™è§†é¢‘ï¼Œå¯¹äºå¤§å®¶å¦‚æœæœ‰æ‰€å¸®åŠ©ï¼Œæ¬¢è¿ç‚¹èµ~\n\nä½œè€…ï¼šç«¹ä¸š\né“¾æ¥ï¼šhttps://juejin.cn/post/7218532789195702333\næ¥æºï¼šç¨€åœŸæ˜é‡‘\nè‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚","tags":["WebRtc"],"categories":["éŸ³è§†é¢‘"]},{"title":"FFmpegä¸SDLå®ç°çœŸæ­£çš„éŸ³è§†é¢‘æ’­æ”¾å™¨","url":"/2024/12/18/FFmpegä¸SDLå®ç°çœŸæ­£çš„éŸ³è§†é¢‘æ’­æ”¾å™¨/","content":"é€šè¿‡å­¦ä¹ è·Ÿç€å†™äº†ä¸€ä¸ªéŸ³è§†é¢‘æ’­æ”¾å™¨ã€‚å†…å®¹æœ‰ç‚¹å¤šï¼Œæ‰€ä»¥æˆ‘å°±ä¸æ‰“ç®—åœ¨åšå®¢éƒ½å±•ç¤ºå‡ºæ¥äº†ï¼Œè¿™é‡Œå°±å±•ç¤ºä¸€ä¸‹æ¯ä¸ªç±»çš„æ ¸å¿ƒé€»è¾‘ã€‚æ€è·¯å¾ˆæ¸…æ™°ï¼Œè¿™é‡Œå°±ç®€å•è®²è§£ä¸€ä¸‹å§((ï½oï¿£3ï¿£)ï½)\n#### éŸ³è§†é¢‘é˜Ÿåˆ—\n- packeté˜Ÿåˆ—\n`avpacketqueue` å­˜å‚¨è§£å¤ç”¨çº¿ç¨‹ä¸­è¯»å–åˆ°çš„packetæ•°æ®ï¼Œå› ä¸ºé˜Ÿåˆ—çš„å®ç°æ¯”è¾ƒç®€å•ï¼Œæˆ‘å°±å±•ç¤ºä¸€ä¸‹è¯¥ç±»çš„ç»“æ„å§\n\n```cpp\nclass AVPacketQueue\n{\npublic:\n    AVPacketQueue();\n    ~AVPacketQueue();\n    void Abort();\n    int Size();\n    int Push(AVPacket *val);\n    AVPacket *Pop(const int timeout);\nprivate:\n    void Release();\n    Queue<AVPacket *>queue_;\n};\n```\n\n- frameè§†é¢‘é˜Ÿåˆ—\n`avframequeue` å­˜å‚¨è§£ç çº¿ç¨‹ä¸­è§£ç åçš„frameæ•°æ®ï¼Œç±»ç»“æ„å¦‚ä¸‹\n```cpp\nclass AVFrameQueue\n{\npublic:\n    AVFrameQueue();\n    ~AVFrameQueue();\n    void Abort();\n    int Push(AVFrame *val);\n    AVFrame *Pop(const int timeout);\n    AVFrame *Front();\n    int Size();\n\nprivate:\n    void release();\n    Queue<AVFrame *>queue_;\n};\n```\n\n#### çº¿ç¨‹åˆ†å·¥\n- ä¸»çº¿ç¨‹\nä¸»è¦å®Œæˆçº¿ç¨‹çš„åˆ›å»ºï¼Œè®©å­çº¿ç¨‹å®Œæˆå…·ä½“çš„å·¥ä½œã€‚å› ä¸ºä¸»çº¿ç¨‹å¯¹ç¨‹åºçš„ç†è§£æŒºé‡è¦çš„ï¼Œæ‰€ä»¥ä½ å¯ä»¥åœ¨æ–‡ç« çš„æœ€åç›´æ¥çœ‹åˆ°ä¸»çº¿ç¨‹çš„æºç \n\n- è§£å¤ç”¨çº¿ç¨‹\n`demuxthread` å®ŒæˆéŸ³é¢‘çš„è§£å¤ç”¨ï¼Œå¹¶å°†pktæ•°æ®å†™å…¥packeté˜Ÿåˆ—ï¼ŒåŒæ—¶éŸ³è§†é¢‘çš„ç›¸å…³å‚æ•°ä¹Ÿç”±è¯¥çº¿ç¨‹æä¾›ã€‚\n```cpp\nwhile(abort_ != 1){\n    ret = av_read_frame(ifmt_ctx_, &pkt);\n    if(ret < 0){\n        av_strerror(ret, err2str, sizeof(err2str));\n        av_log(NULL, AV_LOG_ERROR, \"av_read_frame(ifmt_ctx_, &pkt) failed, ret: %s\\n\", err2str);\n        break;\n    }\n    if(pkt.stream_index == audio_index_){\n        audio_queue_->Push(&pkt);\n        av_log(NULL, AV_LOG_INFO, \"audio pkt queue size:%d\\n\", audio_queue_->Size());\n    }else if(pkt.stream_index == video_index_){\n        video_queue_->Push(&pkt);\n        av_log(NULL, AV_LOG_INFO, \"video pkt queue size:%d\\n\", video_queue_->Size());\n    }else {\n        av_packet_unref(&pkt);\n    }\n}\n```\n\n- è§£ç çº¿ç¨‹\n`decodethread` å®ŒæˆéŸ³è§†é¢‘çš„è§£ç ï¼Œå¹¶å°†è§£ç åçš„æ•°æ®å†™å…¥frameé˜Ÿåˆ—ã€‚\n\n```cpp\nwhile(abort_ != 1){\n    // if(frame_queue_->Size() > 10){\n    //     std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    //     continue;\n    // }\n    AVPacket *pkt = packet_queue_->Pop(10);\n    if(pkt){\n        int ret = avcodec_send_packet(codec_ctx_, pkt);\n        av_packet_free(&pkt);\n        if(ret < 0){\n            av_strerror(ret, err2str, sizeof(err2str));\n            av_log(NULL, AV_LOG_ERROR, \"avcodec_send_packet(codec_ctx_, pkt) failed, ret: %s\\n\", err2str);\n            break;\n        }\n        // è¯»å–è§£ç åçš„æ•°æ®frame\n        while(true){\n            ret = avcodec_receive_frame(codec_ctx_, frame);\n            if(ret == 0){\n                frame_queue_->Push(frame);\n                av_log(NULL, AV_LOG_INFO, \"%s frame queue size:%d\\n\",codec_ctx_->codec->name, frame_queue_->Size());\n                continue;\n            }else if(ret == AVERROR(EAGAIN) || ret == AVERROR_EOF){\n                break;\n            }else {\n                abort_ = 1;\n                av_strerror(ret, err2str, sizeof(err2str));\n                av_log(NULL, AV_LOG_ERROR, \"avcodec_receive_frame(codec_ctx_, frame) failed, ret: %s\\n\", err2str);\n                break;\n            }\n        }\n    }else {\n        //av_log(NULL, AV_LOG_INFO, \"not get packet\\n\");\n    }\n}\n```\n\n#### è¾“å‡ºæ¸²æŸ“\n\n- éŸ³é¢‘è¾“å‡º\n`audiooutput` è¿™é‡Œæ¶‰åŠåˆ°SDLå¯¹æ’­æ”¾éŸ³é¢‘çš„å¤„ç†ã€‚å®é™…ä¸ŠSDLä¼šè‡ªå·±å»ºç«‹çº¿ç¨‹å®Œæˆå¯¹éŸ³é¢‘æ•°æ®çš„è·å–ï¼Œå³é€šè¿‡å›è°ƒçš„æ–¹å¼ï¼Œæ‰€ä»¥æœ€ä¸»è¦çš„å°±æ˜¯è¦è®¾è®¡å¥½å›è°ƒå‡½æ•°ï¼Œä¸‹é¢æ˜¯å›è°ƒå‡½æ•°çš„è®¾è®¡\n\n```cpp\nvoid fill_audio_pcm(void *udata, Uint8 *stream, int len){\n    //1. ä»frame queueè¯»å–è§£ç åçš„PCMæ•°æ®ï¼Œå¡«å……åˆ°stream\n    AudioOutput *is = (AudioOutput *)udata;\n    int len1 = 0;\n    int audio_size = 0;\n    while(len > 0){\n        if(is->audio_buf_index == is->audio_buf_size){\n            is->audio_buf_index = 0;\n            AVFrame *frame = is->frame_queue_->Pop(10);\n            if(frame){\n                is->pts_ = frame->pts;\n                //åˆ¤æ–­è¦ä¸è¦é‡é‡‡æ ·\n                if((frame->format != is->dst_tgt_.fmt)\n                    || (frame->sample_rate != is->dst_tgt_.freq)\n                    || (frame->ch_layout.nb_channels != is->dst_tgt_.channle_layout.nb_channels)\n                    && (!is->swr_ctx_)){\n                    int ret = swr_alloc_set_opts2(&is->swr_ctx_,\n                                        &is->dst_tgt_.channle_layout,\n                                        (enum AVSampleFormat)is->dst_tgt_.fmt,\n                                        is->dst_tgt_.freq,\n                                        &frame->ch_layout,\n                                        (enum AVSampleFormat)frame->format,\n                                        frame->sample_rate,\n                                        0, NULL);\n                    if(ret != 0 || swr_init(is->swr_ctx_) < 0){\n                        av_log(NULL, AV_LOG_ERROR, \"swr_alloc_set_opts2 or swr_init(is->swr_ctx_) failed!\\n\");\n                        swr_free(&is->swr_ctx_);\n                        return ;\n                    }\n                }\n                if(is->swr_ctx_){\n                    const uint8_t **in = (const uint8_t **)frame->extended_data;\n                    uint8_t **out = &is->audio_buf1_;\n                    int out_samples = frame->nb_samples * is->dst_tgt_.freq / frame->sample_rate + 256;\n                    int out_bytes = av_samples_get_buffer_size(NULL, is->dst_tgt_.channles, out_samples, is->dst_tgt_.fmt, 0);\n                    if(out_bytes < 0){\n                        av_log(NULL, AV_LOG_ERROR, \"av_samples_get_buffer_size failed!\\n\");\n                        return ;\n                    }\n                    av_fast_malloc(&is->audio_buf1_, &is->audio_buf1_size, out_bytes);\n                    int len2 = swr_convert(is->swr_ctx_, out, out_samples, in, frame->nb_samples); //è¿”å›æ ·æœ¬æ•°\n                    if(len2 < 0){\n                        av_log(NULL, AV_LOG_ERROR, \"swr_convert failed!\\n\");\n                        return ;\n                    }\n                    is->audio_buf_ = is->audio_buf1_;\n                    is->audio_buf_size = av_samples_get_buffer_size(NULL, is->dst_tgt_.channles, len2, is->dst_tgt_.fmt, 1);\n                }else {\n                    audio_size = av_samples_get_buffer_size(NULL, frame->ch_layout.nb_channels, frame->nb_samples, (enum AVSampleFormat)frame->format, 1);\n                    av_fast_malloc(&is->audio_buf1_, &is->audio_buf1_size, audio_size);\n                    is->audio_buf_ = is->audio_buf1_;\n                    is->audio_buf_size = audio_size;\n                    memcpy(is->audio_buf_, frame->data[0], audio_size);\n                }\n                av_frame_free(&frame);\n            }else{\n                is->audio_buf_ = NULL;\n                is->audio_buf_size = 512;\n            }\n        }\n        len1 = is->audio_buf_size - is->audio_buf_index;\n        if(len1 > len){\n            len1 = len;\n        }\n        if(!is->audio_buf_){\n            memset(stream, 0, len1);\n        }else {\n            memcpy(stream, is->audio_buf_ + is->audio_buf_index, len1);\n        }\n        len -= len1;\n        stream += len1;\n        is->audio_buf_index += len1;\n    }\n    //è®¾ç½®æ—¶é’Ÿ\n    if(is->pts_ != AV_NOPTS_VALUE){\n        double pts = is->pts_ * av_q2d(is->time_base_);\n        av_log(NULL, AV_LOG_INFO, \"audio pts:%0.3lf\\n\", pts);\n        is->avsync_->SetClock(pts);\n    }\n}\n```\n\n- è§†é¢‘è¾“å‡º\n`videooutput` åœ¨ä¸»çº¿æˆé‡Œè°ƒç”¨videooutputçš„ä¸€ä¸ªå¾ªç¯è¾“å‡ºçš„æ–¹æ³•ï¼Œå®ç°è§†é¢‘çš„æ¸²æŸ“ï¼Œä½†è¿™æ ·çš„æ–¹å¼è‚¯å®šæ˜¯ä¸å¥½çš„ï¼Œæ€»ä¹‹å°±å…ˆè¿™æ ·å§(ã„Ÿ( â–”, â–” )ã„)\n\n```cpp\nint VideoOutput::MainLoop()\n{\n    SDL_Event event;\n    while(true){\n        RefreshLoopWaitEvent(&event);\n        switch(event.type){\n        case SDL_KEYDOWN:\n            if(event.key.keysym.sym == SDLK_ESCAPE){\n                av_log(NULL, AV_LOG_INFO, \"esc key down\");\n                return 0;\n            }\n            break;\n        case SDL_QUIT:\n            av_log(NULL, AV_LOG_INFO, \"SDL_QUIT\");\n            return 0;\n        default:\n            break;\n        }\n    }\n    return 0;\n}\n\n```\n\nRefreshLoopWaitEvent()è¿™ä¸ªå‡½æ•°çš„è®¾è®¡ä¸»è¦æ˜¯åœ¨ç­‰å¾…äº‹ä»¶çš„åŒæ—¶å®ŒæˆéŸ³è§†é¢‘çš„å¯¹é½ï¼Œç”±äºæ˜¯è§†é¢‘å¯¹é½éŸ³é¢‘ï¼Œåœ¨è§†é¢‘è´¨é‡å¾ˆé«˜çš„æƒ…å†µä¸‹ï¼Œä¼šå‡ºç°è§†é¢‘è·Ÿä¸ä¸ŠéŸ³é¢‘çš„æƒ…å†µï¼Œæ‰€ä»¥æˆ‘åœ¨ä¸»çº¿ç¨‹é‡Œè®¾ç½®äº†ä¸€ä¸ªç­‰å¾…æ—¶é—´ï¼Œç›®çš„æ˜¯è®©è§£ç çº¿ç¨‹å…ˆè¿è¡Œä¸€æ®µæ—¶é—´ï¼Œè®©è§†é¢‘æ’­æ”¾æ—¶æå‰æœ‰ä¸€äº›æ•°æ®ï¼Œé¿å…è§†é¢‘è§£ç è¿‡æ…¢é€ æˆçš„é—®é¢˜ã€‚ä½†è¿™æ ·è‚¯å®šæ˜¯ä¸è¡Œçš„ï¼Œæˆ‘æƒ³åˆ°ç”¨å¼€å¤šä¸ªè§†é¢‘è§£ç çº¿ç¨‹çš„æ–¹å¼è§£å†³ï¼Œä½†è¿™æ ·åˆä¼šå¼•å‡ºè®¸å¤šé—®é¢˜(ï¼ï¹ï¼œ)ä½†æˆ‘ç›¸ä¿¡ä¼šåœ¨ä»¥åçš„å­¦ä¹ ä¸­ï¼Œè¿™å°†ä¸ä¼šæ˜¯é—®é¢˜(o(*ï¿£ï¸¶ï¿£*)o)\n\n#### éŸ³è§†é¢‘åŒæ­¥\n\n`avsync` éŸ³è§†é¢‘çš„åŒæ­¥æœ‰ä¸‰ç§æ–¹å¼ï¼Œè¿™é‡Œé‡‡ç”¨çš„æ˜¯è§†é¢‘åŸºäºéŸ³é¢‘çš„æ’­æ”¾ï¼Œå¯¹æ—¶é—´çš„è·å–å’Œè®¾ç½®éƒ½æ˜¯é€šè¿‡è¯¥ç±»å®ç°çš„ï¼Œå†…å®¹å¾ˆå°‘æˆ‘å°±ç›´æ¥è´´å‡ºæ¥äº†\n```cpp\nAVSync(){}\n\nvoid InitClock(){\n    SetClock(NAN); //æ•°å­¦å¯¹æ¯”æ˜¯ä¸€ä¸ªæ— æ•ˆå€¼\n}\nvoid SetClockAt(double pts, double time){\n    pts_ = pts;\n    pts_drift_ = pts_ - time;\n}\n\ndouble GetClock(){\n    double time = GetMicroseconds() / 1000000.0;\n    return pts_drift_ + time;\n}\n\nvoid SetClock(double pts){\n    double time = GetMicroseconds() / 1000000.0; //ui->s\n    SetClockAt(pts, time);\n}\n\ntime_t GetMicroseconds(){\n    system_clock::time_point time_point_new = system_clock::now();\n    system_clock::duration duration = time_point_new.time_since_epoch();\n\n    time_t us = duration_cast<microseconds>(duration).count();\n    return us;\n}\n\ndouble pts_ = 0;\ndouble pts_drift_ = 0;\n```\n\n#### ä¸»å‡½æ•°\n```cpp\n#define SDL_MAIN_HANDLED\n#include \"demuxthread.h\"\n#include \"decodethread.h\"\n#include \"audiooutput.h\"\n#include \"videooutput.h\"\n\nusing namespace std;\n\nchar err2str[256] = {0};\n\nint main(int argc, char *argv[])\n{\n    int ret = 0;\n    av_log_set_level(AV_LOG_INFO);\n    if(argc < 2){\n        av_log(NULL, AV_LOG_ERROR, \"argc < 2!\\n\");\n        return -1;\n    }\n    //åˆ›å»ºéŸ³è§†é¢‘é˜Ÿåˆ—\n    AVPacketQueue audio_packet_queue;\n    AVPacketQueue video_packet_queue;\n\n    AVFrameQueue audio_frame_queue;\n    AVFrameQueue video_frame_queue;\n\n    AVSync avsync;\n    avsync.InitClock();\n\n    //1. è§£å¤ç”¨çº¿ç¨‹\n    DemuxThread *demux_thread = new DemuxThread(&audio_packet_queue, &video_packet_queue);\n    ret = demux_thread->Init(argv[1]);\n    if(ret < 0){\n        av_log(NULL, AV_LOG_ERROR, \"demux_thread.Init(argv[1]) failed!\\n\");\n        return -1;\n    }\n\n    ret = demux_thread->Start();\n    if(ret < 0){\n        av_log(NULL, AV_LOG_ERROR, \"demux_thread.Start() failed!\\n\");\n        return -1;\n    }\n\n    //2. è§£ç çº¿ç¨‹\n    DecodeThread *video_decode_thread = new DecodeThread(&video_packet_queue, &video_frame_queue);\n    ret = video_decode_thread->Init(demux_thread->VideoCodecParameters());\n    if(ret < 0){\n        av_log(NULL, AV_LOG_ERROR, \"video_decode_thread->Init() failed!\\n\");\n        return -1;\n    }\n    ret = video_decode_thread->Start();\n    if(ret < 0){\n        av_log(NULL, AV_LOG_ERROR, \"video_decode_thread->Start() failed!\\n\");\n        return -1;\n    }\n\n    DecodeThread *audio_decode_thread = new DecodeThread(&audio_packet_queue, &audio_frame_queue);\n    ret = audio_decode_thread->Init(demux_thread->AudioCodecParameters());\n    if(ret < 0){\n        av_log(NULL, AV_LOG_ERROR, \"audio_decode_thread->Init() failed!\\n\");\n        return -1;\n    }\n    ret = audio_decode_thread->Start();\n    if(ret < 0){\n        av_log(NULL, AV_LOG_ERROR, \"audio_decode_thread->Start() failed!\\n\");\n        return -1;\n    }\n\n    //ä¼‘çœ  è¿™é‡Œé¢„å…ˆè§£ç ä¸€äº›éŸ³è§†é¢‘çš„æ•°æ®ï¼Œå°½é‡é˜²æ­¢éŸ³é¢‘çš„æ’­æ”¾é€Ÿåº¦å¤§äºè§†é¢‘çš„æ’­æ”¾é€Ÿåº¦å¯¼è‡´è§†é¢‘æ’­æ”¾è·Ÿä¸ä¸ŠéŸ³é¢‘æ’­æ”¾çš„é—®é¢˜ ä½†è¿™æ ·çš„è§£å†³æ–¹å¼è‚¯å®šæ˜¯ä¸å¤Ÿçš„ï¼Œå¯èƒ½éœ€è¦å¤šçº¿ç¨‹è§£ç çš„æ–¹å¼\n    std::this_thread::sleep_for(std::chrono::milliseconds(3 * 1000));\n\n    // åˆå§‹åŒ–audioè¾“å‡º\n    AudioParams audio_params = {0};\n    memset(&audio_params, 0, sizeof(AudioParams));\n    audio_params.channles = demux_thread->AudioCodecParameters()->ch_layout.nb_channels;\n    audio_params.channle_layout = demux_thread->AudioCodecParameters()->ch_layout;\n    audio_params.fmt = (enum AVSampleFormat)demux_thread->AudioCodecParameters()->format;\n    audio_params.freq = demux_thread->AudioCodecParameters()->sample_rate;\n    audio_params.frame_size = demux_thread->AudioCodecParameters()->frame_size;\n\n    AudioOutput *audio_output = new AudioOutput(&avsync, demux_thread->AudioStreamTime(), audio_params, &audio_frame_queue);\n    ret = audio_output->Init();\n    if(ret < 0){\n        av_log(NULL, AV_LOG_ERROR, \"audio_output->Init() failed!\\n\");\n        return -1;\n    }\n\n    // åˆå§‹åŒ–è§†é¢‘è¾“å‡º\n    VideoOutput *video_output = new VideoOutput(&avsync, demux_thread->VideoStreamTime(),\n                                                &video_frame_queue,\n                                                demux_thread->VideoCodecParameters()->width,\n                                                demux_thread->VideoCodecParameters()->height,\n                                                640, 480);\n    ret = video_output->Init();\n    if(ret < 0){\n        av_log(NULL, AV_LOG_ERROR, \"video_output->Init() failed!\\n\");\n        return -1;\n    }\n    video_output->MainLoop(); //ç¨‹åºä¼šåœåœ¨è¿™é‡Œç›´åˆ°é€€å‡º\n\n    //ä¼‘çœ \n    //std::this_thread::sleep_for(std::chrono::milliseconds(120 * 1000));\n\n__END:\n    demux_thread->Stop();\n    delete demux_thread;\n\n    audio_decode_thread->Stop();\n    delete audio_decode_thread;\n    video_decode_thread->Stop();\n    delete video_decode_thread;\n\n    audio_output->DeInit();\n    delete audio_output;\n\n    av_log(NULL, AV_LOG_INFO, \"main finished\\n\");\n\n    return 0;\n}\n\n```","tags":["FFmpeg","SDL","å¤šçº¿ç¨‹","éŸ³è§†é¢‘åŒæ­¥","é˜Ÿåˆ—"],"categories":["éŸ³è§†é¢‘"]},{"title":"SDLä¸FFmpegç»“åˆå®ç°ç®€å•çš„è§†é¢‘æ’­æ”¾å™¨","url":"/2024/12/17/SDLä¸FFmpegç»“åˆå®ç°ç®€å•çš„è§†é¢‘æ’­æ”¾å™¨/","content":"\nç”¨FFmpegä¸SDLå†™äº†ä¸€ä¸ªç®€å•çš„éŸ³è§†é¢‘æ’­æ”¾å™¨ï¼Œä½†è¿˜æœ‰å¾ˆå¤§çš„é—®é¢˜ã€‚é¦–å…ˆå¹¶æ²¡æœ‰ä½¿ç”¨å¤šçº¿ç¨‹ï¼ŒéŸ³è§†é¢‘çš„è§£ç æ¸²æŸ“æ“ä½œéƒ½åœ¨ä¸»çº¿ç¨‹ä¸­ï¼Œå¯¼è‡´åœ¨åŒæ—¶æ’­æ”¾è§†é¢‘çš„æ—¶å€™ï¼ŒéŸ³é¢‘çš„æ’­æ”¾ä¼šå‡ºç°æ–­æ–­ç»­ç»­çš„æƒ…å†µï¼ŒæŠŠè§†é¢‘çš„æ’­æ”¾å…³é—­å°±ä¸ä¼šå‡ºç°é—®é¢˜ã€‚è¿˜æœ‰å°±æ˜¯é˜Ÿåˆ—çš„å®ç°ï¼Œç›®å‰åªæœ‰éŸ³é¢‘ä½¿ç”¨äº†é˜Ÿåˆ—ï¼Œè€Œè§†é¢‘åˆ™æ˜¯ç›´æ¥æ’­æ”¾æ¸²æŸ“, è¦ä½¿ç”¨é˜Ÿåˆ—çš„è¯å°±ä¸å¾—ä¸å®ç°å¤šçº¿ç¨‹äº†ã€‚ä¹‹åè¿˜æœ‰éŸ³è§†é¢‘çš„åŒæ­¥ç­‰ç­‰ï¼Œè¿™äº›éƒ½æ˜¯éœ€è¦æ”¹è¿›çš„ç‚¹ã€‚ä¸è¿‡æˆ‘ç›¸ä¿¡åœ¨åé¢çš„å­¦ä¹ ä¸­éƒ½ä¼šè§£å†³çš„<(ï¿£ï¸¶ï¿£)â†—[GO!]\n\nè¿™é‡Œå°±ç›´æ¥æ”¾æºç äº†(â—‹ï½€ 3â€²â—‹)\n\n```c\n#include <stdio.h>\n#include <windows.h>\n#include <SDL.h>\n\n#include <libavutil/log.h>\n#include <libavutil/avutil.h>\n#include <libavutil/fifo.h>\n#include <libavformat/avformat.h>\n#include <libavcodec/avcodec.h>\n#include <libswresample/swresample.h>\n\n#define AUDIO_BUFFER_SIZE 1024\n\ntypedef struct _PacketQueue{\n    AVFifo *pkts;\n    int nb_packets;\n    int size;\n    int64_t duration;\n\n    SDL_mutex *mutex;\n    SDL_cond *cond;\n}PacketQueue;\n\ntypedef struct _VideoState{\n    AVCodecContext *avctx;\n    AVPacket *pkt;\n    AVFrame *frame;\n    SDL_Texture *texture;\n\n    struct SwrContext *swr_ctx;\n\n    uint8_t *audio_buf;\n    int audio_buf_size;\n    int audio_buf_index;\n\n    PacketQueue audioq;\n    PacketQueue videoq;\n}VideoState;\n\n\ntypedef struct MyPacketEle{\n    AVPacket *pkt;\n}MyPacketEle;\n\n\nstatic int w_width = 640;\nstatic int w_height = 480;\n\nstatic SDL_Window *win = NULL;\nstatic SDL_Renderer *renderer = NULL;\n\nstatic int packet_queue_init(PacketQueue *q){\n    memset(q, 0, sizeof(PacketQueue));\n    q->pkts = av_fifo_alloc2(1, sizeof(MyPacketEle), AV_FIFO_FLAG_AUTO_GROW);\n    if(!q->pkts){\n        return AVERROR(ENOMEM);\n    }\n\n    q->mutex = SDL_CreateMutex();\n    if(!q->mutex){\n        return AVERROR(ENOMEM);\n    }\n\n    q->cond = SDL_CreateCond();\n    if(!q->cond){\n        return AVERROR(ENOMEM);\n    }\n}\n\nstatic int packet_queue_put_priv(PacketQueue *q, AVPacket *pkt){\n    MyPacketEle mypkt;\n    int ret;\n    mypkt.pkt = pkt;\n    ret = av_fifo_write(q->pkts, &mypkt, 1);\n    if(ret < 0){\n        return ret;\n    }\n    q->nb_packets++;\n    q->size += mypkt.pkt->size + sizeof(mypkt);\n    q->duration += mypkt.pkt->duration;\n    SDL_CondSignal(q->cond);\n    return 0;\n}\n\nstatic int packet_queue_put(PacketQueue *q, AVPacket *pkt){\n    AVPacket *pkt1;\n    int ret = -1;\n    pkt1 = av_packet_alloc();\n    if(!pkt1){\n        av_packet_unref(pkt1);\n        return -1;\n    }\n    av_packet_move_ref(pkt1, pkt);\n    SDL_LockMutex(q->mutex);\n\n    ret = packet_queue_put_priv(q, pkt1);\n    SDL_UnlockMutex(q->mutex);\n\n    if(ret < 0){\n        av_packet_free(&pkt1);\n    }\n\n    return ret;\n}\n\nstatic int packet_queue_get(PacketQueue *q, AVPacket *pkt, int block){\n    MyPacketEle mypkt;\n    int ret = 1;\n\n    SDL_LockMutex(q->mutex);\n    while(1){\n        if(av_fifo_read(q->pkts, &mypkt, 1) >= 0){\n            q->nb_packets--;\n            q->size -= mypkt.pkt->size + sizeof(mypkt);\n            q->duration -=mypkt.pkt->duration;\n            av_packet_move_ref(pkt, mypkt.pkt);\n            av_packet_free(&mypkt.pkt);\n            ret = 1;\n            break;\n        }else if(!block){\n            ret = 0;\n            break;\n        }else{\n            SDL_CondWait(q->cond, q->mutex);\n        }\n    }\n    SDL_UnlockMutex(q->mutex);\n    return ret;\n}\n\nstatic void packet_queue_flush(PacketQueue *q){\n    MyPacketEle mypkt;\n    SDL_LockMutex(q->mutex);\n    while(av_fifo_read(q->pkts, &mypkt, 1) > 0){\n        av_packet_free(&mypkt.pkt);\n    }\n    q->nb_packets = 0;\n    q->size = 0;\n    q->duration = 0;\n    SDL_UnlockMutex(q->mutex);\n}\n\nstatic void packet_queue_destroy(PacketQueue *q){\n    packet_queue_flush(q);\n    av_fifo_freep2(&q->pkts);\n    SDL_DestroyMutex(q->mutex);\n    SDL_DestroyCond(q->cond);\n}\n\nstatic void render(VideoState *is){\n    SDL_UpdateYUVTexture(is->texture, NULL, \n    is->frame->data[0], is->frame->linesize[0], \n    is->frame->data[1], is->frame->linesize[1], \n    is->frame->data[2], is->frame->linesize[2]);\n\n    SDL_RenderClear(renderer);\n    SDL_RenderCopy(renderer, is->texture, NULL, NULL);\n    SDL_RenderPresent(renderer);\n}\n\nstatic int decode(VideoState *is){\n    int ret = -1;\n    ret = avcodec_send_packet(is->avctx, is->pkt);\n    if(ret < 0){\n        av_log(NULL, AV_LOG_ERROR, \"Failed to send pkt to video decoder!\\n\");\n        goto __OUT;\n    }\n    while(ret >= 0){\n        ret = avcodec_receive_frame(is->avctx, is->frame);\n        if(ret == AVERROR(EAGAIN) || ret == AVERROR_EOF){\n            ret = 0;\n            goto __OUT;\n        }else if(ret < 0){\n            ret = -1;\n            goto __OUT;\n        }\n        render(is);\n    }\n__OUT:\n    return ret;\n}\n\nstatic int audio_decode_frame(VideoState *ais){\n    int ret = -1;\n    int len2;\n\n    int data_size = 0;\n\n    AVPacket pkt;\n    while(1){\n        if(packet_queue_get(&ais->audioq, &pkt, 1) < 0){\n            return -1;\n        }\n        ret = avcodec_send_packet(ais->avctx, &pkt);\n        if(ret < 0){\n            av_log(ais->avctx, AV_LOG_ERROR, \"Failed to send pkt to audio decoder!\\n\");\n            goto __OUT;\n        }\n        while(ret >= 0){\n            ret = avcodec_receive_frame(ais->avctx, ais->frame);\n            if(ret == AVERROR(EAGAIN) || ret == AVERROR_EOF){\n                break;\n            }else if(ret < 0){\n                av_log(ais->avctx, AV_LOG_ERROR, \"Failed to receive frame from audio decoder!\\n\");\n                goto __OUT;\n            }\n\n            if(!ais->swr_ctx){\n                AVChannelLayout in_ch_layout, out_ch_layout;\n                av_channel_layout_copy(&in_ch_layout, &ais->avctx->ch_layout);\n                av_channel_layout_copy(&out_ch_layout, &ais->avctx->ch_layout);\n                if(ais->avctx->sample_fmt != AV_SAMPLE_FMT_S16){\n                    swr_alloc_set_opts2(&ais->swr_ctx, &out_ch_layout, AV_SAMPLE_FMT_S16, ais->avctx->sample_rate, &in_ch_layout, ais->avctx->sample_fmt, ais->avctx->sample_rate, 0, NULL);\n                    swr_init(ais->swr_ctx);\n                }\n            }\n\n            if(ais->swr_ctx){\n                const uint8_t **in = (const uint8_t **)ais->frame->extended_data;\n                uint8_t **out = &ais->audio_buf;\n                int out_cont = ais->frame->nb_samples + 512;\n                int in_cont = ais->frame->nb_samples;\n\n                int out_size = av_samples_get_buffer_size(NULL, ais->frame->ch_layout.nb_channels, out_cont, AV_SAMPLE_FMT_S16, 0);\n                av_fast_malloc(&ais->audio_buf, &ais->audio_buf_size, out_size);\n\n                len2 = swr_convert(ais->swr_ctx, out, out_cont, in, in_cont);\n                data_size = len2 * ais->frame->ch_layout.nb_channels * av_get_bytes_per_sample(AV_SAMPLE_FMT_S16);\n            }else {\n                ais->audio_buf = *(ais->frame->extended_data);\n                data_size = av_samples_get_buffer_size(NULL, ais->frame->ch_layout.nb_channels, ais->frame->nb_samples, ais->frame->format, 1);\n            }\n\n            av_packet_unref(&pkt);\n            av_frame_unref(ais->frame);\n\n            return data_size;\n        }\n    }\n__OUT:\n    return ret;\n}\n\nstatic void sdl_audio_callback(void *userdata, Uint8 *stream, int len){\n    int audio_size = 0, len1 = 0;\n    VideoState *ais = (VideoState*)userdata;\n\n    SDL_memset(stream, 0, len);\n    while(len > 0){\n        if(ais->audio_buf_index >= ais->audio_buf_size){\n            audio_size = audio_decode_frame(ais);\n            if(audio_size < 0){\n                ais->audio_buf_size = AUDIO_BUFFER_SIZE;\n                ais->audio_buf = NULL;\n            }else {\n                ais->audio_buf_size = audio_size;\n            }\n            ais->audio_buf_index = 0;\n        }\n        len1 = ais->audio_buf_size - ais->audio_buf_index;\n        if(len1 > len){\n            len1 = len;\n        }\n        if(ais->audio_buf){\n            memcpy(stream, (uint8_t *)ais->audio_buf + ais->audio_buf_index, len1); \n            //SDL_MixAudio(stream, ais->audio_buf, len1, SDL_MIX_MAXVOLUME);\n        }else {\n            memset(stream, 0, len1);\n        }\n        len -= len1;\n        stream += len1;\n        ais->audio_buf_index += len1;\n    }\n}\n\nint APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {\n    //1. è®¾ç½®å‚æ•°\n    int ret = -1;\n    int vIdx = -1, aIdx = -1;\n\n    SDL_Texture *texture = NULL;\n    SDL_Event event;\n\n    Uint32 pixformat = 0;\n    int video_width = 0;\n    int video_height = 0;\n\n    VideoState *vis = NULL;\n    VideoState *ais = NULL;\n\n    SDL_AudioSpec wanted_spec, spec;\n\n    AVFormatContext *FmtCtx = NULL;\n    AVStream *vinstream = NULL;\n    AVStream *ainstream = NULL;\n\n    const AVCodec *vdec = NULL;\n    AVCodecContext *vctx = NULL;\n    const AVCodec *adec = NULL;\n    AVCodecContext *actx = NULL;\n\n    AVPacket *vpkt = NULL;\n    AVFrame *vframe = NULL;\n    AVPacket *apkt = NULL;\n    AVFrame *aframe = NULL;\n    AVPacket *pkt = NULL;\n\n    char *src = NULL;\n    src = strtok(lpCmdLine, \" \");\n    if(!src){\n        printf(\"Error: Expected one parameters.\\n\");\n        goto __END;\n    }\n    \n    vis = av_mallocz(sizeof(VideoState));\n    if(!vis){\n        av_log(NULL, AV_LOG_ERROR, \"NO MEMORY!\\n\");\n        goto __END;\n    }\n    ais = av_mallocz(sizeof(VideoState));\n    if(!ais){\n        av_log(NULL, AV_LOG_ERROR, \"NO MEMORY!\\n\");\n        goto __END;\n    }\n\n    // // strtok ç”¨äºåˆ†å‰²å‘½ä»¤è¡Œå­—ç¬¦ä¸²ï¼Œé»˜è®¤åˆ†éš”ç¬¦ä¸ºç©ºæ ¼\n    // src = strtok(lpCmdLine, \" \");\n    // if (src != NULL) {\n    //     dst = strtok(NULL, \" \");\n    // }\n\n    // // æ£€æŸ¥æ˜¯å¦æˆåŠŸè§£æäº†ä¸¤ä¸ªå‚æ•°\n    // if (src != NULL && dst != NULL) {\n    //     printf(\"Parameter 1: %s\\n\", src);\n    //     printf(\"Parameter 2: %s\\n\", dst);\n    // } else {\n    //     printf(\"Error: Expected two parameters.\\n\");\n    // }\n\n    //2. åˆå§‹åŒ–SDLï¼Œå¹¶åˆ›å»ºçª—å£å’ŒRender\n    if (SDL_Init(SDL_INIT_AUDIO | SDL_INIT_VIDEO)) {\n        printf(\"åˆå§‹åŒ– SDL å¤±è´¥ï¼\\n\");\n        return ret;\n    }\n\n    win = SDL_CreateWindow(\"YUV Player\", \n                            SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, \n                            w_width, w_height, SDL_WINDOW_OPENGL|SDL_WINDOW_RESIZABLE);\n    if(!win){\n        printf(\"Failed to create window, %s\\n\", SDL_GetError());\n        goto __END;\n    }\n    renderer = SDL_CreateRenderer(win, -1, 0);\n\n    //3. æ‰“å¼€å¤šåª’ä½“æ–‡ä»¶ï¼Œå¹¶è·å–æµä¿¡æ¯\n    if((ret = avformat_open_input(&FmtCtx, src, NULL, NULL)) < 0){\n        av_log(NULL, AV_LOG_ERROR, \"%s\\n\", av_err2str(ret));\n        goto __END;\n    }\n    ret = avformat_find_stream_info(FmtCtx, NULL);\n    if(ret < 0){\n        av_log(NULL, AV_LOG_ERROR, \"%s\\n\", av_err2str(ret));\n        goto __END;\n    }\n\n    //4. æŸ¥æ‰¾æµ\n    for(int i = 0; i < FmtCtx->nb_streams; i++){\n        if(FmtCtx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && vIdx < 0){\n            vIdx = i;\n        }\n        if(FmtCtx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && aIdx < 0){\n            aIdx = i;\n        }\n        if(vIdx > -1 && aIdx > -1){\n            break;\n        }\n    }\n    if(vIdx < 0 || aIdx < 0){\n        av_log(NULL, AV_LOG_ERROR, \"è§†é¢‘æœ‰é—®é¢˜!\");\n        goto __END;\n    }\n\n    ainstream = FmtCtx->streams[aIdx];\n    vinstream = FmtCtx->streams[vIdx];\n\n    //5. æ ¹æ®æµä¸­çš„codec_idï¼Œè·å¾—è§†é¢‘è§£ç å™¨\n    vdec = avcodec_find_decoder(vinstream->codecpar->codec_id);\n    if(!vdec){\n        av_log(NULL, AV_LOG_ERROR, \"Could not find codec\");\n        goto __END;\n    }\n    //6. åˆ›å»ºè§£ç å™¨ä¸Šä¸‹æ–‡\n    vctx = avcodec_alloc_context3(vdec);\n    if(!vctx){\n        av_log(NULL, AV_LOG_ERROR, \"NO MEMRORY\\n\");\n        goto __END;\n    }\n    //7. ä»å¤šåª’ä½“æ–‡ä»¶ä¸­æ‹·è´è§£ç å™¨å‚æ•°åˆ°è§£ç å™¨ä¸Šä¸‹æ–‡ä¸­\n    ret = avcodec_parameters_to_context(vctx, vinstream->codecpar);\n    if(ret < 0){\n        av_log(vctx, AV_LOG_ERROR, \"Could not copy codecpar to codec ctx!\\n\");\n        goto __END;\n    }\n\n    //8. ç»‘å®šè§£ç å™¨ä¸Šä¸‹æ–‡\n    ret = avcodec_open2(vctx, vdec, NULL);\n    if(ret < 0){\n        av_log(vctx, AV_LOG_ERROR, \"Don't open codec:%s\\n\", av_err2str(ret));\n        goto __END;\n    }\n\n    //9. æ ¹æ®æµä¸­çš„codec_idï¼Œè·å¾—éŸ³é¢‘è§£ç å™¨\n    adec = avcodec_find_decoder(ainstream->codecpar->codec_id);\n    if(!adec){\n        av_log(NULL, AV_LOG_ERROR, \"Could not find codec\");\n        goto __END;\n    }\n    //10. åˆ›å»ºè§£ç å™¨ä¸Šä¸‹æ–‡\n    actx = avcodec_alloc_context3(adec);\n    if(!actx){\n        av_log(NULL, AV_LOG_ERROR, \"NO MEMRORY\\n\");\n        goto __END;\n    }\n    //11. ä»å¤šåª’ä½“æ–‡ä»¶ä¸­æ‹·è´è§£ç å™¨å‚æ•°åˆ°è§£ç å™¨ä¸Šä¸‹æ–‡ä¸­\n    ret = avcodec_parameters_to_context(actx, ainstream->codecpar);\n    if(ret < 0){\n        av_log(actx, AV_LOG_ERROR, \"Could not copy codecpar to codec ctx!\\n\");\n        goto __END;\n    }\n    //12. ç»‘å®šè§£ç å™¨ä¸Šä¸‹æ–‡\n    ret = avcodec_open2(actx, adec, NULL);\n    if(ret < 0){\n        av_log(actx, AV_LOG_ERROR, \"Don't open codec:%s\\n\", av_err2str(ret));\n        goto __END;\n    }\n\n    //13. è®¾ç½®éŸ³è§†é¢‘çº¹ç†å‚æ•°\n    video_width = vctx->width;\n    video_height = vctx->height;\n    pixformat = SDL_PIXELFORMAT_IYUV;\n    texture = SDL_CreateTexture(renderer, pixformat, SDL_TEXTUREACCESS_STREAMING, video_width, video_height);\n\n    \n    vpkt = av_packet_alloc();\n    vframe = av_frame_alloc();\n\n    apkt = av_packet_alloc();\n    aframe = av_frame_alloc();\n\n    pkt = av_packet_alloc();\n\n    vis->texture = texture;\n    vis->avctx = vctx;\n    vis->pkt = vpkt;\n    vis->frame = vframe;\n    packet_queue_init(&vis->videoq);\n\n    ais->texture = texture;\n    ais->avctx = actx;\n    ais->pkt = apkt;\n    ais->frame = aframe;\n    packet_queue_init(&ais->audioq);\n\n    wanted_spec.freq = actx->sample_rate;\n    wanted_spec.format = AUDIO_S16SYS;\n    wanted_spec.channels = actx->ch_layout.nb_channels;\n    wanted_spec.silence = 0;\n    wanted_spec.samples = AUDIO_BUFFER_SIZE;\n    wanted_spec.callback = sdl_audio_callback;\n    wanted_spec.userdata = (void *)ais;\n\n    if(SDL_OpenAudio(&wanted_spec, NULL) < 0){\n        av_log(NULL, AV_LOG_ERROR, \"Failed to open audio device!\\n\");\n        goto __END;\n    }\n\n    SDL_PauseAudio(0);\n\n    //14. ä»å¤šåª’ä½“æ–‡ä»¶ä¸­è¯»å–æ•°æ®ï¼Œè¿›è¡Œè§£ç \n    while(1){\n        av_read_frame(FmtCtx, pkt);\n        //15. å¯¹è§£ç åçš„è§†é¢‘æ•°æ®è¿›è¡Œæ¸²æŸ“\n        if(pkt->stream_index == vIdx){\n            vis->pkt = pkt;\n            decode(vis);\n            // if(packet_queue_put(&vis->videoq, pkt) < 0){\n            //     printf(\"å‘é˜Ÿåˆ—æ·»åŠ éŸ³é¢‘æ•°æ®å¤±è´¥!\");\n            // }\n        }else if(pkt->stream_index == aIdx){\n            if(packet_queue_put(&ais->audioq, pkt) < 0){\n                printf(\"å‘é˜Ÿåˆ—æ·»åŠ éŸ³é¢‘æ•°æ®å¤±è´¥!\");\n            }\n        }else {\n            av_packet_unref(pkt);\n        }\n        //å»¶è¿Ÿ 1 æ¯«ç§’ï¼Œé˜²æ­¢ CPU å ç”¨è¿‡é«˜\n        SDL_Delay(1);\n\n        //16. å¤„ç†SDLäº‹ä»¶\n        SDL_PollEvent(&event);\n        switch(event.type){\n            case SDL_QUIT:\n                exit(-1);\n            default:\n                break;\n        }\n        av_packet_unref(vpkt);\n    }\n\n    vis->pkt = NULL;\n    decode(vis);\n    packet_queue_put(&ais->audioq, NULL);\n\n__END:\n    //17. æ”¶å°¾ï¼Œé‡Šæ”¾èµ„æº\n    if(vframe){\n        av_frame_free(&vframe);\n    }\n    if(vpkt){\n        av_packet_free(&vpkt);\n    }\n    if(aframe){\n        av_frame_free(&aframe);\n    }\n    if(apkt){\n        av_packet_free(&apkt);\n    }\n    if(vctx){\n        avcodec_free_context(&vctx);\n    }\n    if(FmtCtx){\n        avformat_close_input(&FmtCtx);\n    }\n    if(win){\n        SDL_DestroyWindow(win);\n    }\n    if(renderer){\n        SDL_DestroyRenderer(renderer);\n    }\n    if(texture){\n        SDL_DestroyTexture(texture);\n    }\n    if(ais){\n        av_free(ais);\n    }\n    if(vis){\n        av_free(vis);\n    }\n    SDL_Quit();\n    return ret;\n}\n```","tags":["FFmpeg","SDL"],"categories":["éŸ³è§†é¢‘"]},{"title":"SDLåˆæ¢","url":"/2024/12/14/SDLåˆæ¢/","content":"\nå­¦ä¹ äº†ä¸€ä¸‹SDLï¼Œè·Ÿç€æ•™å­¦ç”¨SDLå®ç°äº†ä»¥ä¸‹çš„ç®€å•ç¨‹åº\nè¿™é‡Œå…¥å£å‡½æ•°è¢«è®¾ç½®ä¸ºäº†WinMainï¼Œæ˜¯å› ä¸ºSDLå¯¹å…¥å£å‡½æ•°çš„è¦æ±‚ï¼Œå¯ä»¥é€šè¿‡åŠ å…¥`#define SDL_MAIN_HANDLED`æ¥é˜»æ­¢SDLé‡å†™mainå‡½æ•°ã€‚\n\n### éšæœºåŠ è½½çº¢è‰²æ–¹å—\n\n```c\n#include <stdio.h>\n#include <windows.h>\n#include <SDL.h>\n\nint APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)\n{\n    int quit = 1;\n    SDL_Event event;\n    SDL_Window *window = NULL;\n    SDL_Renderer *render = NULL;\n    SDL_Texture *texture = NULL;\n\n    SDL_Rect rect;\n    rect.w = 30;\n    rect.h = 30;\n\n    // åˆå§‹åŒ– SDL è§†é¢‘å­ç³»ç»Ÿ\n    if (SDL_Init(SDL_INIT_VIDEO) != 0) {\n        printf(\"SDL_Init failed: %s\\n\", SDL_GetError());\n        return -1;\n    }\n\n    // åˆ›å»ºçª—å£\n    window = SDL_CreateWindow(\"Hello World\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 640, 360, SDL_WINDOW_SHOWN);\n    if (!window) {\n        printf(\"Failed to Create Window: %s\\n\", SDL_GetError());\n        goto __EXIT;\n    }\n\n    // åˆ›å»ºæ¸²æŸ“å™¨\n    render = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);\n    if (!render) {\n        printf(\"Failed to Create Render: %s\\n\", SDL_GetError());\n        goto __EXIT;\n    }\n\n    // // è®¾ç½®æ¸²æŸ“é¢œè‰²ä¸ºçº¢è‰²\n    // SDL_SetRenderDrawColor(render, 255, 0, 0, 255);\n\n    // // ç”¨è®¾ç½®å¥½çš„é¢œè‰²åˆ·æ–°å±å¹•\n    // SDL_RenderClear(render);\n\n    // // è®©æ˜¾ç¤ºå™¨å°†æ–°å±å¹•å±•ç¤ºå‡ºæ¥\n    // SDL_RenderPresent(render);\n\n    texture = SDL_CreateTexture(render, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, 640, 360);\n    if(!texture){\n        printf(\"Failed to Create Textrue!\");\n        goto __EXIT;\n    }\n    do{\n        SDL_PollEvent(&event);\n        switch(event.type){\n        case SDL_QUIT:\n            quit = 0;\n            break;\n        default:\n            printf(\"event type is %d\", event.type);\n        }\n        rect.x = rand() % 640;\n        rect.y = rand() % 360;\n        SDL_SetRenderTarget(render, texture);\n        SDL_SetRenderDrawColor(render, 0, 0, 0, 255);\n        SDL_RenderClear(render);\n\n        SDL_RenderDrawRect(render, &rect);\n        SDL_SetRenderDrawColor(render, 255, 0, 0, 255);\n        SDL_RenderFillRect(render, &rect);\n\n        SDL_SetRenderTarget(render, NULL);\n        SDL_RenderCopy(render, texture, NULL, NULL);\n        SDL_RenderPresent(render);\n\n    }while(quit);\n\n    // // ç­‰å¾…3ç§’é’Ÿ\n    // SDL_Delay(3000);\n\n\n__EXIT:\n    if(window){\n        // é”€æ¯çª—å£\n        SDL_DestroyWindow(window);\n    }\n    if(render) {\n        // é”€æ¯æ¸²æŸ“å™¨\n        SDL_DestroyRenderer(render);\n    }\n    if(texture){\n        // é”€æ¯çº¹ç†å™¨\n        SDL_DestroyTexture(texture);\n    }\n\n    SDL_Quit();\n\n    return 0;\n}\n```\n\n### å®ç°PCMçš„æ’­æ”¾\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <windows.h>\n#include <SDL.h>\n\n#define BLOCK_SIZE 4096000  // å®šä¹‰éŸ³é¢‘ç¼“å†²åŒºå¤§å°\n\nstatic size_t buffer_len = 0;  // å½“å‰ç¼“å†²åŒºçš„æ•°æ®é•¿åº¦\nstatic Uint8 *audio_pos = NULL;  // å½“å‰éŸ³é¢‘æ•°æ®çš„ä½ç½®\nstatic Uint8 *audio_buf = NULL;  // å­˜æ”¾éŸ³é¢‘æ•°æ®çš„ç¼“å†²åŒº\n\n// SDL éŸ³é¢‘å›è°ƒå‡½æ•°ï¼Œå¤„ç†éŸ³é¢‘æ’­æ”¾æ•°æ®\nvoid read_audio_data(void *udata, Uint8 *stream, int len) {\n    if (buffer_len == 0) {\n        return;  // å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œç›´æ¥è¿”å›\n    }\n\n    // æ¸…ç©ºéŸ³é¢‘è¾“å‡ºæµ\n    SDL_memset(stream, 0, len);\n\n    // ç¡®ä¿ä¸ä¼šè¯»å–è¶…è¿‡ç¼“å†²åŒºçš„æ•°æ®\n    len = (len < buffer_len) ? len : buffer_len;\n\n    // å°†éŸ³é¢‘æ•°æ®æ··åˆåˆ°è¾“å‡ºæµä¸­\n    SDL_MixAudio(stream, audio_pos, len, SDL_MIX_MAXVOLUME);\n\n    // æ›´æ–°éŸ³é¢‘æ•°æ®ä½ç½®å’Œå‰©ä½™æ•°æ®é•¿åº¦\n    audio_pos += len;\n    buffer_len -= len;\n}\n\nint APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {\n    int ret = -1;\n    char *path = \"./output.pcm\";  // PCM æ–‡ä»¶è·¯å¾„\n    FILE *audio_fd = NULL;\n\n    // åˆå§‹åŒ– SDL\n    if (SDL_Init(SDL_INIT_AUDIO | SDL_INIT_TIMER)) {\n        printf(\"åˆå§‹åŒ– SDL å¤±è´¥ï¼\\n\");\n        return ret;\n    }\n\n    // æ‰“å¼€ PCM æ–‡ä»¶ å¹¶ä»¥äºŒè¿›åˆ¶çš„æ¨¡å¼è¯»å–ï¼Œé¿å…æ•°æ®çš„é”™è¯¯è¯»å–\n    audio_fd = fopen(path, \"rb\");\n    if (!audio_fd) {\n        printf(\"æ‰“å¼€ PCM æ–‡ä»¶å¤±è´¥ï¼\\n\");\n        goto __FAIL;\n    }\n\n    // ä¸ºéŸ³é¢‘æ•°æ®åˆ†é…å†…å­˜ç¼“å†²åŒº\n    audio_buf = (Uint8*)malloc(BLOCK_SIZE);\n    if (!audio_buf) {\n        printf(\"åˆ†é…å†…å­˜å¤±è´¥ï¼\\n\");\n        goto __FAIL;\n    }\n\n    // è®¾ç½® SDL éŸ³é¢‘è§„æ ¼\n    SDL_AudioSpec spec;\n    spec.freq = 48000;       // è®¾ç½®é‡‡æ ·ç‡ä¸º 48000Hz\n    spec.channels = 2;       // è®¾ç½®ä¸ºç«‹ä½“å£° (2 é€šé“)\n    spec.format = AUDIO_S16SYS; // è®¾ç½®éŸ³é¢‘æ ¼å¼ä¸º 16-bit æœ‰ç¬¦å·æ•´æ•°\n    spec.silence = 0;        // è®¾ç½®é™éŸ³å€¼ä¸º 0\n    spec.callback = read_audio_data;  // è®¾ç½®å›è°ƒå‡½æ•°\n    spec.userdata = NULL;    // æœªä½¿ç”¨çš„ç”¨æˆ·æ•°æ®\n\n    // æ‰“å¼€éŸ³é¢‘è®¾å¤‡\n    if (SDL_OpenAudio(&spec, NULL) < 0) {\n        printf(\"æ‰“å¼€éŸ³é¢‘è®¾å¤‡å¤±è´¥ï¼\\n\");\n        goto __FAIL;\n    }\n\n    // å¯åŠ¨éŸ³é¢‘æ’­æ”¾\n    SDL_PauseAudio(0);\n\n    // éŸ³é¢‘æ•°æ®æ’­æ”¾å¾ªç¯\n    do {\n        // ä» PCM æ–‡ä»¶ä¸­è¯»å–æ•°æ®åˆ°ç¼“å†²åŒº\n        buffer_len = fread(audio_buf, 1, BLOCK_SIZE, audio_fd);\n        audio_pos = audio_buf;\n\n        // ç­‰å¾…ç›´åˆ°éŸ³é¢‘å›è°ƒå‡½æ•°å¤„ç†å®Œæ•°æ®\n        while (buffer_len > 0) {\n            SDL_Delay(10);  // å»¶è¿Ÿ 10 æ¯«ç§’ï¼Œé˜²æ­¢ CPU å ç”¨è¿‡é«˜\n        }\n\n    } while (buffer_len != 0);  // ç›´åˆ°æ²¡æœ‰æ›´å¤šæ•°æ®\n\n    // å…³é—­éŸ³é¢‘è®¾å¤‡\n    SDL_CloseAudio();\n    ret = 0;\n\n__FAIL:\n    // é‡Šæ”¾èµ„æº\n    if (audio_fd) {\n        fclose(audio_fd);\n    }\n    if (audio_buf) {\n        free(audio_buf);\n    }\n    SDL_Quit();\n    return ret;\n}\n\n```","tags":["SDL"],"categories":["éŸ³è§†é¢‘"]},{"title":"å®ç°FFmpegçš„è§†é¢‘è½¬å›¾ç‰‡(BMP)","url":"/2024/12/13/å®ç°FFmpegçš„è§†é¢‘è½¬å›¾ç‰‡(BMP)/","content":"\nç»“æ„ä½“ä¿¡æ¯å¯ä»¥çœ‹è¿™é‡Œ\nhttps://learn.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-bitmapfileheader\n\nè¿™é‡Œæœ€å®¹æ˜“å‡ºé”™çš„åœ°æ–¹å°±æ˜¯è¿™é‡Œçš„\n#pragma pack(push, 1) // ç¡®ä¿ç»“æ„ä½“å¯¹é½æ–¹å¼ä¸ BMP æ ¼å¼ä¸€è‡´\n#pragma pack(pop)\n\nå¯¹è¿™ä¸ªçš„è®²è§£æˆ‘è¿™é‡Œç›´æ¥å¼•ç”¨äº†AIçš„(è®²çš„æ˜¯çœŸçš„å¥½ï¼ˆã€ƒï½€ 3â€²ã€ƒï¼‰)\n### `#pragma pack(push, 1)` å’Œ `#pragma pack(pop)` çš„ä½œç”¨\n\nè¿™ä¸¤ä¸ªç¼–è¯‘æŒ‡ä»¤ç”¨æ¥æ§åˆ¶ **ç»“æ„ä½“æˆå‘˜çš„å¯¹é½æ–¹å¼**ï¼Œç‰¹åˆ«æ˜¯è®¾ç½®å¦‚ä½•åœ¨å†…å­˜ä¸­æ’åˆ—ç»“æ„ä½“çš„æ•°æ®ã€‚  \n\n#### é»˜è®¤å¯¹é½æ–¹å¼\né»˜è®¤æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨ä¼šå¯¹ç»“æ„ä½“æˆå‘˜è¿›è¡Œå¯¹é½ï¼Œä»¥ä¼˜åŒ–å†…å­˜è®¿é—®çš„æ€§èƒ½ã€‚  \nä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªç»“æ„ä½“æˆå‘˜æ˜¯ `uint32_t` ç±»å‹ï¼ˆ4 å­—èŠ‚ï¼‰ï¼Œå®ƒé€šå¸¸ä¼šå¯¹é½åˆ° **4 å­—èŠ‚è¾¹ç•Œ**ã€‚è¿™æ ·ä¼šå¯¼è‡´ç»“æ„ä½“ä¸­å¯èƒ½å‡ºç°ä¸€äº›é¢å¤–çš„ **å¡«å……å­—èŠ‚**ï¼ˆpaddingï¼‰ï¼Œä»¥ä¿è¯å¯¹é½ã€‚\n\nä¾‹å¦‚ï¼š\n```c\ntypedef struct {\n    uint8_t a;  // 1 å­—èŠ‚\n    uint32_t b; // 4 å­—èŠ‚\n} Example;\n\né»˜è®¤æƒ…å†µä¸‹ï¼Œè¿™ä¸ªç»“æ„ä½“çš„å†…å­˜å¸ƒå±€æ˜¯ï¼š\n| a | å¡«å…… (3 å­—èŠ‚) | b | => æ€»å¤§å°ä¸º 8 å­—èŠ‚\n```\n\n#### `#pragma pack(push, 1)`\nå½“ä½¿ç”¨ `#pragma pack(push, 1)` æ—¶ï¼Œç»“æ„ä½“çš„æˆå‘˜æŒ‰ **1 å­—èŠ‚å¯¹é½**ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆå‘˜ä¼šç´§å¯†æ’åˆ—ï¼Œä¸ä¼šæ’å…¥å¡«å……å­—èŠ‚ã€‚\n\næ”¹ç”¨ `#pragma pack(push, 1)` çš„æƒ…å†µï¼š\n```c\n#pragma pack(push, 1)\ntypedef struct {\n    uint8_t a;  // 1 å­—èŠ‚\n    uint32_t b; // 4 å­—èŠ‚\n} Example;\n#pragma pack(pop)\n\nå†…å­˜å¸ƒå±€ï¼š\n| a | b | => æ€»å¤§å°ä¸º 5 å­—èŠ‚\n```\n\n#### ä¸ºä»€ä¹ˆåœ¨å¤„ç† BMP æ–‡ä»¶æ—¶ä½¿ç”¨ï¼Ÿ\nBMP æ–‡ä»¶å¤´å’Œä¿¡æ¯å¤´çš„æ ¼å¼æ˜¯ä¸¥æ ¼å®šä¹‰çš„ï¼Œå®ƒä»¬åœ¨æ–‡ä»¶ä¸­çš„æ¯ä¸€éƒ¨åˆ†éƒ½éœ€è¦ç´§å¯†æ’åˆ—ï¼Œä¸èƒ½æœ‰å¡«å……å­—èŠ‚ã€‚  \nä¾‹å¦‚ï¼š\n- `BMPFileHeader` çš„å¤§å°å¿…é¡»æ˜¯ 14 å­—èŠ‚ã€‚\n- `BMPInfoHeader` çš„å¤§å°å¿…é¡»æ˜¯ 40 å­—èŠ‚ã€‚\n\nå¦‚æœä½¿ç”¨é»˜è®¤å¯¹é½æ–¹å¼ï¼Œç»“æ„ä½“å¯èƒ½ä¼šåŒ…å«å¡«å……å­—èŠ‚ï¼Œå¯¼è‡´æ–‡ä»¶æ ¼å¼ä¸ç¬¦åˆè§„èŒƒã€‚ä½¿ç”¨ `#pragma pack(push, 1)` å¯ä»¥ç¡®ä¿æ•°æ®ç»“æ„çš„å†…å­˜å¸ƒå±€ä¸ BMP æ–‡ä»¶çš„å®šä¹‰å®Œå…¨ä¸€è‡´ã€‚\n\n#### `#pragma pack(pop)`\nè¿™ä¸ªæŒ‡ä»¤ç”¨æ¥æ¢å¤å¯¹é½æ–¹å¼åˆ°ä¹‹å‰çš„çŠ¶æ€ã€‚  \n`#pragma pack(push, 1)` æ”¹å˜äº†å¯¹é½æ–¹å¼ï¼Œå› æ­¤åœ¨å®šä¹‰å®Œéœ€è¦ç´§å¯†å¯¹é½çš„ç»“æ„ä½“åï¼Œç”¨ `#pragma pack(pop)` æ¢å¤é»˜è®¤å¯¹é½æ–¹å¼ï¼Œä»¥å…å½±å“åç»­ä»£ç çš„æ€§èƒ½ã€‚\n\n---\n\n#### æ€»ç»“\n- `#pragma pack(push, 1)` ç¡®ä¿ç»“æ„ä½“ç´§å¯†å¯¹é½ï¼Œæ— å¡«å……å­—èŠ‚ï¼Œé€‚åˆæ–‡ä»¶æ ¼å¼çš„å®šä¹‰ã€‚\n- `#pragma pack(pop)` æ¢å¤é»˜è®¤å¯¹é½æ–¹å¼ï¼Œé¿å…å…¨å±€å½±å“ã€‚\n- åœ¨å¤„ç†åƒ BMP è¿™ç§å¯¹æ•°æ®æ ¼å¼ä¸¥æ ¼è¦æ±‚çš„åœºæ™¯æ—¶ï¼Œæ˜¾å¾—å°¤ä¸ºé‡è¦ã€‚\n\n### å°†è§†é¢‘è½¬BMPå›¾ç‰‡çš„æ¡ˆä¾‹\n\n```c\n#pragma pack(push, 1) // ç¡®ä¿ç»“æ„ä½“å¯¹é½æ–¹å¼ä¸ BMP æ ¼å¼ä¸€è‡´\n\n// BMP æ–‡ä»¶å¤´\ntypedef struct {\n    uint16_t bfType;      // æ–‡ä»¶æ ‡è¯†ç¬¦ ('BM')\n    uint32_t bfSize;      // æ–‡ä»¶å¤§å°\n    uint16_t bfReserved1; // ä¿ç•™å­—æ®µ\n    uint16_t bfReserved2; // ä¿ç•™å­—æ®µ\n    uint32_t bfOffBits;   // æ•°æ®åç§»é‡\n} BMPFileHeader;\n\n// BMP ä¿¡æ¯å¤´\ntypedef struct {\n    uint32_t biSize;          // ä¿¡æ¯å¤´å¤§å°\n    int32_t  biWidth;         // å›¾åƒå®½åº¦\n    int32_t  biHeight;        // å›¾åƒé«˜åº¦\n    uint16_t biPlanes;        // é¢œè‰²å¹³é¢æ•°ï¼ˆå§‹ç»ˆä¸º1ï¼‰\n    uint16_t biBitCount;      // æ¯åƒç´ ä½æ•°ï¼ˆ24ä½ï¼ŒBGRï¼‰\n    uint32_t biCompression;   // å‹ç¼©æ–¹å¼ï¼ˆ0è¡¨ç¤ºä¸å‹ç¼©ï¼‰\n    uint32_t biSizeImage;     // å›¾åƒæ•°æ®å¤§å°\n    int32_t  biXPelsPerMeter; // æ°´å¹³åˆ†è¾¨ç‡ï¼ˆåƒç´ /ç±³ï¼‰\n    int32_t  biYPelsPerMeter; // å‚ç›´åˆ†è¾¨ç‡ï¼ˆåƒç´ /ç±³ï¼‰\n    uint32_t biClrUsed;       // è°ƒè‰²æ¿é¢œè‰²æ•°ï¼ˆ0è¡¨ç¤ºæ— è°ƒè‰²æ¿ï¼‰\n    uint32_t biClrImportant;  // é‡è¦é¢œè‰²æ•°ï¼ˆ0è¡¨ç¤ºæ‰€æœ‰é¢œè‰²é‡è¦ï¼‰\n} BMPInfoHeader;\n\n#pragma pack(pop)\n\nvoid saveBMP(unsigned char* buf, int width, int height, int linesize, const char* name) {\n    FILE *f = fopen(name, \"wb\");\n    if (!f) {\n        fprintf(stderr, \"æ— æ³•æ‰“å¼€æ–‡ä»¶: %s\\n\", name);\n        return;\n    }\n\n    // åˆå§‹åŒ– BMP æ–‡ä»¶å¤´\n    BMPFileHeader fileHeader = {\n        .bfType = 0x4D42, // 'BM'\n        .bfSize = 0,      // ç¨åå¡«å……\n        .bfReserved1 = 0,\n        .bfReserved2 = 0,\n        .bfOffBits = sizeof(BMPFileHeader) + sizeof(BMPInfoHeader) // æ•°æ®åç§»é‡\n    };\n\n    // åˆå§‹åŒ– BMP ä¿¡æ¯å¤´\n    BMPInfoHeader infoHeader = {\n        .biSize = sizeof(BMPInfoHeader),\n        .biWidth = width,\n        .biHeight = height, // æ³¨æ„ï¼šæ­£æ•°è¡¨ç¤ºä»ä¸‹åˆ°ä¸Šå­˜å‚¨\n        .biPlanes = 1,\n        .biBitCount = 24,\n        .biCompression = 0,\n        .biSizeImage = 0,   // ç¨åå¡«å……\n        .biXPelsPerMeter = 0,\n        .biYPelsPerMeter = 0,\n        .biClrUsed = 0,\n        .biClrImportant = 0\n    };\n\n    // è®¡ç®—æ¯è¡Œå¡«å……çš„å­—èŠ‚æ•°\n    //int row_padded = (width * 3 + 3) & (~3); // è¡Œå¡«å……åˆ°4å­—èŠ‚å¯¹é½\n    int image_size = width * height;    // å›¾åƒæ•°æ®æ€»å¤§å°\n    fileHeader.bfSize = sizeof(BMPFileHeader) + sizeof(BMPInfoHeader) + image_size;\n    infoHeader.biSizeImage = image_size;\n\n    // å†™å…¥æ–‡ä»¶å¤´å’Œä¿¡æ¯å¤´\n    fwrite(&fileHeader, sizeof(BMPFileHeader), 1, f);\n    fwrite(&infoHeader, sizeof(BMPInfoHeader), 1, f);\n\n    // å†™å…¥å›¾åƒæ•°æ®ï¼ˆä»ä¸‹åˆ°ä¸Šå­˜å‚¨ï¼‰\n    for (int i = height - 1; i >= 0; i--) {\n        fwrite(buf + i * linesize, 1, width * 3, f); // æ¯ä¸ªåƒç´ 3ä¸ªå­—èŠ‚ï¼ŒRGB\n    }\n    fclose(f);\n}\n\n\n\nstatic int decode(AVCodecContext *ctx, AVFrame *frame, AVPacket *pkt, const char* fileName) {\n    int ret = -1;\n    char buf[1024];\n\n    ret = avcodec_send_packet(ctx, pkt);\n    if (ret < 0) {\n        av_log(NULL, AV_LOG_ERROR, \"å‘é€æ•°æ®åŒ…åˆ°è§£ç å™¨å¤±è´¥!\\n\");\n        goto _END;\n    }\n\n    while (ret >= 0) {\n        ret = avcodec_receive_frame(ctx, frame);\n        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {\n            return 0;\n        } else if (ret < 0) {\n            return -1;\n        }\n\n        // åˆ›å»ºè½¬æ¢ä¸Šä¸‹æ–‡ï¼Œå°†YUVè½¬æ¢ä¸ºRGB\n        struct SwsContext *sws_ctx = sws_getContext(\n            frame->width, frame->height, frame->format,\n            frame->width, frame->height, AV_PIX_FMT_BGR24,\n            SWS_BICUBIC, NULL, NULL, NULL\n        );\n        if (!sws_ctx) {\n            av_log(NULL, AV_LOG_ERROR, \"åˆå§‹åŒ–è½¬æ¢ä¸Šä¸‹æ–‡å¤±è´¥\\n\");\n            return -1;\n        }\n\n        // ä¸ºRGBæ•°æ®åˆ†é…å†…å­˜\n        uint8_t *rgb_data = (uint8_t *)malloc(frame->width * frame->height * 3); // æ¯ä¸ªåƒç´ 3ä¸ªå­—èŠ‚\n        int rgb_linesize = frame->width * 3;\n\n        // æ‰§è¡Œè½¬æ¢\n        sws_scale(sws_ctx, (const uint8_t *const *)frame->data, frame->linesize, 0, frame->height, &rgb_data, &rgb_linesize);\n\n        snprintf(buf, sizeof(buf), \"%s-%d.bmp\", fileName, ctx->frame_num);\n        saveBMP(rgb_data, frame->width, frame->height, rgb_linesize, buf);\n\n        free(rgb_data);\n        sws_freeContext(sws_ctx);\n    }\n\n_END:\n    return 0;\n}\n\n\nint main(int argc, char *argv[])\n{\n    int ret = -1;\n    int idx = -1;\n    // 1. å¤„ç†å‚æ•°\n    char* src;  // è¾“å…¥æ•°æ®\n    char* dst;  // è¾“å‡ºæ•°æ®\n\n    AVFormatContext *pFmtCtx = NULL;\n    AVStream *inStream = NULL;\n\n    const AVCodec *codec = NULL;\n    AVCodecContext *ctx = NULL;\n\n    AVPacket *pkt = NULL;\n    AVFrame *frame = NULL;\n\n    av_log_set_level(AV_LOG_DEBUG);\n    if(argc < 3) {\n        av_log(NULL, AV_LOG_INFO, \"å‚æ•°æ•°é‡ä¸è¶³!\\n\");\n        exit(-1);\n    }\n\n    src = argv[1];\n    dst = argv[2];\n\n    // 2. é…ç½®è¾“å…¥ä¸Šä¸‹æ–‡ï¼Œæ‰“å¼€å¤šåª’ä½“æ–‡ä»¶\n    if((ret = avformat_open_input(&pFmtCtx, src, NULL, NULL)) < 0){\n        av_log(NULL, AV_LOG_ERROR, \"%s\\n\", av_err2str(ret));\n        exit(-1);\n    }\n\n    // 3. ä»å¤šåª’ä½“æ–‡ä»¶ä¸­æ‰¾åˆ°è§†é¢‘æµ\n    idx = av_find_best_stream(pFmtCtx, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);\n    if(idx < 0){\n        av_log(pFmtCtx, AV_LOG_ERROR, \"æœªæ‰¾åˆ°è§†é¢‘æµ!\\n\");\n        goto __ERROR;\n    }\n\n    // 4. æŸ¥æ‰¾ç¼–ç å™¨\n    inStream = pFmtCtx->streams[idx];\n    codec = avcodec_find_decoder(inStream->codecpar->codec_id);\n    if(!codec){\n        av_log(NULL, AV_LOG_ERROR, \"æ‰¾ä¸åˆ°è§£ç å™¨\\n\");\n        goto __ERROR;\n    }\n\n    // 5. é…ç½®ç¼–ç å™¨ä¸Šä¸‹æ–‡\n    ctx = avcodec_alloc_context3(codec);\n    if(!ctx){\n        av_log(NULL, AV_LOG_ERROR, \"å†…å­˜åˆ†é…å¤±è´¥\\n\");\n        goto __ERROR;\n    }\n    avcodec_parameters_to_context(ctx, inStream->codecpar);\n\n    // 6. æ‰“å¼€è§£ç å™¨\n    ret = avcodec_open2(ctx, codec, NULL);\n    if(ret < 0){\n        av_log(ctx, AV_LOG_ERROR, \"è§£ç å™¨æ‰“å¼€å¤±è´¥: %s\\n\", av_err2str(ret));\n        goto __ERROR;\n    }\n\n    // 7. åˆ›å»ºAVFrame\n    frame = av_frame_alloc();\n    if(!frame){\n        av_log(NULL, AV_LOG_ERROR, \"å†…å­˜åˆ†é…å¤±è´¥!\\n\");\n        goto __ERROR;\n    }\n\n    // 8. åˆ›å»ºAVPacket\n    pkt = av_packet_alloc();\n    if(!pkt){\n        av_log(NULL, AV_LOG_ERROR, \"å†…å­˜åˆ†é…å¤±è´¥!\\n\");\n        goto __ERROR;\n    }\n\n    // 9. è¯»å–è§†é¢‘æ•°æ®å¹¶ä¿å­˜ä¸ºå›¾åƒ\n    while(av_read_frame(pFmtCtx, pkt) >= 0){\n        if(pkt->stream_index == idx){\n            decode(ctx, frame, pkt, dst);\n        }\n        av_packet_unref(pkt);\n    }\n\n    decode(ctx, frame, NULL, dst);\n\n    //10. é‡Šæ”¾èµ„æº\n__ERROR:\n    if(pFmtCtx){\n        avformat_close_input(&pFmtCtx);\n        pFmtCtx = NULL;\n    }\n    if(ctx){\n        avcodec_free_context(&ctx);\n        ctx = NULL;\n    }\n    if(frame){\n        av_frame_free(&frame);\n        frame = NULL;\n    }\n    if(pkt){\n        av_packet_free(&pkt);\n        pkt = NULL;\n    }\n    return 0;\n}\n```","tags":["FFmpeg","BMP"],"categories":["éŸ³è§†é¢‘"]},{"title":"ç”¨FFmpegè‡ªå¸¦çš„AACç¼–ç å™¨è¿›è¡Œç¼–ç ","url":"/2024/12/11/ç”¨FFmpegè‡ªå¸¦çš„AACç¼–ç å™¨è¿›è¡Œç¼–ç /","content":"\nå¤§ä½“å†…å®¹å’Œhttps://stardm.ddns-ip.net/2024/12/01/%E2%91%A2%E5%AE%9E%E7%8E%B0%E7%94%B5%E8%84%91%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91%E7%9A%84%E5%BD%95%E5%88%B6%E5%B9%B6%E5%B0%81%E8%A3%85%E6%88%90mp4/ è¿™ä¸€ç¯‡çš„ç›¸åŒï¼Œè¿™é‡Œä¸»è¦å±•ç¤ºæ”¹å˜æœ‰å˜åŠ¨çš„éƒ¨åˆ†\n\n### **éŸ³é¢‘é‡‡é›†æ­¥éª¤**\n\nè¿™é‡Œçš„åºå·ä¸`â‘¢å®ç°ç”µè„‘éŸ³é¢‘å’Œè§†é¢‘çš„å½•åˆ¶å¹¶å°è£…æˆmp4`è¿™ç¯‡é‡Œçš„å¯¹åº”\n\n3. **æ‰“å¼€AACç¼–ç å™¨**  \n   ```cpp\n   open_encoder(&codec_ctx);\n   ```\n\n4. **é…ç½®é‡é‡‡æ ·ä¸Šä¸‹æ–‡ï¼ˆä¸»è¦å°±æ˜¯å¤šäº†è¿™ä¸€æ­¥ï¼‰**  \n   ```cpp\n   init_resampler(codec_ctx, &swr_ctx, &src_data, &dst_data);\n   ```\n\n\n8. **é…ç½®è§£ç åæ•°æ®çš„frameå®¹å™¨åŠéŸ³é¢‘å¸§**\n\n```cpp\n    //è·å–frame_size\n    const int frame_size = codec_ctx->frame_size;\n    // åˆå§‹åŒ–å¸§ç¼–å·\n    int64_t pts = 0;\n\n    frame->nb_samples = dec_ctx->frame_size;\n    frame->sample_rate = dec_ctx->sample_rate;\n    frame->ch_layout = dec_ctx->ch_layout;\n    frame->format = dec_ctx->sample_fmt;\n\n    av_frame_get_buffer(frame, 0);\n\n    AVFrame *nframe = av_frame_alloc();\n    nframe->nb_samples = codec_ctx->frame_size;\n    nframe->sample_rate = codec_ctx->sample_rate;\n    nframe->ch_layout = codec_ctx->ch_layout;\n    nframe->format = codec_ctx->sample_fmt;\n\n    av_frame_get_buffer(nframe, 0);\n\n    fifo = init_audio_fifo(codec_ctx->sample_fmt, dec_ctx->ch_layout.nb_channels);\n```\n\n9. **ç”¨ `av_read_frame()` è¯»å–éŸ³é¢‘æ•°æ®å¹¶å†™å…¥æ–‡ä»¶**\n\n---\n\n### **open_encoder() çš„å…·ä½“å®ç°**\n\n```cpp\nint AudioRecorder::open_encoder(AVCodecContext **codec_ctx) {\n    AVDictionary *options = NULL;\n    const AVCodec *codec = avcodec_find_encoder_by_name(\"aac\"); //è¿™é‡Œæ”¹æˆaac\n    if (!codec) {\n        qDebug() << \"ç¼–ç å™¨ libfdk_aac æœªæ‰¾åˆ°\";\n        return 0;\n    }\n\n    // åˆ†é…ç¼–ç å™¨ä¸Šä¸‹æ–‡\n    *codec_ctx = avcodec_alloc_context3(codec);\n    if (!*codec_ctx) {\n        qDebug() << \"ç¼–ç å™¨ä¸Šä¸‹æ–‡åˆ†é…å¤±è´¥\";\n        return 0;\n    }\n\n    // è®¾ç½®ç¼–ç å™¨å‚æ•°\n    AVChannelLayout ch_layout;\n    av_channel_layout_default(&ch_layout, 2);\n    (*codec_ctx)->sample_rate = 48000;\n    (*codec_ctx)->sample_fmt = AV_SAMPLE_FMT_FLTP;  // æ ·æœ¬æ ¼å¼æ”¹æˆFLTP\n    (*codec_ctx)->bit_rate = 128000;\n    if (av_channel_layout_copy(&(*codec_ctx)->ch_layout, &ch_layout) < 0) {\n        qDebug() << \"è®¾ç½®é€šé“å¸ƒå±€å¤±è´¥\";\n        return 0;\n    }\n\n    // æ‰“å¼€ç¼–ç å™¨\n    if (avcodec_open2(*codec_ctx, codec, &options) < 0) {\n        qDebug() << \"ç¼–ç å™¨æ‰“å¼€å¤±è´¥\";\n        return 0;\n    }\n\n    return 1;\n}\n```\n\n---\n\n### **init_resampler() çš„å…·ä½“å®ç°(è¿™é‡Œä¿æŒä¸å˜)**\n\n```cpp\nint AudioRecorder::init_resampler(AVCodecContext *codec_ctx, SwrContext **swr_ctx, uint8_t ***src_data, uint8_t ***dst_data) {\n    *swr_ctx = swr_alloc();\n    AVChannelLayout in_ch_layout;\n    av_channel_layout_default(&in_ch_layout, 2);  // ç«‹ä½“å£°å¸ƒå±€\n\n    // é…ç½®é‡é‡‡æ ·ä¸Šä¸‹æ–‡\n    swr_alloc_set_opts2(swr_ctx,\n                        &codec_ctx->ch_layout,          // è¾“å‡ºé€šé“å¸ƒå±€\n                        codec_ctx->sample_fmt,          // è¾“å‡ºé‡‡æ ·æ ¼å¼\n                        codec_ctx->sample_rate,         // è¾“å‡ºé‡‡æ ·ç‡\n                        &in_ch_layout,                 // è¾“å…¥é€šé“å¸ƒå±€\n                        AV_SAMPLE_FMT_S16,              // è¾“å…¥é‡‡æ ·æ ¼å¼\n                        48000,                         // è¾“å…¥é‡‡æ ·ç‡\n                        0, nullptr);\n\n    if (!*swr_ctx || swr_init(*swr_ctx) < 0) {\n        qDebug() << \"é‡é‡‡æ ·åˆå§‹åŒ–å¤±è´¥\";\n        return 0;\n    }\n\n    // åˆ›å»ºè¾“å…¥è¾“å‡ºç¼“å†²åŒº\n    av_samples_alloc_array_and_samples(src_data, nullptr, in_ch_layout.nb_channels, 22050, AV_SAMPLE_FMT_S16, 0);\n    av_samples_alloc_array_and_samples(dst_data, nullptr, 2, 22050, codec_ctx->sample_fmt, 0);\n    \n    return 1;  // æˆåŠŸ\n}\n```\n\n---\n\n### **éŸ³é¢‘æ•°æ®è¯»å–ä¸å†™å…¥æ–‡ä»¶è¿‡ç¨‹**\n\nçœ‹å®˜æ–¹æ¡ˆä¾‹å°±å¯ä»¥çŸ¥é“æˆ‘è¿™é‡Œå†™çš„ä¸€å¡Œç³Šæ¶‚(ä¸è¿‡æˆ‘ä¹Ÿæ‡’å¾—æ”¹äº†(ï¿£ï¹ƒï¿£))\n\n```cpp\n //å¼€å§‹è·å–éŸ³é¢‘å¸§æ•°æ®ï¼Œå¹¶è¿›è¡Œè½¬æ¢\n    while (flage && av_read_frame(fmt_ctx, &pkt) == 0) {\n        int ret = avcodec_send_packet(dec_ctx, &pkt);\n        if(ret < 0){\n            qDebug() << \"å‘è§£ç å™¨å‘é€æ•°æ®åŒ…å¤±è´¥!\";\n            return;\n        }\n        while(ret >= 0){\n            ret = avcodec_receive_frame(dec_ctx, frame);\n            if(ret < 0){\n                if(ret == AVERROR(EAGAIN) || ret == AVERROR_EOF){\n                    break;\n                }\n                qDebug() << \"Error, decoding video frame\";\n                return;\n            }\n\n            swr_convert(swr_ctx, dst_data, nb_samples, frame->data, nb_samples);//æ·»åŠ è¿™ä¸€æ­¥\n\n            //å°†æ ·æœ¬æ•°æ®å†™å…¥ FIFO\n            write_to_fifo(fifo, (const uint8_t**)dst_data, nb_samples); //è¿™é‡Œçš„frameæ”¹æˆdst_data\n            while (av_audio_fifo_size(fifo) >= frame_size) {\n                read_from_fifo(fifo, nframe->data, frame_size);\n                nframe->nb_samples = codec_ctx->frame_size;\n                nframe->pts = pts;\n                ret = avcodec_send_frame(codec_ctx, nframe); //è¿˜æœ‰è¿™ä¸ªå‘é€çš„æ•°æ®åŒ…æ”¹æˆnframe\n                if(ret < 0){\n                    qDebug() << \"å‘ç¼–ç å™¨å‘é€æ•°æ®åŒ…å¤±è´¥!\";\n                    return;\n                }\n                while(ret >= 0){\n                    ret = avcodec_receive_packet(codec_ctx, newpkt);\n                    if(ret < 0){\n                        if(ret == AVERROR(EAGAIN) || ret == AVERROR_EOF){\n                            break;\n                        }\n                        qDebug() << \"Error, encoding video frame\";\n                        return;\n                    }\n                    newpkt->pts = newpkt->dts = pts;\n                    newpkt->stream_index = audio_stream_index;\n                    CallbackFun write = std::bind(&MainWindow::Main_av_interleaved_write_frame, static_cast<MainWindow *>(parent), *ofmt_ctx, newpkt);\n                    write();\n                    av_packet_unref(newpkt);\n                }\n                pts += frame_size;\n            }\n            av_frame_unref(frame);\n        }\n        av_packet_unref(&pkt);\n    }\n```\nä¹‹å‰æˆ‘è¿™é‡Œread_from_fifo(fifo, frame->data, frame_size); ä¹‹å‰å·æ‡’ï¼Œç›´æ¥ç”¨frameã€‚å› ä¸ºæ²¡æœ‰é‡é‡‡æ ·ï¼Œæ‰€ä»¥frameçš„dataæ•°æ®åˆæ˜¯ä¸€è‡´çš„ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰å‘ç”Ÿæ”¹å†™æ“ä½œï¼Œè¿™æ ·å°±ä¸ä¼šå—å¼•ç”¨è®¡æ•°çš„å½±å“ï¼Œä»è€Œä¸ä¼šæŠ¥é”™ã€‚ä½†å°±æ˜¯è¿™ä¹ˆç‚¹ç»†èŠ‚ç»“æœè®©æˆ‘åœ¨ç”¨å®˜æ–¹AACç¼–ç å™¨ä¸Šä¸€ç›´å†™ä¸å¯¹(ç„¶åå°±ç”¨libfdk_aacäº†^(*ï¿£(oo)ï¿£)^)","tags":["FFmpeg","AAC"],"categories":["éŸ³è§†é¢‘"]},{"title":"Cloudflareè¯ä¹¦çš„é¢å‘åˆ‡æ¢ä¸º Google Trust(GTS)","url":"/2024/12/10/Cloudflareè¯ä¹¦çš„é¢å‘åˆ‡æ¢ä¸º Google Trust(GTS)/","content":"\nåœ¨ä½¿ç”¨cloudflareæ—¶å‘ç°äº†SSLçš„è¯ä¹¦å®‰å…¨é—®é¢˜ï¼Œç»è¿‡ä¸€æ®µæ—¶é—´çš„æŠ˜è…¾ï¼Œè¯ä¹¦å®‰å…¨é—®é¢˜å€’æ˜¯è§£å†³äº†ã€‚ä½†æ˜¯æˆ‘å‘ç°cloudflareé‡ŒSSLæ˜¾ç¤ºçš„æœ‰æ•ˆè¯ä¹¦ä¸æˆ‘ç½‘ç«™çš„çœŸå®è¯ä¹¦ä¸ä¸€è‡´ï¼Œæ‰€ä»¥å°±æ‰¾åˆ°äº†è¿™ä¸ªè°ƒç”¨å®˜æ–¹APIçš„æ–¹æ³•ã€‚ä½†è°ƒç”¨æˆåŠŸåï¼Œæˆ‘å‘ç°ç½‘ç«™çš„å®é™…è¯ä¹¦è¿˜æ˜¯ä¸ä¸€æ ·(å¾ˆå¯èƒ½æ˜¯æˆ‘ä¸€å¼€å§‹çæå¼„æˆè¿™æ ·çš„/(ã„’oã„’)/~~)ã€‚æ€»ä¹‹é™è§‚å…¶å˜å§ï¼Œçœ‹çœ‹å®ƒç»­ç­¾çš„æ—¶å€™ä¼šä¸ä¼šæ¢å›æ¥...(ãƒã¸ï¿£ã€)\n\n### é€šè¿‡ API æ”¹å˜è¯ä¹¦(å¯èƒ½éœ€è¦ä»£ç†)\n\n#### è¾“å…¥ï¼ˆé€‚ç”¨äº Mac/Linuxï¼‰ï¼š\n\n```bash\ncurl -sX PATCH \"https://api.cloudflare.com/client/v4/zones/[DOMAIN_ZONE_ID_HERE]/ssl/universal/settings\" -H \"X-Auth-Email: [CLOUDFLARE_EMAIL_HERE]\" -H \"X-Auth-Key: [GLOBAL_API_KEY_HERE]\" -H \"Content-Type: application/json\" --data '{\"certificate_authority\":\"google\"}'\n```\n\n#### æˆ–è€…ï¼ˆå¯¹äº Windowsï¼‰ï¼š\n\n```bash\ncurl -sX PATCH \"https://api.cloudflare.com/client/v4/zones/[DOMAIN_ZONE_ID_HERE]/ssl/universal/settings\" -H \"X-Auth-Email: [CLOUDFLARE_EMAIL_HERE]\" -H \"X-Auth-Key: [GLOBAL_API_KEY_HERE]\" -H \"Content-Type: application/json\" --data \"{\\\"certificate_authority\\\":\\\"google\\\"}\"\n```\n\n`[DOMAIN_ZONE_ID_HERE]` æ›´æ”¹ä¸º Zone IDï¼Œä¹Ÿå°±æ˜¯æ§åˆ¶é¢æ¿æ˜¾ç¤ºçš„é‚£ä¸ª\n`[CLOUDFLARE_EMAIL_HERE]` ä¸º Cloudflare ç”µå­é‚®ä»¶åœ°å€\n`[GLOBAL_API_KEY_HERE]` ä¸ºå…¨å±€ API å¯†é’¥\n`æ³¨æ„ä¸è¦åŒ…å« \"[\" å’Œ \"]\"`\n\nè¿”å›ä»¥ä¸‹å†…å®¹ä»£è¡¨æˆåŠŸ\n\n`{\"result\":{\"enabled\":true,\"certificate_authority\":\"google\"},\"success\":true,\"errors\":[],\"messages\":[]}`\n\n#### æŸ¥çœ‹å½“å‰è¯ä¹¦(Linux)\n```bash\nopenssl s_client -connect yourdomain.com:443\n```","tags":["è§£å†³"],"categories":["æ‚é¡¹"]},{"title":"ç”¨FFmpegå®ç°ä¸€ä¸ªç®€å•å°å’–ç§€","url":"/2024/12/09/ç”¨FFmpegå®ç°ä¸€ä¸ªç®€å•å°å’–ç§€/","content":"\n### æ ¸å¿ƒä»£ç \n\n#### æ‰¾å…¶ä¸­ä¸€ä¸ªæºæ–‡ä»¶çš„éŸ³é¢‘æµ\n```c\nfor(int i = 0; i < ifmt1->nb_streams; i++){\n    AVStream *instream1 = ifmt1->streams[i];\n    AVStream *outstream = NULL;\n    AVCodecParameters *inCodecPar1 = instream1->codecpar;\n\n    if(inCodecPar1->codec_type == AVMEDIA_TYPE_AUDIO){\n        outstream = avformat_new_stream(ofmt, NULL);\n        if(!outstream){\n            av_log(NULL, AV_LOG_ERROR, \"åˆ›å»ºæµå¤±è´¥!\");\n            goto __ERROR;\n        }\n        avcodec_parameters_copy(outstream->codecpar, instream1->codecpar);\n        outstream->codecpar->codec_tag = 0;\n        aidx = i;\n        aidx1 = cnt++;\n    }\n}\n```\n\n\n#### æ‰¾å¦ä¸€ä¸ªæºæ–‡ä»¶çš„è§†é¢‘æµ\n\n```c\nfor(int i = 0; i < ifmt2->nb_streams; i++){\n    AVStream *instream2 = ifmt2->streams[i];\n    AVStream *outstream = NULL;\n    AVCodecParameters *inCodecPar2 = instream2->codecpar;\n\n    if(inCodecPar2->codec_type == AVMEDIA_TYPE_VIDEO){\n        outstream = avformat_new_stream(ofmt, NULL);\n        if(!outstream){\n            av_log(NULL, AV_LOG_ERROR, \"åˆ›å»ºæµå¤±è´¥!\");\n            goto __ERROR;\n        }\n        avcodec_parameters_copy(outstream->codecpar, instream2->codecpar);\n        outstream->codecpar->codec_tag = 0;\n        vidx = i;\n        vidx1 = cnt++;\n    }\n}\n```\n\n#### è¯»å–æºæ–‡ä»¶å¹¶å†™å…¥åˆ°ç›®æ ‡æ–‡ä»¶\n\n```c\nwhile(av_read_frame(ifmt1, &pkt1) >= 0 || av_read_frame(ifmt2, &pkt2) >= 0){\n    if(pkt1.stream_index == aidx){\n        pkt1.pts = av_rescale_q_rnd(pkt1.pts, ifmt1->streams[aidx]->time_base, ofmt->streams[aidx1]->time_base, (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));\n        pkt1.dts = pkt1.pts;\n        pkt1.stream_index = aidx1;\n        av_interleaved_write_frame(ofmt, &pkt1);\n        av_packet_unref(&pkt1);\n    }\n    if(pkt2.stream_index == vidx){\n        pkt2.pts = av_rescale_q_rnd(pkt2.pts, ifmt2->streams[vidx]->time_base, ofmt->streams[vidx1]->time_base, (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));\n        pkt2.dts = av_rescale_q_rnd(pkt2.dts, ifmt2->streams[vidx]->time_base, ofmt->streams[vidx1]->time_base, (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));\n        pkt2.stream_index = vidx1;\n        av_interleaved_write_frame(ofmt, &pkt2);\n        av_packet_unref(&pkt2);        \n    }\n}\n```","tags":["FFmpeg"],"categories":["éŸ³è§†é¢‘"]},{"title":"å®ç°FFmpegçš„è£å‰ª","url":"/2024/12/08/å®ç°FFmpegçš„è£å‰ª/","content":"\n### æ ¸å¿ƒä»£ç \n\n#### èµ·å§‹è¯»å…¥ä½ç½®åç§»åˆ°ä¸starttimeä½ç½®æœ€è¿‘çš„åä¸€ä¸ªå¸§\n```cpp\nret = av_seek_frame(pFmtCtx, -1, starttime * AV_TIME_BASE, AVSEEK_FLAG_BACKWARD);\nif(ret < 0){\n    av_log(oFmtCtx, AV_LOG_ERROR, \"%s\", av_err2str(ret));\n    goto __ERROR;\n}\n```\n\n#### ç”³è¯·å­˜å‚¨èµ·å§‹è¯»å…¥å¸§çš„å†…å­˜\n```cpp\n    dts_start_time = av_calloc(pFmtCtx->nb_streams, sizeof(int64_t));\n    pts_start_time = av_calloc(pFmtCtx->nb_streams, sizeof(int64_t));\n```\n\n#### ä»æºå¤šåª’ä½“æ–‡ä»¶ä¸­è¯»å–æ•°æ®åˆ°ç›®çš„æ–‡ä»¶ä¸­\n```cpp\nwhile(av_read_frame(pFmtCtx, &pkt) >= 0){\n\n    .....\n\n    //æ‹¿åˆ°èµ·å§‹è¯»å…¥å¸§çš„ptså’Œdts\n    if(pts_start_time[pkt.stream_index] == -1 && pkt.pts > 0 && pkt.dts > 0){\n        pts_start_time[pkt.stream_index] = pkt.pts;\n        dts_start_time[pkt.stream_index] = pkt.dts;\n    }\n\n    //åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»“æŸæ—¶é—´\n    if((pkt.pts * av_q2d(pFmtCtx->streams[pkt.stream_index]->time_base)) > endtime){\n        av_log(oFmtCtx, AV_LOG_INFO, \"success!\\n\");\n        break;\n    }\n\n    //ä¸å¼€å§‹çš„å¸§ç›¸å‡å¾—åˆ°ç›¸å¯¹çš„ptså’Œdts\n    pkt.pts -= pts_start_time[pkt.stream_index];\n    pkt.dts -= dts_start_time[pkt.stream_index];\n\n    //åœ¨å«æœ‰Bå¸§çš„æƒ…å†µï¼Œç¼–ç å™¨ä¼šå¯¹è§†é¢‘å¸§è¿›è¡Œé‡æ’ï¼Œä¼šå¯¼è‡´é€‰æ‹©çš„ç¬¬ä¸€ä¸ªè§†é¢‘å¸§çš„ptså¤§äºdtsã€‚\n    //è¿™å°±å¯¼è‡´äº†ptså’Œdtsç›¸åŒçš„å¸§ï¼Œåœ¨å¤„ç†åçš„ptsä¼šå°äºdtsè€Œå‘ç”Ÿé”™è¯¯, ä½†å¯¹dtsçš„å¤„ç†æ˜¯æ²¡æœ‰é—®é¢˜çš„\n    //æ‰€ä»¥åœ¨è¿™é‡Œå°†å®ƒé‡æ–°ä¸dtså¯¹é½\n    if(pkt.dts > pkt.pts){\n        pkt.pts = pkt.dts;\n    }\n\n    .....\n\n}\n```","tags":["FFmpeg"],"categories":["éŸ³è§†é¢‘"]},{"title":"å®ç°FFmpegçš„è§£å¤ç”¨","url":"/2024/12/06/å®ç°FFmpegçš„è§£å¤ç”¨/","content":"\n## ç¨‹åºæ­¥éª¤\n\n### 1. å¤„ç†å‚æ•°\n```cpp\nchar* src;  //è¾“å…¥æ•°æ®\nchar* dst;  //è¾“å‡ºæ•°æ®\n\nint *stream_map = NULL;\n\nAVFormatContext *pFmtCtx = NULL;\nAVFormatContext *oFmtCtx = NULL;\n\nAVPacket pkt;\n\nav_log_set_level(AV_LOG_DEBUG);\nif(argc < 3){ //argv[0] å°±æ˜¯è¿™ä¸ªextra_audioåå­—\n    av_log(NULL, AV_LOG_INFO, \"arguments must be more than 3!\");\n    exit(-1);\n}\n\nsrc = argv[1];\ndst = argv[2];\n```\n\n---\n\n### 2. é…ç½®è¾“å…¥ä¸Šä¸‹æ–‡ï¼Œæ‰“å¼€å¤šåª’ä½“æ–‡ä»¶\né€šè¿‡ avformat_open_input æ‰“å¼€è¾“å…¥çš„å¤šåª’ä½“æ–‡ä»¶ï¼Œå¹¶åˆå§‹åŒ–è¾“å…¥ä¸Šä¸‹æ–‡ï¼š\n```cpp\nif((ret = avformat_open_input(&pFmtCtx, src, NULL, NULL)) < 0){\n    av_log(NULL, AV_LOG_ERROR, \"%s\\n\", av_err2str(ret));\n    exit(-1);\n}\n```\n\n---\n\n### 3. é…ç½®è¾“å‡ºä¸Šä¸‹æ–‡\né€šè¿‡ avformat_alloc_output_context2 ä¸ºç›®æ ‡æ–‡ä»¶åˆ›å»ºè¾“å‡ºä¸Šä¸‹æ–‡ï¼š\n```cpp\navformat_alloc_output_context2(&oFmtCtx, NULL, NULL, dst);\nif(!oFmtCtx){\n    av_log(NULL ,AV_LOG_ERROR, \"NO MEMORY\");\n    goto __ERROR;\n}\n```\n\n---\n\n### 4. æ‰“å¼€è¾“å‡ºæ–‡ä»¶\né€šè¿‡ avio_open2 æ‰“å¼€ç›®æ ‡æ–‡ä»¶ï¼Œç”¨äºå†™å…¥å¤„ç†åçš„å¤šåª’ä½“æ•°æ®ï¼š\n```cpp\nret = avio_open2(&oFmtCtx->pb, dst, AVIO_FLAG_WRITE, NULL, NULL);\nif(ret < 0){\n    av_log(oFmtCtx, AV_LOG_ERROR, \"%s\", av_err2str(ret));\n    goto __ERROR;\n}\n```\n\n---\n\n### 5. åœ¨è¾“å‡ºä¸Šä¸‹æ–‡åˆ›å»ºæµ\néå†è¾“å…¥æ–‡ä»¶çš„æ‰€æœ‰æµï¼Œæ ¹æ®éœ€è¦åˆ›å»ºå¯¹åº”çš„è¾“å‡ºæµï¼ŒåŒæ—¶åˆå§‹åŒ– stream_mapï¼š\n```cpp\nstream_map = av_calloc(pFmtCtx->nb_streams, sizeof(int));\nif(!stream_map){\n    av_log(NULL ,AV_LOG_ERROR, \"NO MEMORY\");\n    goto __ERROR;\n}\n\nfor(int i = 0; i < pFmtCtx->nb_streams; i++){\n    AVStream *outStream = NULL;\n    AVStream *inStream = pFmtCtx->streams[i];\n    AVCodecParameters *inCodecPar = inStream->codecpar;\n    if(inCodecPar->codec_type != AVMEDIA_TYPE_AUDIO && inCodecPar->codec_type != AVMEDIA_TYPE_VIDEO && inCodecPar->codec_type != AVMEDIA_TYPE_SUBTITLE){\n        stream_map[i] = -1;\n        continue;\n    }\n    stream_map[i] = stream_idx++;\n    outStream = avformat_new_stream(oFmtCtx, NULL);\n    if(!outStream){\n        av_log(NULL ,AV_LOG_ERROR, \"NO MEMORY\");\n        goto __ERROR;\n    }\n\n    //è®¾ç½®è¾“å‡ºè§†é¢‘å‚æ•°\n    avcodec_parameters_copy(outStream->codecpar, inStream->codecpar);\n    outStream->codecpar->codec_tag = 0; //è‡ªåŠ¨è®¾ç½®ç¼–è§£ç å™¨ï¼Œå¯¹äºè¾“å‡ºæµåœ¨è¿™é‡Œæ˜¯è‡ªåŠ¨è®¾ç½®ç¼–ç å™¨\n}\n```\n\n---\n\n### 6. å†™å¤šåª’ä½“æ–‡ä»¶å¤´åˆ°ç›®çš„æ–‡ä»¶\n```cpp\nret = avformat_write_header(oFmtCtx, NULL);\nif(ret < 0){\n    av_log(oFmtCtx, AV_LOG_ERROR, \"%s\", av_err2str(ret));\n    goto __ERROR;\n}\n```\n\n---\n\n### 7. ä»æºå¤šåª’ä½“æ–‡ä»¶ä¸­è¯»å–æ•°æ®åˆ°ç›®çš„æ–‡ä»¶ä¸­\né€šè¿‡ av_read_frame è¯»å–è¾“å…¥æ–‡ä»¶çš„å¸§æ•°æ®ï¼Œå¹¶é€šè¿‡ av_interleaved_write_frame å°†å¤„ç†åçš„æ•°æ®å†™å…¥ç›®æ ‡æ–‡ä»¶ï¼š\n```cpp\nwhile(av_read_frame(pFmtCtx, &pkt) >= 0){\n    AVStream *inStream, *outStream;\n    if(stream_map[pkt.stream_index] < 0){\n        av_packet_unref(&pkt);\n        continue;\n    }\n    inStream = pFmtCtx->streams[pkt.stream_index];\n    pkt.stream_index = stream_map[pkt.stream_index];\n    outStream = oFmtCtx->streams[pkt.stream_index];\n    av_packet_rescale_ts(&pkt, inStream->time_base, outStream->time_base);\n    //æŸ¥çœ‹ffmpegæºç å¯ä»¥çŸ¥é“åœ¨å†™å…¥åŒ…ä¹‹å‰ä¼šæœ‰ä¸€ä¸ªguess_pkt_duration(s, st, pkt),è¿™ä¸ªå‡½æ•°ä¼šè‡ªåŠ¨è®¾ç½®duration\n    //pkt.pos = -1; //ç”¨äºç´¢å¼•æ ‡è¯†ï¼Œåœ¨ç‰¹æ®Šçš„åœºæ™¯ä¸‹å¯ä»¥ä½¿ç”¨ï¼Œæ¯”å¦‚åˆå¹¶å¤šä¸ªæ–‡ä»¶ã€‚\n    av_interleaved_write_frame(oFmtCtx, &pkt);\n    av_packet_unref(&pkt);\n}\n```\n\n---\n\n### 8. å†™å¤šåª’ä½“æ–‡ä»¶å°¾åˆ°æ–‡ä»¶ä¸­\n```cpp\nav_write_trailer(oFmtCtx);\n```\n\n---\n\n### 9. å°†ç”³è¯·çš„èµ„æºé‡Šæ”¾æ‰\n```cpp\n__ERROR:\nif(pFmtCtx){\n    avformat_close_input(&pFmtCtx);\n    pFmtCtx = NULL;\n}\nif(oFmtCtx->pb){\n    avio_close(oFmtCtx->pb);\n}\nif(oFmtCtx){\n    avformat_free_context(oFmtCtx);\n    oFmtCtx = NULL;\n}\nif(stream_map){\n    av_free(stream_map);\n}\n```","tags":["FFmpeg"],"categories":["éŸ³è§†é¢‘"]},{"title":"å¯¹ffmpegä¸­æ—¶é—´åŸºä¸æ—¶é—´æˆ³çš„ç†è§£","url":"/2024/12/05/å¯¹ffmpegä¸­æ—¶é—´åŸºä¸æ—¶é—´æˆ³çš„ç†è§£/","content":"\n### æ—¶é—´åŸºä¸æ—¶é—´æˆ³çš„åŸºæœ¬æ¦‚å¿µ\nåœ¨ FFmpeg ä¸­ï¼Œæ—¶é—´åŸº(time_base)æ˜¯æ—¶é—´æˆ³(timestamp)çš„å•ä½ï¼Œæ—¶é—´æˆ³å€¼ä¹˜ä»¥æ—¶é—´åŸºï¼Œå¯ä»¥å¾—åˆ°å®é™…çš„æ—¶åˆ»å€¼(ä»¥ç§’ç­‰ä¸ºå•ä½)ã€‚\n\n### ptså’Œdts\nè¿™é‡Œæˆ‘å°†ptså’Œdtsç®€å•çš„ç†è§£ä¸º`ptsæ˜¯æ’­æ”¾æ—¶é—´`ï¼Œ`dtsæ˜¯è§£ç æ—¶é—´`\nè§†é¢‘å¸§çš„è§£ç æ—¶é—´å’Œæ’­æ”¾æ—¶é—´å¯èƒ½ä¸åŒï¼Œå°¤å…¶æ˜¯å½“è§†é¢‘å¸§åŒ…å«Bå¸§æ—¶ã€‚\nå¯¹äºIå¸§ï¼Œè§£ç æ—¶é—´å’Œæ’­æ”¾æ—¶é—´ç›¸åŒã€‚è€ŒBå¸§å’ŒPå¸§çš„dtså’Œptså°±ä¼šä¸ä¸€æ ·ã€‚\néŸ³é¢‘å¸§çš„è§£ç æ—¶é—´å’Œæ’­æ”¾æ—¶é—´ç»å¤§å¤šæ•°çš„æƒ…å†µä¸‹æ˜¯ç›¸åŒçš„ï¼Œå› ä¸ºéŸ³é¢‘å¸§æŒ‰é¡ºåºè§£ç å¹¶æ’­æ”¾ã€‚\n\n### è§†é¢‘æµå’ŒéŸ³é¢‘æµptså’Œdtsçš„è®¾ç½®(åŸºäºè£¸æµ)\n#### è§†é¢‘æµ\n`è§†é¢‘æŒ‰å¸§æ’­æ”¾`ï¼Œæ‰€ä»¥è§£ç åçš„åŸå§‹è§†é¢‘å¸§æ—¶é—´åŸºä¸º 1/å¸§ç‡ã€‚  \nå¯¹äºä¸€èˆ¬çš„è§†é¢‘æµï¼Œæ—¶é—´åŸºçš„ `num` å’Œ `den` ä¸º 1 å’Œ 90000ï¼Œæ—¶é—´åŸºå°±æ˜¯ 1/90000ã€‚\nè¿™æ ·è®¡ç®—è§†é¢‘çš„æ—¶é—´æˆ³å°±æ˜¯ `index / 25 * 90000`ï¼Œ`index`æ˜¯å¸§æ ‡è¯†ï¼Œè¡¨ç¤ºç¬¬å‡ å¸§ã€‚\nå³ptså°±æ˜¯`index / 25 * 90000`\nè€Œdtsæˆ‘å‘ç°ä¸è®¾ç½®ä¹Ÿå¯ä»¥(ä½†å…·ä½“åŸå› æˆ‘ä¹Ÿä¸çŸ¥é“ï¼Œæœ‰çŸ¥é“çš„è¿˜è¯·ä¸€å®šæŒ‡ç‚¹ä¸€äºŒï¼Œæ‹œæ‰˜äº†`(à²¥ _ à²¥)`)\nå…¶ä¸­ï¼Œ`25` æ˜¯è§†é¢‘çš„å¸§ç‡ï¼ˆframes per secondï¼Œfpsï¼‰ï¼Œå³æ¯ç§’é’Ÿçš„å¸§æ•°ã€‚  \né€šè¿‡å°†æ—¶é—´æˆ³ä¹˜ä»¥æ—¶é—´åŸºï¼Œå¯ä»¥å¾—åˆ°å®é™…çš„æ’­æ”¾æ—¶é—´ã€‚\næ¢ç®—æˆæ—¶é—´åŸºçš„ç›®çš„ï¼Œä¸»è¦æ˜¯ä¸ºäº†ç»Ÿä¸€ä¸è§†é¢‘æµçš„æ—¶é—´å•ä½ï¼Œå°±åƒç»Ÿä¸€å›½é™…å•ä½ä¸€æ ·ï¼Œä¸åŒå¸§ç‡çš„è§†é¢‘æ—¶é—´æˆ³éƒ½æœ‰ç»Ÿä¸€çš„å•ä½ã€‚\nè¿™æ ·çš„æ¢ç®—ä¹Ÿèƒ½è¿›ä¸€æ­¥æé«˜ç²¾åº¦ã€‚\n\n#### éŸ³é¢‘æµ\n`éŸ³é¢‘æŒ‰é‡‡æ ·ç‚¹æ’­æ”¾`ï¼Œæ‰€ä»¥è§£ç åçš„åŸå§‹éŸ³é¢‘å¸§æ—¶é—´åŸºä¸º 1/é‡‡æ ·ç‡ã€‚  \nè¿™æ ·éŸ³é¢‘çš„æ—¶é—´æˆ³è®¾ç½®å°±æ˜¯é‡‡æ ·æ•°ï¼Œæ—¶é—´åŸºå°±æ˜¯é‡‡æ ·ç‡çš„å€’æ•°ã€‚å³ï¼Œé‡‡æ ·ç‡è¶Šé«˜ï¼Œæ¯ä¸ªé‡‡æ ·ç‚¹çš„æ—¶é—´åŸºå°±è¶Šå°ã€‚\n\n### é‡ç‚¹\nç†è§£è¿™äº›æœ€éœ€è¦è®°ä½çš„ä¸€ç‚¹æ˜¯ï¼š`æ—¶é—´åŸºä¹˜ä»¥æ—¶é—´æˆ³å¾—åˆ°çš„æ˜¯å®é™…æ—¶é—´`ã€‚","tags":["FFmpeg"],"categories":["éŸ³è§†é¢‘"]},{"title":"è§£å†³gitæ“ä½œpushå¤±è´¥çš„é—®é¢˜","url":"/2024/12/04/è§£å†³gitæ“ä½œpushå¤±è´¥çš„é—®é¢˜/","content":"\nä»ç½‘ä¸Šæ‰¾åˆ°äº†ä¸€ä¸ªæ•™ç¨‹ï¼Œè§£å†³äº†ä¸€ä¸ªçƒ¦äººçš„é—®é¢˜\n\n### è®¾ç½®ä»£ç†\n```bash\ngit config --global http.proxy http://127.0.0.1:7890  \ngit config --global https.proxy http://127.0.0.1:7890\n```\n\n### å–æ¶ˆå’ŒæŸ¥çœ‹ä»£ç†\n\n#### å–æ¶ˆä»£ç†\n```bash\ngit config --global --unset http.proxy  \ngit config --global --unset https.proxy\n```\n\n#### æŸ¥çœ‹ä»£ç†\n```bash\ngit config --global --get http.proxy  \ngit config --global --get https.proxy  \ngit config --list\n```\n\nåŸæ–‡é“¾æ¥ï¼š[https://blog.csdn.net/Naylor_5/article/details/135648311](https://blog.csdn.net/Naylor_5/article/details/135648311)","tags":["è§£å†³","git"],"categories":["æ‚é¡¹"]},{"title":"åˆ©ç”¨rtmpå¯¹æœ¬åœ°flvæ–‡ä»¶è¿›è¡Œæ¨æµ","url":"/2024/12/03/åˆ©ç”¨rtmpå¯¹æœ¬åœ°flvæ–‡ä»¶è¿›è¡Œæ¨æµ/","content":"\n### å®ç°äº†ä»ä¸€ä¸ª FLV æ–‡ä»¶è¯»å–éŸ³è§†é¢‘æ•°æ®ï¼Œå¹¶é€šè¿‡ RTMP åè®®è¿›è¡Œæ¨æµã€‚æ ¸å¿ƒæ­¥éª¤åŒ…æ‹¬ï¼š\n\n#### **FLV æ–‡ä»¶å¤´è§£æ (openfile)**  \n   - **åŠŸèƒ½**: æ‰“å¼€å¹¶è¯»å– FLV æ–‡ä»¶ï¼Œè·³è¿‡æ–‡ä»¶å¤´ï¼ˆ9 å­—èŠ‚ï¼‰ã€‚  \n   - **æ­¥éª¤**:\n     - æ‰“å¼€æŒ‡å®šçš„ FLV æ–‡ä»¶ã€‚\n     - æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æˆåŠŸæ‰“å¼€ã€‚å¦‚æœæ‰“å¼€å¤±è´¥ï¼Œåˆ™è¿”å› `nullptr`ã€‚\n     - è·³è¿‡æ–‡ä»¶å¤´çš„ 9 å­—èŠ‚ï¼Œå®šä½åˆ°æ•°æ®éƒ¨åˆ†ã€‚\n\n```cpp\nstatic QFile *openfile(char *flv_name) {\n    QFile *file = new QFile(flv_name);\n    if(!file->open(QFile::ReadOnly)){\n        qDebug() << \"æ–‡ä»¶æ‰“å¼€å¤±è´¥!\";\n        return nullptr;\n    }\n    file->seek(9); //è·³è¿‡ 9å­—èŠ‚ header\n    return file;\n}\n```\n\n#### **RTMP è¿æ¥ (connect_rtmp_server)**  \n   - **åŠŸèƒ½**: åˆå§‹åŒ– RTMP è¿æ¥åˆ° RTMP æœåŠ¡å™¨ã€‚  \n   - **æ­¥éª¤**:\n     - æ£€æŸ¥ RTMP åœ°å€æ˜¯å¦ä¸ºç©ºã€‚\n     - åˆ›å»ºå¹¶åˆå§‹åŒ– RTMP å¯¹è±¡ã€‚\n     - è®¾ç½® RTMP æœåŠ¡å™¨åœ°å€å’Œè¿æ¥è¶…æ—¶æ—¶é—´ã€‚\n     - è¿›è¡Œè¿æ¥ï¼Œå¹¶è®¾ç½®ä¸ºæ¨æµæ¨¡å¼ï¼ˆè°ƒç”¨ `RTMP_EnableWrite`ï¼‰ã€‚\n     - åˆ›å»ºå¹¶è¿æ¥æµã€‚\n\n```cpp\nstatic RTMP *connect_rtmp_server(char *rtmpaddr) {\n    if(rtmpaddr == NULL){\n        qDebug() << \"è¿æ¥çš„RTMPåœ°å€ä¸ºç©º!\";\n        return NULL;\n    }\n    RTMP *rtmp = nullptr;\n    rtmp = RTMP_Alloc();\n    RTMP_Init(rtmp);\n    if(!rtmp){\n        qDebug() << \"Failed to alloc RTMP object!\";\n        goto __ERROR;\n    }\n\n    RTMP_SetupURL(rtmp, rtmpaddr);\n    rtmp->Link.timeout = 10;\n\n    if(!RTMP_Connect(rtmp, NULL)){\n        qDebug() << \"Failed to connect RTMP Server!\";\n        goto __ERROR;\n    }\n\n    RTMP_EnableWrite(rtmp);\n    RTMP_ConnectStream(rtmp, 0);\n\n    return rtmp;\n__ERROR:\n    if(rtmp){\n        RTMP_Close(rtmp);\n        RTMP_Free(rtmp);\n    }\n    return NULL;\n}\n```\n\n#### **RTMP æ•°æ®åŒ…åˆ†é… (alloc_packet)**  \n   - **åŠŸèƒ½**: ä¸º RTMP æ•°æ®åŒ…åˆ†é…å†…å­˜å¹¶åˆå§‹åŒ–ã€‚  \n   - **æ­¥éª¤**:\n     - åˆ†é… `RTMPPacket` å†…å­˜ç©ºé—´ã€‚\n     - åˆ†é… 64KB å†…å­˜ç©ºé—´ç”¨äºæ•°æ®åŒ…ã€‚\n     - é‡ç½®æ•°æ®åŒ…å¹¶è®¾ç½®åˆå§‹å€¼ã€‚\n\n```cpp\nstatic RTMPPacket *alloc_packet() {\n    RTMPPacket *packet = NULL;\n    packet = (RTMPPacket *)malloc(sizeof(RTMPPacket));\n    if(!packet){\n        qDebug() << \"Failed to alloc RTMPPacket!\";\n        return NULL;\n    }\n\n    RTMPPacket_Alloc(packet, 64 * 1024);\n    RTMPPacket_Reset(packet);\n\n    packet->m_hasAbsTimestamp = 0;\n    packet->m_nChannel = 0x4;\n\n    return packet;\n}\n```\n\n#### **è¯»å– FLV æ•°æ®å¹¶å¡«å…… RTMP æ•°æ®åŒ… (read_data)**  \n   - **åŠŸèƒ½**: é€ä¸ªè¯»å– FLV æ–‡ä»¶ä¸­çš„æ•°æ®å—å¹¶å¡«å…… RTMP æ•°æ®åŒ…ã€‚  \n   - **æ­¥éª¤**:\n     - è·³è¿‡å‰ 4 å­—èŠ‚çš„ `pre-tag size`ã€‚\n     - è¯»å– tag typeã€tag data sizeã€æ—¶é—´æˆ³å’Œæµ IDã€‚\n     - è¯»å–å®é™…çš„ tag æ•°æ®ä½“ï¼Œå¹¶å°†å…¶å¡«å……åˆ° `RTMPPacket` ä¸­ã€‚\n\n```cpp\nstatic int read_data(QFile *file, RTMPPacket **packet) {\n    if (!file || !packet) {\n        qDebug() << \"Error: Invalid arguments.\";\n        return 0;\n    }\n\n    int ret = 0;\n    QByteArray tt, tag_data_size, ts, streamid;\n\n    file->read(4);  // è·³è¿‡ pre-tag size\n    tt = file->read(1);  // è¯»å– tag type\n    tag_data_size = file->read(3);  // è¯»å– tag data size\n\n    unsigned int tagDataSize = ((unsigned char)tag_data_size[0] << 16)\n                               | ((unsigned char)tag_data_size[1] << 8)\n                               | (unsigned char)tag_data_size[2];\n\n    if (file->bytesAvailable() < tagDataSize) {\n        qDebug() << \"Error: Insufficient data for tag body.\";\n        return 0;\n    }\n\n    ts = file->read(4);  // è¯»å–æ—¶é—´æˆ³\n    unsigned int timestamp = ((unsigned char)ts[0] << 16)\n                             | ((unsigned char)ts[1] << 8)\n                             | ((unsigned char)ts[2]);\n\n    streamid = file->read(3);  // è¯»å–æµ ID\n    QByteArray bodyData = file->read(tagDataSize);  // è¯»å– tag body\n\n    (*packet)->m_packetType = static_cast<unsigned char>(tt[0]);\n    std::memcpy((*packet)->m_body, bodyData.constData(), tagDataSize);\n    (*packet)->m_headerType = RTMP_PACKET_SIZE_LARGE;\n    (*packet)->m_nTimeStamp = timestamp;\n    (*packet)->m_nBodySize = tagDataSize;\n\n    qDebug() << \"tt:\" << static_cast<unsigned char>(tt[0])\n             << \"ts:\" << timestamp\n             << \"datasize:\" << tagDataSize;\n\n    ret = 1; // æˆåŠŸ\n    return ret;\n}\n```\n\n#### **æ¨æµåˆ° RTMP æœåŠ¡å™¨ (send_data)**  \n   - **åŠŸèƒ½**: ä» FLV æ–‡ä»¶ä¸­è¯»å–æ•°æ®å¹¶é€šè¿‡ RTMP åè®®å‘é€ã€‚  \n   - **æ­¥éª¤**:\n     - åˆ›å»º `RTMPPacket` å¯¹è±¡ã€‚\n     - é€ä¸ªè¯»å– FLV æ•°æ®åŒ…å¹¶å‘é€åˆ° RTMP æœåŠ¡å™¨ã€‚\n     - å¦‚æœè¿æ¥æ–­å¼€ï¼Œåˆ™ä¸­æ–­å‘é€ã€‚\n     - ä½¿ç”¨ `RTMP_SendPacket` å‘é€æ•°æ®åŒ…åˆ° RTMP æœåŠ¡å™¨ã€‚\n\n```cpp\nstatic void send_data(QFile *file, RTMP *rtmp) {\n    RTMPPacket *packet = alloc_packet();\n\n    while(read_data(file, &packet)) {\n        if(!RTMP_IsConnected(rtmp)) {\n            qDebug() << \"Disconnect...\";\n            break;\n        }\n\n        if(!RTMP_SendPacket(rtmp, packet, 0)) {\n            qDebug() << \"Failed to send packet!\";\n        }\n    }\n\n    qDebug() << \"å‘é€ç»“æŸ\";\n}\n```\n\n#### **RTMP æ¨æµæ•´ä½“çš„å°è£… (publish_stream)**  \n   - **åŠŸèƒ½**: å®Œæˆ FLV æ–‡ä»¶è¯»å–ã€RTMP è¿æ¥ã€æ•°æ®å‘é€ç­‰æ“ä½œã€‚  \n   - **æ­¥éª¤**:\n     - æ‰“å¼€ FLV æ–‡ä»¶å¹¶è¿æ¥åˆ° RTMP æœåŠ¡å™¨ã€‚\n     - å°† FLV æ–‡ä»¶ä¸­çš„éŸ³è§†é¢‘æ•°æ®é€ä¸ªå‘é€åˆ° RTMP æœåŠ¡å™¨ã€‚\n     - å®Œæˆæ¨æµåï¼Œå…³é—­æ–‡ä»¶ã€‚\n\n```cpp\nvoid publish_stream() {\n    char *rtmpaddr = (char *)\"rtmp://127.0.0.1:1935/live/stream01\";\n    QFile *file = openfile((char *)\"output.flv\");\n    if(!file) {\n        return;\n    }\n\n    RTMP *rtmp = connect_rtmp_server(rtmpaddr);\n    if(!rtmp) {\n        return;\n    }\n\n    send_data(file, rtmp);\n    file->close();\n}\n```\n\n#### **çº¿ç¨‹è¿è¡Œå…¥å£ (run)**  \n   - **åŠŸèƒ½**: åœ¨çº¿ç¨‹ä¸­æ‰§è¡Œå‘å¸ƒæµçš„æ“ä½œã€‚  \n   - **æ­¥éª¤**:\n     - åˆå§‹åŒ– Windows å¥—æ¥å­—åº“ (`WSAStartup`)ã€‚\n     - è°ƒç”¨ `publish_stream` å®Œæˆæ¨æµä»»åŠ¡ã€‚\n     - è°ƒç”¨ `WSACleanup` å…³é—­å¥—æ¥å­—åº“ã€‚\n\n```cpp\nvoid myRtmp::run() {\n    WSADATA wsaData;\n    int result = WSAStartup(MAKEWORD(2, 2), &wsaData);\n    if (result != 0) {\n        qDebug() << \"WSAStartup failed: \" << result;\n        return;\n    }\n    publish_stream();\n    WSACleanup();\n}\n```\n\n### ä¸»è¦ç»“æ„å’ŒåŠŸèƒ½ï¼š\n- **RTMP æµä¼ è¾“**: ä½¿ç”¨ RTMP åè®®æ¨é€ FLV æ–‡ä»¶æ•°æ®åˆ°æœåŠ¡å™¨ã€‚\n- **æ–‡ä»¶å¤„ç†**: ä» FLV æ–‡ä»¶ä¸­æå–éŸ³è§†é¢‘æ•°æ®å¹¶å¡«å……åˆ° RTMP æ•°æ®åŒ…ä¸­ã€‚\n- **å¤šçº¿ç¨‹æ”¯æŒ**: ä½¿ç”¨ `QThread` åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­æ‰§è¡Œæ¨æµä»»åŠ¡ã€‚","tags":["FLV","æ¨æµ","RTMP"],"categories":["éŸ³è§†é¢‘"]},{"title":"â‘ å®ç°ç”µè„‘éŸ³é¢‘å’Œè§†é¢‘çš„å½•åˆ¶å¹¶å°è£…æˆmp4","url":"/2024/12/02/â‘ å®ç°ç”µè„‘éŸ³é¢‘å’Œè§†é¢‘çš„å½•åˆ¶å¹¶å°è£…æˆmp4/","content":"\n### å¤´æ–‡ä»¶éƒ¨åˆ†\n\nå†…å®¹æ¯”è¾ƒå°‘ï¼Œæˆ‘å°±å…¨éƒ¨æ”¾è¿™äº†, è‡ªå·±çœ‹å§~\n\n```cpp\n#include \"AudioRecorder.h\"\n#include \"videoRecorder.h\"\n\n#include <QMainWindow>\n\nQT_BEGIN_NAMESPACE\nnamespace Ui {\nclass MainWindow;\n}\nQT_END_NAMESPACE\n\nclass MainWindow : public QMainWindow\n{\n    Q_OBJECT\n\npublic:\n    MainWindow(QWidget *parent = nullptr);\n    ~MainWindow();\n\n    int open_device(AVFormatContext **fmt_ctx);\n    int Main_av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt);\n    int Main_avformat_write_header(AVFormatContext *s, AVDictionary **options);\n\nprivate slots:\n    void on_pushButton_clicked();\n\nprivate:\n    Ui::MainWindow *ui;\n    AudioRecorder *aread;\n    VideoRecorder *vread;\n    // create file è®¾ç½®æ–‡ä»¶æ“ä½œå¯¹è±¡ç”¨äºå­˜å‚¨æ¶ˆæ¯\n    const char* outFilename = \"output.mp4\";\n    AVFormatContext *ofmt_ctx = nullptr; // è¾“å‡ºä¸Šä¸‹æ–‡\n    QReadWriteLock lock; // çº¿ç¨‹å®‰å…¨ï¼Œè¯»é” ä¸å…è®¸åœ¨è¯»å–æ—¶è¿›è¡Œä¿®æ”¹; å†™é” ä¸å…è®¸åœ¨å†™çš„æ—¶å€™è¿›è¡Œè¯»å†™ æ³¨æ„è¯»å†™é”ä¸èƒ½åŒ…å«åœ¨åŒä¸€ä¸ªä½œç”¨åŸŸé‡Œ\n};\n```\n\n### æºæ–‡ä»¶éƒ¨åˆ†\n\n```cpp\n#include \"./ui_mainwindow.h\"\n#include \"mainwindow.h\"\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n    aread = new AudioRecorder(this, &ofmt_ctx);\n    vread = new VideoRecorder(this, &ofmt_ctx);\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\nint MainWindow::Main_av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt)\n{\n    QWriteLocker locker(&lock); // å†™é”\n    return av_interleaved_write_frame(s, pkt);\n}\n\nint stream_nb = 0;\n\nint MainWindow::Main_avformat_write_header(AVFormatContext *s, AVDictionary **options)\n{\n    // å†™å¤´æ–‡ä»¶\n    stream_nb += 1;\n    if (stream_nb == 1) {\n        qDebug() << \"ç­‰å¾…ä¸‹ä¸€ä¸ªæµ\";\n        while (1) {\n            if (stream_nb == 2) return 1;\n        }\n    };\n    return avformat_write_header(ofmt_ctx, NULL);\n};\n\nvoid MainWindow::on_pushButton_clicked()\n{\n    if (!vread->flage) {\n        // é…ç½®è¾“å‡ºä¸Šä¸‹æ–‡\n        avformat_alloc_output_context2(&ofmt_ctx, NULL, NULL, outFilename);\n        if (!ofmt_ctx) {\n            qDebug() << \"åˆ›å»ºè¾“å‡ºä¸Šä¸‹æ–‡å¤±è´¥!\";\n            return;\n        }\n        // æ‰“å¼€è¾“å‡º\n        if (!(ofmt_ctx->oformat->flags & AVFMT_NOFILE)) {\n            // 2.3 åˆ›å»ºå¹¶åˆå§‹åŒ–ä¸€ä¸ªAVIOContext, ç”¨ä»¥è®¿é—®URLï¼ˆoutFilenameï¼‰æŒ‡å®šçš„èµ„æº\n            if (avio_open(&ofmt_ctx->pb, outFilename, AVIO_FLAG_WRITE) < 0) {\n                qDebug() << \"can't open output URL: %s\\n\" << outFilename;\n                return;\n            }\n        }\n        stream_nb = 0;\n        aread->flage = true;\n        vread->flage = true;\n        aread->start();\n        vread->start();\n        ui->pushButton->setText(\"åœæ­¢\");\n    } else {\n        aread->flage = false;\n        vread->flage = false;\n        aread->wait();\n        vread->wait();\n        av_write_trailer(ofmt_ctx);\n        /* close output */\n        if (ofmt_ctx && !(ofmt_ctx->oformat->flags & AVFMT_NOFILE)) {\n            avio_closep(&ofmt_ctx->pb);\n        }\n        avformat_free_context(ofmt_ctx);\n        ui->pushButton->setText(\"å¼€å§‹\");\n    }\n}\n```\n---\n\n### **æ€»ç»“**\né€šè¿‡å¤šçº¿ç¨‹, è°ƒç”¨FFmpegçš„APIï¼ŒéŸ³é¢‘é‡‡é›†éƒ¨åˆ†åˆ©ç”¨FIFOç¼“å†²åŒºå­˜å‚¨éŸ³é¢‘æ•°æ®ï¼Œè§†é¢‘é‡‡é›†éƒ¨åˆ†ç›´æ¥å­˜æ”¾äºpFrameYUVï¼ŒéŸ³é¢‘ç»è¿‡è§£ç ã€ç¼–ç æˆAACåè¿›è¡Œå†™å…¥ï¼Œè§†é¢‘ç»è¿‡è§£ç ã€ç¼–ç æˆH264åè¿›è¡Œå†™å…¥\nç¬¬ä¸€æ¬¡å†™ï¼Œæ„Ÿè§‰å†™çš„å¾ˆä¹±ï¼Œæœ‰å¾ˆå¤šä¸è¶³çš„åœ°æ–¹ã€‚ æœ‰ä¸å¥½çš„åœ°æ–¹å¯ä»¥å¸®å¿™æŒ‡å‡ºæ¥ è®©æˆ‘å·å·æ‡’å§~~~","tags":["FFmpeg","å¤šçº¿ç¨‹","QT","C++"],"categories":["éŸ³è§†é¢‘"]},{"title":"â‘¡å®ç°ç”µè„‘éŸ³é¢‘å’Œè§†é¢‘çš„å½•åˆ¶å¹¶å°è£…æˆmp4","url":"/2024/12/02/â‘¡å®ç°ç”µè„‘éŸ³é¢‘å’Œè§†é¢‘çš„å½•åˆ¶å¹¶å°è£…æˆmp4/","content":"\n\n## VideoRecorder ç±»è¯¦è§£\n\n### å¤´æ–‡ä»¶éƒ¨åˆ†\n\n```cpp\n// æ„é€ å‡½æ•°\nVideoRecorder(QObject* parent = nullptr, AVFormatContext **ofmt_ctx = nullptr);\n\n// å˜é‡\nvoid run() override;\nbool flage = false;\nAVFormatContext *fmt_ctx = NULL; // è¾“å…¥ä¸Šä¸‹æ–‡\nAVFormatContext **ofmt_ctx = NULL; // è¾“å‡ºä¸Šä¸‹æ–‡\nQObject *parent = NULL;\n```\n\n### æºæ–‡ä»¶éƒ¨åˆ†\n\né‡‡é›†è§†é¢‘çš„å…·ä½“æ­¥éª¤åˆ†ä¸º9æ­¥ï¼Œæ¶‰åŠä»¥ä¸‹å˜é‡ï¼š\n\n```cpp\nAVPacket pkt; // éŸ³é¢‘åŒ…\nAVPacket *H264pkt = av_packet_alloc();\nAVCodecContext *dec_ctx = NULL;\nAVCodecContext *H264_Codec_ctx = NULL;\nAVFrame *frame = av_frame_alloc();\nAVPacket *newpkt = av_packet_alloc();\nconst char* outFilename = \"output.mp4\"; // è¾“å‡ºæ–‡ä»¶\n```\n\n#### æ­¥éª¤ 1ï¼šæ‰“å¼€è§†é¢‘è®¾å¤‡\n\n```cpp\nopen_device(&fmt_ctx)\n```\n\n#### æ­¥éª¤ 2ï¼šæ‰“å¼€è§†é¢‘è§£ç å™¨\n\n```cpp\nopen_video_decoder(fmt_ctx, &dec_ctx)\n```\n\n#### æ­¥éª¤ 3ï¼šé…ç½®è§†é¢‘ç¼–ç å™¨å¹¶æ‰“å¼€\n\n```cpp\nopen_video_encoder(&H264_Codec_ctx, dec_ctx)\n```\n\n#### æ­¥éª¤ 4ï¼šåˆ›å»ºè¾“å‡ºæµ\n\n```cpp\n// åˆ›å»ºè¾“å‡ºæµ\nAVStream *outStream = avformat_new_stream(*ofmt_ctx, NULL);\navcodec_parameters_from_context(outStream->codecpar, H264_Codec_ctx); // åŒæ ·è¿™é‡Œä¹Ÿæ˜¯è¾“å‡ºè§†é¢‘æµçš„ç›¸å…³ä¿¡æ¯\n```\n\n#### æ­¥éª¤ 5ï¼šé…ç½®å›¾åƒé‡é‡‡æ ·ä¸Šä¸‹æ–‡\n\n```cpp\n// å›¾åƒæ ¼å¼è½¬æ¢ä¸Šä¸‹æ–‡\nSwsContext* pImgConvertCtx = sws_getContext(dec_ctx->width, dec_ctx->height,\n                                            dec_ctx->pix_fmt, dec_ctx->width, dec_ctx->height,\n                                            AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL);\n```\n\n#### æ­¥éª¤ 6ï¼šå†™å¤´æ–‡ä»¶\n\n```cpp\n// å†™å¤´æ–‡ä»¶\nCallbackFun writehead = std::bind(&MainWindow::Main_avformat_write_header, static_cast<MainWindow *>(parent), *ofmt_ctx, nullptr);\nwritehead();\n```\n\n#### æ­¥éª¤ 7ï¼šé…ç½®è§†é¢‘æ•°æ®å­˜å‚¨å®¹å™¨ pFrameYUV\n\n```cpp\n// åˆå§‹åŒ–å¸§ç¼–å·\nint64_t pts = 0;\n\nAVFrame *pFrameYUV = av_frame_alloc();\npFrameYUV->format = AV_PIX_FMT_YUV420P;\npFrameYUV->width = dec_ctx->width;\npFrameYUV->height = dec_ctx->height;\nav_frame_get_buffer(pFrameYUV, 0);\n```\n\n#### æ­¥éª¤ 8ï¼šè¯»å–æ•°æ®å¹¶å†™å…¥æ–‡ä»¶\n\n```cpp\n// ä½¿ç”¨ av_read_frame() è¯»å–éŸ³é¢‘æ•°æ®ï¼Œå¹¶å†™å…¥æ–‡ä»¶\n```\n\n#### æ­¥éª¤ 9ï¼šé‡Šæ”¾åˆ†é…çš„ç©ºé—´\n\n```cpp\n// é‡Šæ”¾ç¼“å†²åŒºçš„æ•°æ®å’Œç›¸å…³ä¸Šä¸‹æ–‡\nif(frame) av_frame_free(&frame);\nif(pFrameYUV) av_frame_free(&pFrameYUV);\nif(newpkt) av_packet_free(&newpkt);\n\nsws_freeContext(pImgConvertCtx);\n\n// å…³é—­è®¾å¤‡å¹¶é‡Šæ”¾ fmt_ctx èµ„æº\navformat_close_input(&fmt_ctx);\n```\n\n### open_device(&fmt_ctx)çš„å…·ä½“å®ç°\n\n```cpp\nint VideoRecorder::open_device(AVFormatContext **fmt_ctx){\n    const AVInputFormat * iformat = NULL;  // éŸ³è§†é¢‘æ•è·æ ¼å¼\n    AVDictionary *options = NULL;\n    QString devicename;  // éŸ³è§†é¢‘è®¾å¤‡åç§°\n\n    // æ³¨å†ŒéŸ³è§†é¢‘è®¾å¤‡\n    avdevice_register_all();\n\n    // è·å–éŸ³è§†é¢‘æ ¼å¼\n    iformat = av_find_input_format(\"dshow\");\n\n    // è·å–å½“å‰éŸ³è§†é¢‘è®¾å¤‡çš„æè¿°åç§°\n    // if (avdevice_list_input_sources(iformat, NULL, NULL, &device_list) >= 0) {\n    //     for (int i = 0; i < device_list->nb_devices; i++) {\n    //         qDebug() << \"Device: \" << device_list->devices[i]->device_description << Qt::endl;\n    //         if(i == 1) devicename = \"audio=\" + QString(device_list->devices[i]->device_description);\n    //     }\n    // }\n\n    // video=USB2.0 HD UVC WebCam æ‘„åƒå¤´è®¾å¤‡åç§° || audio=éº¦å…‹é£é˜µåˆ— (Realtek(R) Audio) éº¦å…‹é£è®¾å¤‡åç§°\n    // å¯ä»¥ç”¨å†’å·video=\"Camera\":audio=\"Microphone\" è¿›è¡ŒåŒæ—¶ä½¿ç”¨\n    devicename = \"video=USB2.0 HD UVC WebCam\";\n\n    av_dict_set(&options, \"video_size\", \"1280x720\", 0);\n    // av_dict_set(&options, \"pixel_fmt\", \"yuv420p\", 0);\n    av_dict_set(&options, \"framerate\", \"30\", 0);\n\n    // æ‰“å¼€è§†é¢‘æµè®¾å¤‡ å¹¶åˆå§‹åŒ–ä¸Šä¸‹æ–‡\n    if(avformat_open_input(fmt_ctx, devicename.toUtf8(), iformat, &options) < 0){\n        // av_strerror(ret, errors, 1024);\n        // qDebug() << \"Failed to open audio device: \" << ret << errors;\n        return 0;\n    };\n    return 1;\n}\n```\n\n### open_video_decoder(fmt_ctx, &dec_ctx)çš„å…·ä½“å®ç°\n\n```cpp\nint VideoRecorder::open_video_decoder(AVFormatContext *fmt_ctx, AVCodecContext **dec_ctx){\n    const AVCodec *dec;\n    int ret;\n\n    if((ret = avformat_find_stream_info(fmt_ctx, NULL)) < 0){\n        qDebug() << \"æ— æ³•è·å–æµä¿¡æ¯! \" << ret;\n        return 0;\n    };\n\n    // é€‰æ‹©è§†é¢‘æµ\n    ret = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, &dec, 0);\n    if(ret < 0){\n        qDebug() << \"æ— æ³•æ‰¾åˆ°è§†é¢‘æµ \" << ret;\n        return 0;\n    }\n\n    int video_stream_index = ret;\n\n    // åˆ›å»ºè§£ç å™¨ä¸Šä¸‹æ–‡,å¹¶åˆå§‹åŒ–ä¸Šä¸‹æ–‡\n    *dec_ctx = avcodec_alloc_context3(dec);\n    if(!*dec_ctx) return 0;\n    avcodec_parameters_to_context(*dec_ctx, fmt_ctx->streams[video_stream_index]->codecpar);\n\n    // æ‰“å¼€è§£ç å™¨\n    if((ret = avcodec_open2(*dec_ctx, dec, nullptr)) < 0){\n        qDebug() << \"è§£ç å™¨æ‰“å¼€å¤±è´¥! \" << ret;\n        return 0;\n    };\n\n    return 1;\n}\n```\n\n### open_video_encoder(&H264_Codec_ctx, dec_ctx)çš„å…·ä½“å®ç°\n\n```cpp\nint VideoRecorder::open_video_encoder(AVCodecContext **H264_Codec_ctx, AVCodecContext *dec_ctx){\n    AVDictionary *options = NULL;\n\n    av_dict_set(&options, \"preset\", \"superfast\", 0);\n    av_dict_set(&options, \"tune\", \"zerolatency\", 0);  // å®ç°å®æ—¶ç¼–ç \n\n    const AVCodec *H264_Codec = avcodec_find_encoder(AV_CODEC_ID_H264);\n    if(!H264_Codec){\n        qDebug() << \"æœªæ‰¾åˆ°H264ç¼–ç å™¨!\";\n        return 0;\n    }\n\n    *H264_Codec_ctx = avcodec_alloc_context3(H264_Codec);\n\n    // è®¾ç½®ç¼–ç å™¨æ ¼å¼\n    (*H264_Codec_ctx)->codec_id = AV_CODEC_ID_H264; // option\n    (*H264_Codec_ctx)->codec_type = AVMEDIA_TYPE_VIDEO; // option\n    (*H264_Codec_ctx)->pix_fmt = AV_PIX_FMT_YUV420P;\n\n    // è®¾ç½®SPS/PPS\n    (*H264_Codec_ctx)->profile = FF_PROFILE_H264_HIGH_444; // å‹ç¼©ç­‰çº§\n    (*H264_Codec_ctx)->level = 50; // è´¨é‡ç­‰çº§ä¸º5.0\n\n    // è®¾ç½®åˆ†è¾¨ç‡\n    (*H264_Codec_ctx)->width = dec_ctx->width;\n    (*H264_Codec_ctx)->height = dec_ctx->height;\n\n    // è®¾ç½®GOP\n    (*H264_Codec_ctx)->gop_size = 250;\n    (*H264_Codec_ctx)->keyint_min = 25; // æœ€å°æ’å…¥Iå¸§çš„å¸§æ•° åœ¨ç½‘ç»œä¸¢å¸§æ—¶ç”¨äºæ¢å¤ option\n\n    // è®¾ç½®Bå¸§æ•°æ®å¯å‡å°ç æµ\n    (*H264_Codec_ctx)->max_b_frames = 3; // å¯è¿ç»­çš„æœ€å¤§Bå¸§æ•°é‡ option\n    (*H264_Codec_ctx)->has_b_frames = 1; // æŒ‡ç¤ºç¼–ç å™¨æ˜¯å¦ç”Ÿæˆ B å¸§ä»¥åŠè§£ç å™¨æ˜¯å¦éœ€è¦å¤„ç† B å¸§ option\n\n    // è®¾ç½®å‚è€ƒå¸§æ•°é‡å¯æå‡è¿˜åŸåº¦\n    (*H264_Codec_ctx)->refs = 3; // option\n\n    // è®¾ç½®å¸§ç‡\n    (*H264_Codec_ctx)->time_base.num = 1\n\n;\n    (*H264_Codec_ctx)->time_base.den = 30;\n\n    // è®¾ç½®æ¯”ç‰¹ç‡\n    (*H264_Codec_ctx)->bit_rate = 3420000;\n\n    // æ‰“å¼€ç¼–ç å™¨\n    if((avcodec_open2(*H264_Codec_ctx, H264_Codec, &options)) < 0){\n        qDebug() << \"H264 ç¼–ç å™¨æ‰“å¼€å¤±è´¥!\";\n        return 0;\n    }\n\n    return 1;\n}\n```\n\n### æ•°æ®çš„è¯»å–ä¸å†™å…¥çš„å…·ä½“å®ç°\n\n```cpp\nwhile(flage && av_read_frame(fmt_ctx, &pkt) == 0){\n    int ret = avcodec_send_packet(dec_ctx, &pkt);\n    if(ret < 0) return;\n\n    while(ret >= 0){\n        ret = avcodec_receive_frame(dec_ctx, frame);\n        if(ret < 0){\n            if(ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) break;\n            return;\n        }\n        sws_scale(pImgConvertCtx, (const unsigned char* const*)frame->data, frame->linesize, 0, dec_ctx->height, pFrameYUV->data, pFrameYUV->linesize);\n\n        ret = avcodec_send_frame(H264_Codec_ctx, pFrameYUV);\n        if(ret < 0) return;\n\n        while(ret >= 0){\n            ret = avcodec_receive_packet(H264_Codec_ctx, H264pkt);\n            if(ret < 0){\n                if(ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) break;\n                return;\n            }\n\n            // ç¼–ç åPTSã€DTSèµ‹å€¼\n            H264pkt->pts = H264pkt->dts = pts * (*ofmt_ctx)->streams[video_stream_index]->time_base.den / (*ofmt_ctx)->streams[video_stream_index]->time_base.num / 30;\n            H264pkt->stream_index = video_stream_index;\n\n            CallbackFun write = std::bind(&MainWindow::Main_av_interleaved_write_frame, static_cast<MainWindow *>(parent), *ofmt_ctx, H264pkt);\n            write();\n\n            pts++;\n            av_packet_unref(H264pkt);\n        }\n        av_frame_unref(frame);\n    }\n    av_packet_unref(&pkt); // Free the packet data after each read\n}\n```","tags":["FFmpeg","QT","H264"],"categories":["éŸ³è§†é¢‘"]},{"title":"â‘¢å®ç°ç”µè„‘éŸ³é¢‘å’Œè§†é¢‘çš„å½•åˆ¶å¹¶å°è£…æˆmp4","url":"/2024/12/01/â‘¢å®ç°ç”µè„‘éŸ³é¢‘å’Œè§†é¢‘çš„å½•åˆ¶å¹¶å°è£…æˆmp4/","content":"\n### **éŸ³è§†é¢‘å½•åˆ¶çš„å¤šçº¿ç¨‹å®ç°**\n\n#### **ä¸»è¦ç±»**\n- **AudioRecorder**ï¼šéŸ³é¢‘é‡‡é›†çº¿ç¨‹\n- **VideoRecorder**ï¼šè§†é¢‘é‡‡é›†çº¿ç¨‹\n- **MainWindow**ï¼šæ§åˆ¶éŸ³é¢‘å’Œè§†é¢‘çš„é‡‡é›†\n\n---\n\n### **AudioRecorder ç±»è¯¦è§£**\n\n#### **å¤´æ–‡ä»¶éƒ¨åˆ†**\n- **æ„é€ å‡½æ•°**ï¼š\n  ```cpp\n  AudioRecorder(QObject *parent = nullptr, AVFormatContext **ofmt_ctx = nullptr);\n  ```\n\n- **ä¸»è¦å˜é‡**ï¼š\n  - `bool flage = false;`  // ç”¨äºæ§åˆ¶é‡‡é›†çš„å¼€å§‹ä¸ç»“æŸ\n  - `AVFormatContext *fmt_ctx = NULL;`  // è¾“å…¥ä¸Šä¸‹æ–‡\n  - `AVFormatContext **ofmt_ctx = NULL;`  // è¾“å‡ºä¸Šä¸‹æ–‡\n  - `QObject *parent = NULL;`  // ç”¨äºå›è°ƒå‡½æ•°\n\n\n#### æºæ–‡ä»¶éƒ¨åˆ†\n\né‡‡é›†éŸ³é¢‘çš„å…·ä½“æ­¥éª¤å¯ä»¥åˆ†ä¸º10ä¸ªæ­¥éª¤ï¼Œä½¿ç”¨åˆ°çš„å˜é‡æœ‰ï¼š\n\n- `AVPacket pkt;`ï¼šéŸ³é¢‘åŒ…\n- `int nb_samples = 22050;`ï¼šæ¯å¸§æ ·æœ¬æ•°\n- `SwrContext *swr_ctx = nullptr;`ï¼šé‡é‡‡æ ·ä¸Šä¸‹æ–‡\n- `uint8_t **src_data = nullptr; uint8_t **dst_data = nullptr;`ï¼šéŸ³é¢‘æ•°æ®ç¼“å†²åŒº\n- `AVCodecContext *codec_ctx = nullptr;`ï¼šç¼–ç ä¸Šä¸‹æ–‡\n- `AVCodecContext *dec_ctx = nullptr;`ï¼šè§£ç ä¸Šä¸‹æ–‡\n- `AVFrame *frame = av_frame_alloc();`ï¼šéŸ³é¢‘å¸§\n- `AVAudioFifo* fifo = nullptr;`ï¼šéŸ³é¢‘FIFOç¼“å†²åŒº\n- `const char* outFilename = \"output.mp4\";`ï¼šè¾“å‡ºæ–‡ä»¶å\n\n#### **éŸ³é¢‘é‡‡é›†æ­¥éª¤**\n1. **æ‰“å¼€è®¾å¤‡**  \n   ```cpp\n   open_device(&fmt_ctx);\n   ```\n\n2. **æŸ¥æ‰¾å¹¶æ‰“å¼€éŸ³é¢‘è§£ç å™¨**  \n   ```cpp\n   open_Audio_decoder(fmt_ctx, &dec_ctx);\n   ```\n\n3. **æ‰“å¼€AACç¼–ç å™¨**  \n   ```cpp\n   open_encoder(&codec_ctx);\n   ```\n\n4. **å»ºç«‹FIFOç¼“å†²åŒº**  \n   ```cpp\n   fifo = init_audio_fifo(codec_ctx->sample_fmt, codec->ch_layout.nb_channels);\n   ```\n\n5. **é…ç½®é‡é‡‡æ ·ä¸Šä¸‹æ–‡ï¼ˆå¦‚æœéœ€è¦ï¼Œæ ¹æ®ç¼–ç å™¨çš„è¾“å…¥è¦æ±‚ï¼‰**  \n   ```cpp\n   init_resampler(codec_ctx, &swr_ctx, &src_data, &dst_data);\n   ```\n\n6. **åˆ›å»ºè¾“å‡ºæµ**  \n   ```cpp\n   AVStream *outStream = avformat_new_stream(*ofmt_ctx, NULL);\n   ```\n\n7. **å†™å¤´æ–‡ä»¶ï¼ˆé€šè¿‡å›è°ƒæ–¹å¼ï¼‰**\n\nä¸ºäº†ç¡®ä¿éŸ³é¢‘æµå’Œè§†é¢‘æµéƒ½åˆ›å»ºå¥½åå†å†™å…¥å¤´æ–‡ä»¶ï¼Œæˆ‘é‡‡ç”¨äº†å›è°ƒå‡½æ•°çš„æ–¹å¼ã€‚FFmpegåœ¨å†™å…¥å¤´æ–‡ä»¶æ—¶è¦æ±‚æ‰€æœ‰æµéƒ½å·²ç»åˆ›å»ºå¥½ï¼Œå› æ­¤æˆ‘ä»¬é€šè¿‡å›è°ƒæœºåˆ¶ç¡®ä¿éŸ³é¢‘æµå’Œè§†é¢‘æµçš„åˆ›å»ºé¡ºåºã€‚\n\n#### **å›è°ƒå‡½æ•°çš„å®ç°**\n\nåœ¨ä»£ç ä¸­ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªå›è°ƒå‡½æ•°åˆ«åï¼Œå¹¶å°†å…¶ä¸`MainWindow`çš„`Main_avformat_write_header`æ–¹æ³•ç»‘å®šï¼Œç¡®ä¿åœ¨åˆé€‚çš„æ—¶æœºè°ƒç”¨è¯¥å‡½æ•°æ¥å†™å…¥å¤´æ–‡ä»¶ã€‚\n\n```cpp\n// å®šä¹‰å›è°ƒå‡½æ•°åˆ«åï¼Œç»‘å®šåˆ° MainWindow::Main_avformat_write_header æ–¹æ³•\nCallbackFun writehead = std::bind(&MainWindow::Main_avformat_write_header, \n                                   static_cast<MainWindow *>(parent), \n                                   *ofmt_ctx, nullptr);\n\n// è°ƒç”¨å›è°ƒå‡½æ•°æ‰§è¡Œå†™å…¥å¤´æ–‡ä»¶æ“ä½œ\nwritehead();\n```\n\n#### **è§£é‡Š**\n\n- `std::bind`ï¼šè¯¥æ–¹æ³•å°†`MainWindow::Main_avformat_write_header`å‡½æ•°ä¸`parent`ï¼ˆ`MainWindow`ï¼‰å¯¹è±¡ç»‘å®šï¼Œå¹¶ä¼ å…¥å¿…è¦çš„å‚æ•°ã€‚\n- é€šè¿‡å›è°ƒçš„æ–¹å¼ï¼Œåªæœ‰åœ¨éŸ³é¢‘å’Œè§†é¢‘æµéƒ½å‡†å¤‡å¥½åæ‰ä¼šè°ƒç”¨`Main_avformat_write_header`æ–¹æ³•è¿›è¡Œå¤´æ–‡ä»¶å†™å…¥ï¼Œç¡®ä¿FFmpegæ­£ç¡®åœ°å†™å…¥å¤´æ–‡ä»¶ã€‚\n\n#### **ä¸ºä»€ä¹ˆè¦ä½¿ç”¨å›è°ƒ**\n\nFFmpegçš„`avformat_write_header()`å‡½æ•°è¦æ±‚åœ¨å†™å…¥æ–‡ä»¶å¤´ä¹‹å‰ï¼Œæ‰€æœ‰æµéƒ½å¿…é¡»è¢«åˆ›å»ºå¹¶åˆå§‹åŒ–ã€‚å› æ­¤ï¼Œåœ¨åˆ›å»ºéŸ³é¢‘å’Œè§†é¢‘æµåï¼Œæˆ‘ä»¬é€šè¿‡å›è°ƒå‡½æ•°æ¥ç¡®ä¿å¤´æ–‡ä»¶çš„å†™å…¥æ—¶æœºæ˜¯æ­£ç¡®çš„ã€‚\n\n\n8. **é…ç½®è§£ç åæ•°æ®çš„frameå®¹å™¨åŠéŸ³é¢‘å¸§**\n\n```cpp\n    //è·å–frame_size\n    const int frame_size = codec_ctx->frame_size;\n    // åˆå§‹åŒ–å¸§ç¼–å·\n    int64_t pts = 0;\n\n    frame->nb_samples = dec_ctx->frame_size;\n    frame->sample_rate = dec_ctx->sample_rate;\n    frame->ch_layout = dec_ctx->ch_layout;\n    frame->format = dec_ctx->sample_fmt;\n```\n\n9. **ç”¨ `av_read_frame()` è¯»å–éŸ³é¢‘æ•°æ®å¹¶å†™å…¥æ–‡ä»¶**\n\n\n10. **é‡Šæ”¾åˆ†é…çš„ç©ºé—´**\n\n```cpp\n    // é‡Šæ”¾ç¼“å†²åŒºçš„æ•°æ®å’Œç›¸å…³ä¸Šä¸‹æ–‡\n    if(src_data){\n        av_freep(&src_data[0]);\n        av_freep(&src_data);\n    }\n    if(dst_data){\n        av_freep(&dst_data[0]);\n        av_freep(&dst_data);\n    }\n    if(swr_ctx)swr_free(&swr_ctx);\n    if(frame)av_frame_free(&frame);\n    if(newpkt)av_packet_free(&newpkt);\n    if(fifo)av_audio_fifo_free(fifo);\n\n    // close device and Release fmt_ctx resources å…³é—­è®¾å¤‡å¹¶é‡Šæ”¾ä¸Šä¸‹æ–‡\n    avformat_close_input(&fmt_ctx);\n```\n\n---\n\n### **open_device(&fmt_ctx) çš„å…·ä½“å®ç°**\n\n```cpp\nint AudioRecorder::open_device(AVFormatContext **fmt_ctx) {\n    const AVInputFormat * iformat = NULL;  // éŸ³è§†é¢‘æ•è·æ ¼å¼\n    AVDictionary *options = NULL;\n    QString devicename;  // éŸ³è§†é¢‘è®¾å¤‡åç§°\n\n    avdevice_register_all();  // æ³¨å†ŒéŸ³è§†é¢‘è®¾å¤‡\n\n    // è·å–éŸ³è§†é¢‘æ ¼å¼\n    iformat = av_find_input_format(\"dshow\");\n\n    // è·å–å½“å‰éŸ³é¢‘è®¾å¤‡çš„æè¿°åç§°\n    devicename = \"audio=éº¦å…‹é£é˜µåˆ— (Realtek(R) Audio)\";\n\n    if (avformat_open_input(fmt_ctx, devicename.toUtf8(), iformat, &options) < 0) {\n        return 0;  // æ‰“å¼€è®¾å¤‡å¤±è´¥\n    }\n    return 1;  // æˆåŠŸæ‰“å¼€è®¾å¤‡\n}\n```\n\n---\n\n### **open_Audio_decoder() çš„å…·ä½“å®ç°**\n\n```cpp\nint AudioRecorder::open_Audio_decoder(AVFormatContext **fmt_ctx) {\n    const AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_AAC);\n    if (!codec) {\n        qDebug() << \"éŸ³é¢‘è§£ç å™¨æœªæ‰¾åˆ°\";\n        return 0;  // æœªæ‰¾åˆ°è§£ç å™¨\n    }\n    \n    // æ‰“å¼€éŸ³é¢‘è§£ç å™¨\n    if (avcodec_open2(dec_ctx, codec, nullptr) < 0) {\n        qDebug() << \"æ— æ³•æ‰“å¼€è§£ç å™¨\";\n        return 0;\n    }\n    \n    return 1;  // æˆåŠŸæ‰“å¼€è§£ç å™¨\n}\n```\n\n---\n\n### **open_encoder() çš„å…·ä½“å®ç°**\n\n```cpp\nint AudioRecorder::open_encoder(AVCodecContext **codec_ctx) {\n    AVDictionary *options = NULL;\n    const AVCodec *codec = avcodec_find_encoder_by_name(\"libfdk_aac\");\n    if (!codec) {\n        qDebug() << \"ç¼–ç å™¨ libfdk_aac æœªæ‰¾åˆ°\";\n        return 0;\n    }\n\n    // åˆ†é…ç¼–ç å™¨ä¸Šä¸‹æ–‡\n    *codec_ctx = avcodec_alloc_context3(codec);\n    if (!*codec_ctx) {\n        qDebug() << \"ç¼–ç å™¨ä¸Šä¸‹æ–‡åˆ†é…å¤±è´¥\";\n        return 0;\n    }\n\n    // è®¾ç½®ç¼–ç å™¨å‚æ•°\n    AVChannelLayout ch_layout;\n    av_channel_layout_default(&ch_layout, 2);  // ç«‹ä½“å£°å¸ƒå±€\n    (*codec_ctx)->sample_rate = 48000;  // é‡‡æ ·ç‡\n    (*codec_ctx)->sample_fmt = AV_SAMPLE_FMT_S16;  // æ ·æœ¬æ ¼å¼\n    (*codec_ctx)->bit_rate = 128000;  // æ¯”ç‰¹ç‡\n    if (av_channel_layout_copy(&(*codec_ctx)->ch_layout, &ch_layout) < 0) {\n        qDebug() << \"è®¾ç½®é€šé“å¸ƒå±€å¤±è´¥\";\n        return 0;\n    }\n\n    // æ‰“å¼€ç¼–ç å™¨\n    if (avcodec_open2(*codec_ctx, codec, &options) < 0) {\n        qDebug() << \"ç¼–ç å™¨æ‰“å¼€å¤±è´¥\";\n        return 0;\n    }\n\n    return 1;  // æˆåŠŸæ‰“å¼€ç¼–ç å™¨\n}\n```\n\n---\n\n### **FIFOç¼“å†²åŒºå®ç°**\n\n```cpp\nAVAudioFifo* AudioRecorder::init_audio_fifo(AVSampleFormat sample_fmt, int channels) {\n    AVAudioFifo* fifo = av_audio_fifo_alloc(sample_fmt, channels, 1);\n    if (!fifo) {\n        qDebug() << \"æ— æ³•åˆ†é…FIFOç¼“å†²åŒº\";\n        return nullptr;\n    }\n    return fifo;\n}\n\nint AudioRecorder::write_to_fifo(AVAudioFifo* fifo, const uint8_t** data, int nb_samples) {\n    int ret = av_audio_fifo_write(fifo, (void**)data, nb_samples);\n    if (ret < nb_samples) {\n        qDebug() << \"å†™å…¥FIFOå¤±è´¥\";\n        return -1;\n    }\n    return 0;  // æˆåŠŸå†™å…¥\n}\n\nint AudioRecorder::read_from_fifo(AVAudioFifo* fifo, uint8_t** data, int frame_size) {\n    int ret = av_audio_fifo_read(fifo, (void**)data, frame_size);\n    if (ret < frame_size) {\n        qDebug() << \"ä»FIFOè¯»å–å¤±è´¥\";\n        return -1;\n    }\n    return 0;  // æˆåŠŸè¯»å–\n}\n```\n\n---\n\n### **init_resampler() çš„å…·ä½“å®ç°**\n\n```cpp\nint AudioRecorder::init_resampler(AVCodecContext *codec_ctx, SwrContext **swr_ctx, uint8_t ***src_data, uint8_t ***dst_data) {\n    *swr_ctx = swr_alloc();\n    AVChannelLayout in_ch_layout;\n    av_channel_layout_default(&in_ch_layout, 2);  // ç«‹ä½“å£°å¸ƒå±€\n\n    // é…ç½®é‡é‡‡æ ·ä¸Šä¸‹æ–‡\n    swr_alloc_set_opts2(swr_ctx,\n                        &codec_ctx->ch_layout,          // è¾“å‡ºé€šé“å¸ƒå±€\n                        codec_ctx->sample_fmt,          // è¾“å‡ºé‡‡æ ·æ ¼å¼\n                        codec_ctx->sample_rate,         // è¾“å‡ºé‡‡æ ·ç‡\n                        &in_ch_layout,                 // è¾“å…¥é€šé“å¸ƒå±€\n                        AV_SAMPLE_FMT_S16,              // è¾“å…¥é‡‡æ ·æ ¼å¼\n                        48000,                         // è¾“å…¥é‡‡æ ·ç‡\n                        0, nullptr);\n\n    if (!*swr_ctx || swr_init(*swr_ctx) < 0) {\n        qDebug() << \"é‡é‡‡æ ·åˆå§‹åŒ–å¤±è´¥\";\n        return 0;\n    }\n\n    // åˆ›å»ºè¾“å…¥è¾“å‡ºç¼“å†²åŒº\n    av_samples_alloc_array_and_samples(src_data, nullptr, in_ch_layout.nb_channels, 22050, AV_SAMPLE_FMT_S16, 0);\n    av_samples_alloc_array_and_samples(dst_data, nullptr, 2, 22050, codec_ctx->sample_fmt, 0);\n    \n    return 1;  // æˆåŠŸ\n}\n```\n\n---\n\n### **éŸ³é¢‘æ•°æ®è¯»å–ä¸å†™å…¥æ–‡ä»¶è¿‡ç¨‹**\n\n```cpp\n //å¼€å§‹è·å–éŸ³é¢‘å¸§æ•°æ®ï¼Œå¹¶è¿›è¡Œè½¬æ¢\n    while (flage && av_read_frame(fmt_ctx, &pkt) == 0) {\n        // qDebug() << \"pkt size: \" << pkt.size;\n        // qDebug() << \"pkt data: \" << pkt.data << Qt::endl;\n\n        //å†…å­˜æ‹·è´\n        //memcpy(src_data[0], pkt.data, pkt.size); //åªä½¿ç”¨ç¬¬ä¸€ä¸ªç¼“å†²åŒº\n        //å¦‚æœæœ‰éœ€è¦åœ¨å†™å…¥æ–‡ä»¶ä¹‹å‰è¿›è¡Œé‡é‡‡æ ·\n        //swr_convert(swr_ctx, dst_data, nb_samples, src_data, nb_samples);\n        int ret = avcodec_send_packet(dec_ctx, &pkt);\n        if(ret < 0){\n            qDebug() << \"å‘è§£ç å™¨å‘é€æ•°æ®åŒ…å¤±è´¥!\";\n            return;\n        }\n        while(ret >= 0){\n            ret = avcodec_receive_frame(dec_ctx, frame);\n            if(ret < 0){\n                if(ret == AVERROR(EAGAIN) || ret == AVERROR_EOF){\n                    break;\n                }\n                qDebug() << \"Error, decoding video frame\";\n                return;\n            }\n            // memcpy(src_data[0], frame->data, 22300);\n            // swr_convert(swr_ctx, dst_data, nb_samples, src_data, nb_samples);\n\n            //å°†æ ·æœ¬æ•°æ®å†™å…¥ FIFO\n            write_to_fifo(fifo, (const uint8_t**)frame->data, nb_samples);\n            while (av_audio_fifo_size(fifo) >= frame_size) {\n                read_from_fifo(fifo, frame->data, frame_size);\n                frame->nb_samples = codec_ctx->frame_size;\n                frame->pts = pts;\n                ret = avcodec_send_frame(codec_ctx, frame);\n                if(ret < 0){\n                    qDebug() << \"å‘ç¼–ç å™¨å‘é€æ•°æ®åŒ…å¤±è´¥!\";\n                    return;\n                }\n                while(ret >= 0){\n                    ret = avcodec_receive_packet(codec_ctx, newpkt);\n                    if(ret < 0){\n                        if(ret == AVERROR(EAGAIN) || ret == AVERROR_EOF){\n                            break;\n                        }\n                        qDebug() << \"Error, encoding video frame\";\n                        return;\n                    }\n                    newpkt->pts = newpkt->dts = pts;\n                    newpkt->stream_index = audio_stream_index;\n                    //av_interleaved_write_frame(*ofmt_ctx, newpkt);\n                    CallbackFun write = std::bind(&MainWindow::Main_av_interleaved_write_frame, static_cast<MainWindow *>(parent), *ofmt_ctx, newpkt);\n                    write();\n                    av_packet_unref(newpkt);\n                }\n                pts += frame_size;\n            }\n            av_frame_unref(frame);\n        }\n        av_packet_unref(&pkt); // Free the packet data after each read\n    }\n```","tags":["FFmpeg","QT","AAC"],"categories":["éŸ³è§†é¢‘"]},{"title":"SQLåŸºç¡€","url":"/2024/11/28/SQLåŸºç¡€/","content":"\n# æ•°æ®åº“çº¦æŸä¸é«˜çº§æ“ä½œæ€»ç»“\n\n## çº¦æŸ\n\n### æ¦‚å¿µ\nçº¦æŸæ˜¯ä½œç”¨äºè¡¨ä¸­å­—æ®µä¸Šçš„è§„åˆ™ï¼Œç”¨äºé™åˆ¶å­˜å‚¨åœ¨è¡¨ä¸­çš„æ•°æ®ã€‚\n\n**ç›®çš„**: ä¿è¯æ•°æ®åº“ä¸­æ•°æ®çš„æ­£ç¡®æ€§ã€æœ‰æ•ˆæ€§å’Œå®Œæ•´æ€§ã€‚\n\n**åˆ†ç±»**:\n- **éç©ºçº¦æŸ**: é™åˆ¶å­—æ®µæ•°æ®ä¸èƒ½ä¸º NULL  \n  ```sql\n  NOT NULL\n  ```\n\n- **å”¯ä¸€çº¦æŸ**: ä¿è¯å­—æ®µæ•°æ®å”¯ä¸€ã€ä¸é‡å¤  \n  ```sql\n  UNIQUE\n  ```\n\n- **ä¸»é”®çº¦æŸ**: ä¸»é”®æ˜¯è¡Œæ•°æ®çš„å”¯ä¸€æ ‡è¯†ï¼Œè¦æ±‚éç©ºä¸”å”¯ä¸€  \n  ```sql\n  PRIMARY KEY\n  ```\n\n- **é»˜è®¤çº¦æŸ**: ä¿å­˜æ•°æ®æ—¶æœªæŒ‡å®šå­—æ®µå€¼ï¼Œåˆ™é‡‡ç”¨é»˜è®¤å€¼  \n  ```sql\n  DEFAULT\n  ```\n\n- **æ£€æŸ¥çº¦æŸ** (8.0.16ç‰ˆæœ¬ä¹‹å): ä¿è¯å­—æ®µå€¼æ»¡è¶³æ¡ä»¶  \n  ```sql\n  CHECK\n  ```\n\n- **å¤–é”®çº¦æŸ**: ç”¨æ¥å»ºç«‹è¡¨é—´æ•°æ®çš„å…³è”ï¼Œä¿è¯ä¸€è‡´æ€§ä¸å®Œæ•´æ€§  \n  ```sql\n  FOREIGN KEY\n  ```\n\n---\n\n### å¤–é”®çº¦æŸ\n\n#### æ¦‚å¿µ\nå¤–é”®ç”¨äºåœ¨ä¸¤å¼ è¡¨ä¹‹é—´å»ºç«‹æ•°æ®è¿æ¥ï¼Œä¿è¯æ•°æ®çš„ä¸€è‡´æ€§å’Œå®Œæ•´æ€§ã€‚\n\n#### è¯­æ³•\n- **æ·»åŠ å¤–é”®**\n  ```sql\n  CREATE TABLE è¡¨å (\n    å­—æ®µå æ•°æ®ç±»å‹,\n    ...\n    [CONSTRAINT å¤–é”®åç§°] FOREIGN KEY (å¤–é”®å­—æ®µå) REFERENCES ä¸»è¡¨ (ä¸»è¡¨åˆ—å)\n  );\n\n  ALTER TABLE è¡¨å ADD CONSTRAINT å¤–é”®åç§° FOREIGN KEY (å¤–é”®å­—æ®µå) REFERENCES ä¸»è¡¨ (ä¸»è¡¨åˆ—å);\n  ```\n\n- **åˆ é™¤å¤–é”®**\n  ```sql\n  ALTER TABLE è¡¨å DROP FOREIGN KEY å¤–é”®åç§°;\n  ```\n\n#### åˆ é™¤/æ›´æ–°è¡Œä¸º\n- `NO ACTION`: æ£€æŸ¥å¤–é”®å…³è”ï¼Œä¸å…è®¸åˆ é™¤/æ›´æ–°ã€‚\n- `RESTRICT`: ä¸ `NO ACTION` ç±»ä¼¼ï¼Œä¸å…è®¸åˆ é™¤/æ›´æ–°ã€‚\n- `CASCADE`: åˆ é™¤/æ›´æ–°çˆ¶è¡¨è®°å½•æ—¶ï¼ŒåŒæ—¶åˆ é™¤/æ›´æ–°å­è¡¨è®°å½•ã€‚\n- `SET NULL`: åˆ é™¤çˆ¶è¡¨è®°å½•æ—¶ï¼Œå°†å­è¡¨å¤–é”®å­—æ®µè®¾ç½®ä¸º `NULL`ã€‚\n- `SET DEFAULT`: è®¾ç½®å­è¡¨å¤–é”®å­—æ®µä¸ºé»˜è®¤å€¼ï¼ˆInnoDB ä¸æ”¯æŒï¼‰ã€‚\n\n**ç¤ºä¾‹**:\n```sql\nALTER TABLE è¡¨å ADD CONSTRAINT å¤–é”®åç§° FOREIGN KEY (å¤–é”®å­—æ®µ) REFERENCES ä¸»è¡¨å (ä¸»è¡¨å­—æ®µå) ON UPDATE CASCADE ON DELETE CASCADE;\n```\n\n---\n\n## å¤šè¡¨æŸ¥è¯¢\n\n### æ¦‚è¿°\nå¤šè¡¨æŸ¥è¯¢æŒ‡ä»å¤šå¼ è¡¨ä¸­è·å–æ•°æ®ã€‚  \néœ€è¦é¿å…æ— æ•ˆçš„ **ç¬›å¡å°”ç§¯**ï¼Œå³ä¸¤å¼ è¡¨ä¸­æ‰€æœ‰æ•°æ®çš„ç»„åˆã€‚\n\n### å¤šè¡¨æŸ¥è¯¢åˆ†ç±»\n1. **è¿æ¥æŸ¥è¯¢**\n   - **å†…è¿æ¥**: è·å–ä¸¤å¼ è¡¨äº¤é›†éƒ¨åˆ†çš„æ•°æ®ã€‚\n   - **å·¦è¿æ¥**: è·å–å·¦è¡¨æ‰€æœ‰æ•°æ®åŠäº¤é›†éƒ¨åˆ†æ•°æ®ã€‚\n   - **å³è¿æ¥**: è·å–å³è¡¨æ‰€æœ‰æ•°æ®åŠäº¤é›†éƒ¨åˆ†æ•°æ®ã€‚\n   - **è‡ªè¿æ¥**: è¡¨ä¸è‡ªèº«çš„è¿æ¥æŸ¥è¯¢ï¼Œå¿…é¡»ä½¿ç”¨è¡¨åˆ«åã€‚\n\n2. **å­æŸ¥è¯¢**  \n   åœ¨ SQL è¯­å¥ä¸­åµŒå¥— `SELECT` è¯­å¥ï¼Œç§°ä¸ºåµŒå¥—æŸ¥è¯¢æˆ–å­æŸ¥è¯¢ã€‚\n\n#### å†…è¿æ¥\n- **éšå¼å†…è¿æ¥**\n  ```sql\n  SELECT å­—æ®µåˆ—è¡¨ FROM è¡¨1, è¡¨2 WHERE æ¡ä»¶;\n  ```\n\n- **æ˜¾ç¤ºå†…è¿æ¥**\n  ```sql\n  SELECT å­—æ®µåˆ—è¡¨ FROM è¡¨1 [INNER] JOIN è¡¨2 ON è¿æ¥æ¡ä»¶;\n  ```\n\n#### è‡ªè¿æ¥\nè‡ªè¿æ¥æ˜¯å°†ä¸€å¼ è¡¨è§†ä¸ºä¸¤å¼ è¡¨ï¼Œè®¾ç½®è¡¨åˆ«åè¿›è¡ŒæŸ¥è¯¢ã€‚\n\n---\n\n## äº‹åŠ¡\n\n### æ¦‚å¿µ\näº‹åŠ¡æ˜¯ä¸€ç»„æ“ä½œçš„é›†åˆï¼Œæ˜¯ä¸€ä¸ªä¸å¯åˆ†å‰²çš„å·¥ä½œå•ä½ã€‚  \näº‹åŠ¡ä¸­çš„æ‰€æœ‰æ“ä½œè¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥ã€‚\n\n### äº‹åŠ¡æ“ä½œ\n- **æŸ¥çœ‹/è®¾ç½®äº‹åŠ¡æäº¤æ–¹å¼**\n  ```sql\n  SELECT @@autocommit; -- 1 è¡¨ç¤ºè‡ªåŠ¨æäº¤ï¼Œ0 è¡¨ç¤ºæ‰‹åŠ¨æäº¤\n\n  SET @@autocommit = 0;\n  ```\n\n- **å¼€å¯äº‹åŠ¡**\n  ```sql\n  START TRANSACTION;\n  ```\n\n- **æäº¤äº‹åŠ¡**\n  ```sql\n  COMMIT;\n  ```\n\n- **å›æ»šäº‹åŠ¡**\n  ```sql\n  ROLLBACK;\n  ```\n\n### äº‹åŠ¡å¹¶å‘é—®é¢˜\n1. **è„è¯»**: è¯»å–åˆ°æœªæäº¤çš„æ•°æ®ã€‚\n2. **ä¸å¯é‡å¤è¯»**: ä¸€æ¬¡äº‹åŠ¡ä¸­ï¼Œæ•°æ®å¤šæ¬¡è¯»å–ç»“æœä¸åŒã€‚\n3. **å¹»è¯»**: ä¸€æ¬¡äº‹åŠ¡ä¸­æ–°å¢æˆ–åˆ é™¤æ•°æ®å¯¼è‡´æ€»è®°å½•æ•°ä¸ä¸€è‡´ã€‚\n\n### äº‹åŠ¡éš”ç¦»çº§åˆ«\n| éš”ç¦»çº§åˆ«           | è„è¯» | ä¸å¯é‡å¤è¯» | å¹»è¯» |\n|--------------------|-------|------------|-------|\n| Read uncommitted  | ä¼š    | ä¼š         | ä¼š    |\n| Read committed    | ä¸ä¼š  | ä¼š         | ä¼š    |\n| Repeatable Read   | ä¸ä¼š  | ä¸ä¼š       | ä¼š    |\n| Serializable      | ä¸ä¼š  | ä¸ä¼š       | ä¸ä¼š  |\n\n- **æŸ¥çœ‹äº‹åŠ¡éš”ç¦»çº§åˆ«**\n  ```sql\n  SELECT @@TRANSACTION_ISOLATION;\n  ```\n\n- **è®¾ç½®äº‹åŠ¡éš”ç¦»çº§åˆ«**\n  ```sql\n  SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE};\n  ```","tags":["æ•°æ®åº“","SQL"],"categories":["SQL"]},{"title":"å››ç§SQLè¯­å¥","url":"/2024/11/28/å››ç§SQLè¯­å¥/","content":"\n# æ•°æ®åº“æ“ä½œä¸å‘½ä»¤æ€»ç»“\n\n## DLL å®šä¹‰\n\n### æ•°æ®åº“æ“ä½œ\n```sql\nSHOW DATABASES;\n\nCREATE DATABASE æ•°æ®åº“è¡¨å;\n\nUSE æ•°æ®åº“å;\n\nSELECT DATABASE(); -- å±•ç¤ºå½“å‰æ‰€åœ¨çš„æ•°æ®åº“\n\nDROP DATABASE æ•°æ®åº“å; -- åˆ é™¤æ•°æ®åº“\n```\n\n### è¡¨æ“ä½œ\n```sql\nSHOW TABLES;\n\nCREATE TABLE è¡¨å (å­—æ®µ å­—æ®µç±»å‹, ...);\n\nDESC è¡¨å; -- æŸ¥çœ‹å½“å‰çš„è¡¨ç»“æ„\n\nSHOW CREATE TABLE è¡¨å;\n\nDROP TABLE è¡¨å;\n```\n\n### è¡¨æ“ä½œ - ä¿®æ”¹\n- **æ·»åŠ å­—æ®µ**\n  ```sql\n  ALTER TABLE è¡¨å ADD å­—æ®µå ç±»å‹(é•¿åº¦) [COMMENT æ³¨é‡Š] [çº¦æŸ];\n  ```\n\n- **ä¿®æ”¹å­—æ®µç±»å‹**\n  ```sql\n  ALTER TABLE è¡¨å MODIFY å­—æ®µå æ•°æ®ç±»å‹(é•¿åº¦);\n  ```\n\n- **ä¿®æ”¹å­—æ®µåå’Œå­—æ®µç±»å‹**\n  ```sql\n  ALTER TABLE è¡¨å CHANGE æ—§å­—æ®µå æ–°å­—æ®µå ç±»å‹(é•¿åº¦) [COMMENT æ³¨é‡Š] [çº¦æŸ];\n  ```\n\n- **åˆ é™¤å­—æ®µ**\n  ```sql\n  ALTER TABLE è¡¨å DROP å­—æ®µå;\n  ```\n\n- **ä¿®æ”¹è¡¨å**\n  ```sql\n  ALTER TABLE è¡¨å RENAME TO æ–°è¡¨å;\n  ```\n\n- **åˆ é™¤è¡¨**\n  ```sql\n  DROP TABLE [IF EXISTS] è¡¨å;\n  ```\n\n- **åˆ é™¤å¹¶é‡æ–°åˆ›å»ºè¡¨**\n  ```sql\n  TRUNCATE TABLE è¡¨å;\n  ```\n\n---\n\n## DML ä¿®æ”¹\n\n### æ·»åŠ æ•°æ® (INSERT)\n```sql\n-- ç»™æŒ‡å®šå­—æ®µæ·»åŠ æ•°æ®\nINSERT INTO è¡¨å (å­—æ®µå1, å­—æ®µå2...) VALUES (å€¼1, å€¼2, ...);\n\n-- ç»™å…¨éƒ¨å­—æ®µæ·»åŠ æ•°æ®\nINSERT INTO è¡¨å VALUES (å€¼1, å€¼2, ...);\n\n-- æ‰¹é‡æ·»åŠ æ•°æ®\nINSERT INTO è¡¨å (å­—æ®µå1, å­—æ®µå...) VALUES (å€¼1, å€¼2...), (å€¼1, å€¼2...), ...;\n\nINSERT INTO è¡¨å VALUES (å€¼1, å€¼2...), (å€¼1, å€¼2...), ...;\n```\n\n### ä¿®æ”¹æ•°æ® (UPDATE)\n```sql\nUPDATE è¡¨å SET å­—æ®µå1 = å€¼1, å­—æ®µå2 = å€¼2, ... [WHERE æ¡ä»¶];\n```\n\n### åˆ é™¤æ•°æ® (DELETE)\n```sql\nDELETE FROM è¡¨å [WHERE æ¡ä»¶];\n-- æ³¨æ„: ä¸èƒ½åˆ é™¤æŸä¸ªå­—æ®µçš„å€¼, è¦ç”¨ UPDATE;\n```\n\n---\n\n## DQL æŸ¥è¯¢\n\n### åŸºæœ¬æŸ¥è¯¢\n```sql\n-- æŸ¥è¯¢å¤šä¸ªå­—æ®µ\nSELECT å­—æ®µ1, å­—æ®µ2, ... FROM è¡¨å;\n\nSELECT * FROM è¡¨å;\n\n-- è®¾ç½®åˆ«å\nSELECT å­—æ®µ1 [AS åˆ«å1], å­—æ®µ2 [AS åˆ«å2], ... FROM è¡¨å;\n\n-- å»é™¤é‡å¤è®°å½•\nSELECT DISTINCT å­—æ®µåˆ—è¡¨ FROM è¡¨å;\n```\n\n### æ¡ä»¶æŸ¥è¯¢\n```sql\nSELECT å­—æ®µåˆ—è¡¨ FROM è¡¨å WHERE æ¡ä»¶åˆ—è¡¨;\n-- å¸¸è§æ¡ä»¶:\n<> æˆ– !=      -- ä¸ç­‰äº\nBETWEEN ... AND ... -- åœ¨èŒƒå›´å†… (å«æœ€å¤§æœ€å°å€¼)\nIN (...)      -- åœ¨åˆ—è¡¨ä¸­\nLIKE å ä½ç¬¦    -- æ¨¡ç³ŠåŒ¹é… (_åŒ¹é…å•å­—ç¬¦, %åŒ¹é…ä»»æ„å­—ç¬¦)\nIS NULL       -- æ˜¯ NULL\n```\n\n### èšåˆå‡½æ•°\n```sql\n-- å¸¸è§èšåˆå‡½æ•°:\nCOUNT -- ç»Ÿè®¡æ•°é‡\nMAX   -- æœ€å¤§å€¼\nMIN   -- æœ€å°å€¼\nAVG   -- å¹³å‡å€¼\nSUM   -- æ±‚å’Œ\n\n-- ä½¿ç”¨ç¤ºä¾‹:\nSELECT èšåˆå‡½æ•°(å­—æ®µåˆ—è¡¨) FROM è¡¨å;\n```\n\n### åˆ†ç»„æŸ¥è¯¢\n```sql\nSELECT å­—æ®µåˆ—è¡¨ FROM è¡¨å [WHERE æ¡ä»¶] GROUP BY åˆ†ç»„å­—æ®µå [HAVING åˆ†ç»„åè¿‡æ»¤æ¡ä»¶];\n```\n\n### æ’åºæŸ¥è¯¢\n```sql\nSELECT å­—æ®µåˆ—è¡¨ FROM è¡¨å ORDER BY å­—æ®µ1 æ’åºæ–¹å¼1, å­—æ®µ2 æ’åºæ–¹å¼2;\n-- æ’åºæ–¹å¼:\n-- ASC : å‡åº (é»˜è®¤å€¼)\n-- DESC: é™åº\n```\n\n### åˆ†é¡µæŸ¥è¯¢\n```sql\nSELECT å­—æ®µåˆ—è¡¨ FROM è¡¨å LIMIT èµ·å§‹ç´¢å¼•, æŸ¥è¯¢è®°å½•æ•°;\n```\n\n---\n\n## DCL æ§åˆ¶\n\n### ç”¨æˆ·ç®¡ç†\n```sql\n-- æŸ¥è¯¢ç”¨æˆ·\nUSE mysql;\nSELECT * FROM user;\n\n-- åˆ›å»ºç”¨æˆ·\nCREATE USER 'ç”¨æˆ·å'@'ä¸»æœºå' IDENTIFIED BY 'å¯†ç ';\n\n-- ä¿®æ”¹ç”¨æˆ·å¯†ç \nALTER USER 'ç”¨æˆ·å'@'ä¸»æœºå' IDENTIFIED WITH mysql_native_password BY 'æ–°å¯†ç ';\n\n-- åˆ é™¤ç”¨æˆ·\nDROP USER 'ç”¨æˆ·å'@'ä¸»æœºå';\n```\n\n### æƒé™æ§åˆ¶\n- **å¸¸ç”¨æƒé™**\n  ```text\n  ALL, ALL PRIVILEGES -- æ‰€æœ‰æƒé™\n  SELECT              -- æŸ¥è¯¢æ•°æ®\n  INSERT              -- æ’å…¥æ•°æ®\n  UPDATE              -- ä¿®æ”¹æ•°æ®\n  DELETE              -- åˆ é™¤æ•°æ®\n  ALTER               -- ä¿®æ”¹è¡¨\n  DROP                -- åˆ é™¤æ•°æ®åº“/è¡¨/è§†å›¾\n  CREATE              -- åˆ›å»ºæ•°æ®åº“/è¡¨\n  ```\n\n- **æŸ¥è¯¢æƒé™**\n  ```sql\n  SHOW GRANTS FOR 'ç”¨æˆ·å'@'ä¸»æœºå';\n  ```\n\n- **æˆäºˆæƒé™**\n  ```sql\n  GRANT æƒé™åˆ—è¡¨ ON æ•°æ®åº“.è¡¨å TO 'ç”¨æˆ·å'@'ä¸»æœºå';\n  ```\n\n- **æ’¤é”€æƒé™**\n  ```sql\n  REVOKE æƒé™åˆ—è¡¨ ON æ•°æ®åº“.è¡¨å FROM 'ç”¨æˆ·å'@'ä¸»æœºå';\n  ```\n  > æ³¨æ„: æ•°æ®åº“.è¡¨å å¯ä»¥ä½¿ç”¨é€šé…ç¬¦ `*.*` è¡¨ç¤ºæ‰€æœ‰æ•°æ®åº“çš„æ‰€æœ‰è¡¨ã€‚","tags":["æ•°æ®åº“","SQL"],"categories":["SQL"]},{"title":"FFmpeg åŸºæœ¬å‘½ä»¤","url":"/2024/11/28/FFmpeg åŸºæœ¬å‘½ä»¤/","content":"\n# FFmpeg ä½¿ç”¨å‘½ä»¤\n\n## æŸ¥è¯¢å¯ç”¨è®¾å¤‡\n```bash\nffmpeg -list_devices true -f dshow -i dummy\n```\n\n---\n\n## å½•åˆ¶\n\n- **æ‘„åƒå¤´å½•åˆ¶**\n  ```bash\n  ffmpeg -f dshow -r 30 -i video=\"USB2.0 HD UVC WebCam\" output.yuv\n  ```\n\n- **éº¦å…‹é£å½•åˆ¶**\n  ```bash\n  ffmpeg -f dshow -i audio=\"éº¦å…‹é£é˜µåˆ— (Realtek(R) Audio)\" output.pcm\n  ```\n\n---\n\n## æ’­æ”¾\n\n- **æ’­æ”¾è§†é¢‘**\n  ```bash\n  ffplay -i output.yuv -video_size 1280x720 -framerate 30 -pixel_format yuvj422p\n  ```\n\n- **æ’­æ”¾éŸ³é¢‘**\n  ```bash\n  ffplay -i output.pcm -ar 48000 -f s16le\n  ```\n\n---\n\n## å¤„ç†åŸå§‹æ•°æ®\n\n- **æå– YUV è§†é¢‘æ•°æ®**\n  ```bash\n  ffmpeg -i input.mp4 -an -c:v rawvideo -pixel_format yuv420p out.yuv\n  ```\n\n- **æå– PCM éŸ³é¢‘æ•°æ®**\n  ```bash\n  ffmpeg -i input.mp4 -vn -ar 48000 -channels 2 -f s16le output.pcm\n  ```\n\n---\n\n## è§†é¢‘æ»¤é•œ\n\n- **è£å‰ªè§†é¢‘å®½é«˜å„å‡ 200**\n  ```bash\n  ffmpeg -i input.mp4 -vf crop=in_w-200:in_h-200 -c:v libx264 -c:a copy output.mp4\n  ```\n\n- **ä»æŒ‡å®šæ—¶é—´å¼€å§‹è£å‰ª 10 ç§’**\n  ```bash\n  ffmpeg -i input.mp4 -ss 00:00:00 -t 10 output.mp4\n  ```\n\n- **æ‹¼æ¥å¤šä¸ªè§†é¢‘**\n  ```bash\n  ffmpeg -f concat -i input.txt output.mp4\n  ```\n  > `input.txt` æ–‡ä»¶å†…å®¹ç¤ºä¾‹ï¼š\n  > ```txt\n  > file 'file1.mp4'\n  > file 'file2.mp4'\n  > ```\n\n---\n\n## å›¾ç‰‡ä¸è§†é¢‘è½¬æ¢\n\n- **å°†è§†é¢‘è½¬æ¢ä¸ºå›¾ç‰‡**\n  ```bash\n  ffmpeg -i input.mp4 -r 1 -f image2 image-%3d.jpeg\n  ```\n\n- **å°†å›¾ç‰‡è½¬æ¢ä¸ºè§†é¢‘**\n  ```bash\n  ffmpeg -i image-%3d.jpeg out.mp4\n  ```\n\n# FFprobe ä½¿ç”¨å‘½ä»¤\n\n## è·å–è§†é¢‘å¸§ä¿¡æ¯\n  ```bash\n  ffprobe -show_frames -select_streams v:0 -print_format json output.mp4\n  ```\n## å­¦ä¹ ä¸­...","tags":["FFmpeg"],"categories":["éŸ³è§†é¢‘"]}]